import {
  CancellationTokenSource,
  Emitter,
  KeyCode,
  KeyMod,
  MarkerSeverity,
  MarkerTag,
  Position,
  Range,
  Selection,
  SelectionDirection,
  Token,
  Uri,
  editor$2,
  languages$2
} from "./chunk-YPCN2EIP.js";
import "./chunk-KWQPLJ7U.js";
import "./chunk-CZRJEBC5.js";
import {
  __publicField
} from "./chunk-JJCHJJ73.js";

// ../../node_modules/.pnpm/@vue+repl@3.4.0/node_modules/@vue/repl/dist/chunks/highlight-CJzieDKQ.js
var monaco = Object.freeze(Object.defineProperty({
  __proto__: null,
  CancellationTokenSource,
  Emitter,
  KeyCode,
  KeyMod,
  MarkerSeverity,
  MarkerTag,
  Position,
  Range,
  Selection,
  SelectionDirection,
  Token,
  Uri,
  editor: editor$2,
  languages: languages$2
}, Symbol.toStringTag, { value: "Module" }));
var FontStyle;
(function(FontStyle2) {
  FontStyle2[FontStyle2["NotSet"] = -1] = "NotSet";
  FontStyle2[FontStyle2["None"] = 0] = "None";
  FontStyle2[FontStyle2["Italic"] = 1] = "Italic";
  FontStyle2[FontStyle2["Bold"] = 2] = "Bold";
  FontStyle2[FontStyle2["Underline"] = 4] = "Underline";
})(FontStyle || (FontStyle = {}));
({
  InDebugMode: typeof process !== "undefined" && !!process.env["VSCODE_TEXTMATE_DEBUG"]
});
var EncodedTokenAttributes;
(function(EncodedTokenAttributes2) {
  function toBinaryStr(encodedTokenAttributes) {
    return encodedTokenAttributes.toString(2).padStart(32, "0");
  }
  EncodedTokenAttributes2.toBinaryStr = toBinaryStr;
  function print(encodedTokenAttributes) {
    const languageId = EncodedTokenAttributes2.getLanguageId(encodedTokenAttributes);
    const tokenType = EncodedTokenAttributes2.getTokenType(encodedTokenAttributes);
    const fontStyle = EncodedTokenAttributes2.getFontStyle(encodedTokenAttributes);
    const foreground = EncodedTokenAttributes2.getForeground(encodedTokenAttributes);
    const background = EncodedTokenAttributes2.getBackground(encodedTokenAttributes);
    console.log({
      languageId,
      tokenType,
      fontStyle,
      foreground,
      background
    });
  }
  EncodedTokenAttributes2.print = print;
  function getLanguageId(encodedTokenAttributes) {
    return (encodedTokenAttributes & 255) >>> 0;
  }
  EncodedTokenAttributes2.getLanguageId = getLanguageId;
  function getTokenType(encodedTokenAttributes) {
    return (encodedTokenAttributes & 768) >>> 8;
  }
  EncodedTokenAttributes2.getTokenType = getTokenType;
  function containsBalancedBrackets(encodedTokenAttributes) {
    return (encodedTokenAttributes & 1024) !== 0;
  }
  EncodedTokenAttributes2.containsBalancedBrackets = containsBalancedBrackets;
  function getFontStyle(encodedTokenAttributes) {
    return (encodedTokenAttributes & 30720) >>> 11;
  }
  EncodedTokenAttributes2.getFontStyle = getFontStyle;
  function getForeground(encodedTokenAttributes) {
    return (encodedTokenAttributes & 16744448) >>> 15;
  }
  EncodedTokenAttributes2.getForeground = getForeground;
  function getBackground(encodedTokenAttributes) {
    return (encodedTokenAttributes & 4278190080) >>> 24;
  }
  EncodedTokenAttributes2.getBackground = getBackground;
  function set(encodedTokenAttributes, languageId, tokenType, containsBalancedBrackets2, fontStyle, foreground, background) {
    let _languageId = EncodedTokenAttributes2.getLanguageId(encodedTokenAttributes);
    let _tokenType = EncodedTokenAttributes2.getTokenType(encodedTokenAttributes);
    let _containsBalancedBracketsBit = EncodedTokenAttributes2.containsBalancedBrackets(encodedTokenAttributes) ? 1 : 0;
    let _fontStyle = EncodedTokenAttributes2.getFontStyle(encodedTokenAttributes);
    let _foreground = EncodedTokenAttributes2.getForeground(encodedTokenAttributes);
    let _background = EncodedTokenAttributes2.getBackground(encodedTokenAttributes);
    if (languageId !== 0) {
      _languageId = languageId;
    }
    if (tokenType !== 8) {
      _tokenType = fromOptionalTokenType(tokenType);
    }
    if (containsBalancedBrackets2 !== null) {
      _containsBalancedBracketsBit = containsBalancedBrackets2 ? 1 : 0;
    }
    if (fontStyle !== -1) {
      _fontStyle = fontStyle;
    }
    if (foreground !== 0) {
      _foreground = foreground;
    }
    if (background !== 0) {
      _background = background;
    }
    return (_languageId << 0 | _tokenType << 8 | _containsBalancedBracketsBit << 10 | _fontStyle << 11 | _foreground << 15 | _background << 24) >>> 0;
  }
  EncodedTokenAttributes2.set = set;
})(EncodedTokenAttributes || (EncodedTokenAttributes = {}));
function toOptionalTokenType(standardType) {
  return standardType;
}
function fromOptionalTokenType(standardType) {
  return standardType;
}
function createMatchers(selector, matchesName) {
  const results = [];
  const tokenizer = newTokenizer(selector);
  let token = tokenizer.next();
  while (token !== null) {
    let priority = 0;
    if (token.length === 2 && token.charAt(1) === ":") {
      switch (token.charAt(0)) {
        case "R":
          priority = 1;
          break;
        case "L":
          priority = -1;
          break;
        default:
          console.log(`Unknown priority ${token} in scope selector`);
      }
      token = tokenizer.next();
    }
    let matcher = parseConjunction();
    results.push({ matcher, priority });
    if (token !== ",") {
      break;
    }
    token = tokenizer.next();
  }
  return results;
  function parseOperand() {
    if (token === "-") {
      token = tokenizer.next();
      const expressionToNegate = parseOperand();
      return (matcherInput) => !!expressionToNegate && !expressionToNegate(matcherInput);
    }
    if (token === "(") {
      token = tokenizer.next();
      const expressionInParents = parseInnerExpression();
      if (token === ")") {
        token = tokenizer.next();
      }
      return expressionInParents;
    }
    if (isIdentifier(token)) {
      const identifiers = [];
      do {
        identifiers.push(token);
        token = tokenizer.next();
      } while (isIdentifier(token));
      return (matcherInput) => matchesName(identifiers, matcherInput);
    }
    return null;
  }
  function parseConjunction() {
    const matchers = [];
    let matcher = parseOperand();
    while (matcher) {
      matchers.push(matcher);
      matcher = parseOperand();
    }
    return (matcherInput) => matchers.every((matcher2) => matcher2(matcherInput));
  }
  function parseInnerExpression() {
    const matchers = [];
    let matcher = parseConjunction();
    while (matcher) {
      matchers.push(matcher);
      if (token === "|" || token === ",") {
        do {
          token = tokenizer.next();
        } while (token === "|" || token === ",");
      } else {
        break;
      }
      matcher = parseConjunction();
    }
    return (matcherInput) => matchers.some((matcher2) => matcher2(matcherInput));
  }
}
function isIdentifier(token) {
  return !!token && !!token.match(/[\w\.:]+/);
}
function newTokenizer(input) {
  let regex = /([LR]:|[\w\.:][\w\.:\-]*|[\,\|\-\(\)])/g;
  let match = regex.exec(input);
  return {
    next: () => {
      if (!match) {
        return null;
      }
      const res = match[0];
      match = regex.exec(input);
      return res;
    }
  };
}
function disposeOnigString(str) {
  if (typeof str.dispose === "function") {
    str.dispose();
  }
}
function clone(something) {
  return doClone(something);
}
function doClone(something) {
  if (Array.isArray(something)) {
    return cloneArray(something);
  }
  if (typeof something === "object") {
    return cloneObj(something);
  }
  return something;
}
function cloneArray(arr) {
  let r = [];
  for (let i = 0, len = arr.length; i < len; i++) {
    r[i] = doClone(arr[i]);
  }
  return r;
}
function cloneObj(obj) {
  let r = {};
  for (let key2 in obj) {
    r[key2] = doClone(obj[key2]);
  }
  return r;
}
function mergeObjects(target, ...sources) {
  sources.forEach((source) => {
    for (let key2 in source) {
      target[key2] = source[key2];
    }
  });
  return target;
}
function basename(path) {
  const idx = ~path.lastIndexOf("/") || ~path.lastIndexOf("\\");
  if (idx === 0) {
    return path;
  } else if (~idx === path.length - 1) {
    return basename(path.substring(0, path.length - 1));
  } else {
    return path.substr(~idx + 1);
  }
}
var CAPTURING_REGEX_SOURCE = /\$(\d+)|\${(\d+):\/(downcase|upcase)}/g;
var RegexSource = class {
  static hasCaptures(regexSource) {
    if (regexSource === null) {
      return false;
    }
    CAPTURING_REGEX_SOURCE.lastIndex = 0;
    return CAPTURING_REGEX_SOURCE.test(regexSource);
  }
  static replaceCaptures(regexSource, captureSource, captureIndices) {
    return regexSource.replace(CAPTURING_REGEX_SOURCE, (match, index, commandIndex, command) => {
      let capture = captureIndices[parseInt(index || commandIndex, 10)];
      if (capture) {
        let result = captureSource.substring(capture.start, capture.end);
        while (result[0] === ".") {
          result = result.substring(1);
        }
        switch (command) {
          case "downcase":
            return result.toLowerCase();
          case "upcase":
            return result.toUpperCase();
          default:
            return result;
        }
      } else {
        return match;
      }
    });
  }
};
function strcmp(a, b) {
  if (a < b) {
    return -1;
  }
  if (a > b) {
    return 1;
  }
  return 0;
}
function strArrCmp(a, b) {
  if (a === null && b === null) {
    return 0;
  }
  if (!a) {
    return -1;
  }
  if (!b) {
    return 1;
  }
  let len1 = a.length;
  let len2 = b.length;
  if (len1 === len2) {
    for (let i = 0; i < len1; i++) {
      let res = strcmp(a[i], b[i]);
      if (res !== 0) {
        return res;
      }
    }
    return 0;
  }
  return len1 - len2;
}
function isValidHexColor(hex) {
  if (/^#[0-9a-f]{6}$/i.test(hex)) {
    return true;
  }
  if (/^#[0-9a-f]{8}$/i.test(hex)) {
    return true;
  }
  if (/^#[0-9a-f]{3}$/i.test(hex)) {
    return true;
  }
  if (/^#[0-9a-f]{4}$/i.test(hex)) {
    return true;
  }
  return false;
}
function escapeRegExpCharacters(value) {
  return value.replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&");
}
var CachedFn = class {
  constructor(fn) {
    __publicField(this, "fn");
    __publicField(this, "cache", /* @__PURE__ */ new Map());
    this.fn = fn;
  }
  get(key2) {
    if (this.cache.has(key2)) {
      return this.cache.get(key2);
    }
    const value = this.fn(key2);
    this.cache.set(key2, value);
    return value;
  }
};
var TopLevelRuleReference = class {
  constructor(scopeName) {
    __publicField(this, "scopeName");
    this.scopeName = scopeName;
  }
  toKey() {
    return this.scopeName;
  }
};
var TopLevelRepositoryRuleReference = class {
  constructor(scopeName, ruleName) {
    __publicField(this, "scopeName");
    __publicField(this, "ruleName");
    this.scopeName = scopeName;
    this.ruleName = ruleName;
  }
  toKey() {
    return `${this.scopeName}#${this.ruleName}`;
  }
};
var ExternalReferenceCollector = class {
  constructor() {
    __publicField(this, "_references", []);
    __publicField(this, "_seenReferenceKeys", /* @__PURE__ */ new Set());
    __publicField(this, "visitedRule", /* @__PURE__ */ new Set());
  }
  get references() {
    return this._references;
  }
  add(reference) {
    const key2 = reference.toKey();
    if (this._seenReferenceKeys.has(key2)) {
      return;
    }
    this._seenReferenceKeys.add(key2);
    this._references.push(reference);
  }
};
var ScopeDependencyProcessor = class {
  constructor(repo, initialScopeName) {
    __publicField(this, "repo");
    __publicField(this, "initialScopeName");
    __publicField(this, "seenFullScopeRequests", /* @__PURE__ */ new Set());
    __publicField(this, "seenPartialScopeRequests", /* @__PURE__ */ new Set());
    __publicField(this, "Q");
    this.repo = repo;
    this.initialScopeName = initialScopeName;
    this.seenFullScopeRequests.add(this.initialScopeName);
    this.Q = [new TopLevelRuleReference(this.initialScopeName)];
  }
  processQueue() {
    const q = this.Q;
    this.Q = [];
    const deps = new ExternalReferenceCollector();
    for (const dep of q) {
      collectReferencesOfReference(dep, this.initialScopeName, this.repo, deps);
    }
    for (const dep of deps.references) {
      if (dep instanceof TopLevelRuleReference) {
        if (this.seenFullScopeRequests.has(dep.scopeName)) {
          continue;
        }
        this.seenFullScopeRequests.add(dep.scopeName);
        this.Q.push(dep);
      } else {
        if (this.seenFullScopeRequests.has(dep.scopeName)) {
          continue;
        }
        if (this.seenPartialScopeRequests.has(dep.toKey())) {
          continue;
        }
        this.seenPartialScopeRequests.add(dep.toKey());
        this.Q.push(dep);
      }
    }
  }
};
function collectReferencesOfReference(reference, baseGrammarScopeName, repo, result) {
  const selfGrammar = repo.lookup(reference.scopeName);
  if (!selfGrammar) {
    if (reference.scopeName === baseGrammarScopeName) {
      throw new Error(`No grammar provided for <${baseGrammarScopeName}>`);
    }
    return;
  }
  const baseGrammar = repo.lookup(baseGrammarScopeName);
  if (reference instanceof TopLevelRuleReference) {
    collectExternalReferencesInTopLevelRule({ baseGrammar, selfGrammar }, result);
  } else {
    collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, { baseGrammar, selfGrammar, repository: selfGrammar.repository }, result);
  }
  const injections = repo.injections(reference.scopeName);
  if (injections) {
    for (const injection of injections) {
      result.add(new TopLevelRuleReference(injection));
    }
  }
}
function collectExternalReferencesInTopLevelRepositoryRule(ruleName, context, result) {
  if (context.repository && context.repository[ruleName]) {
    const rule = context.repository[ruleName];
    collectExternalReferencesInRules([rule], context, result);
  }
}
function collectExternalReferencesInTopLevelRule(context, result) {
  if (context.selfGrammar.patterns && Array.isArray(context.selfGrammar.patterns)) {
    collectExternalReferencesInRules(context.selfGrammar.patterns, { ...context, repository: context.selfGrammar.repository }, result);
  }
  if (context.selfGrammar.injections) {
    collectExternalReferencesInRules(Object.values(context.selfGrammar.injections), { ...context, repository: context.selfGrammar.repository }, result);
  }
}
function collectExternalReferencesInRules(rules, context, result) {
  for (const rule of rules) {
    if (result.visitedRule.has(rule)) {
      continue;
    }
    result.visitedRule.add(rule);
    const patternRepository = rule.repository ? mergeObjects({}, context.repository, rule.repository) : context.repository;
    if (Array.isArray(rule.patterns)) {
      collectExternalReferencesInRules(rule.patterns, { ...context, repository: patternRepository }, result);
    }
    const include = rule.include;
    if (!include) {
      continue;
    }
    const reference = parseInclude(include);
    switch (reference.kind) {
      case 0:
        collectExternalReferencesInTopLevelRule({ ...context, selfGrammar: context.baseGrammar }, result);
        break;
      case 1:
        collectExternalReferencesInTopLevelRule(context, result);
        break;
      case 2:
        collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, { ...context, repository: patternRepository }, result);
        break;
      case 3:
      case 4:
        const selfGrammar = reference.scopeName === context.selfGrammar.scopeName ? context.selfGrammar : reference.scopeName === context.baseGrammar.scopeName ? context.baseGrammar : void 0;
        if (selfGrammar) {
          const newContext = { baseGrammar: context.baseGrammar, selfGrammar, repository: patternRepository };
          if (reference.kind === 4) {
            collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, newContext, result);
          } else {
            collectExternalReferencesInTopLevelRule(newContext, result);
          }
        } else {
          if (reference.kind === 4) {
            result.add(new TopLevelRepositoryRuleReference(reference.scopeName, reference.ruleName));
          } else {
            result.add(new TopLevelRuleReference(reference.scopeName));
          }
        }
        break;
    }
  }
}
var BaseReference = class {
  constructor() {
    __publicField(this, "kind", 0);
  }
};
var SelfReference = class {
  constructor() {
    __publicField(this, "kind", 1);
  }
};
var RelativeReference = class {
  constructor(ruleName) {
    __publicField(this, "ruleName");
    __publicField(this, "kind", 2);
    this.ruleName = ruleName;
  }
};
var TopLevelReference = class {
  constructor(scopeName) {
    __publicField(this, "scopeName");
    __publicField(this, "kind", 3);
    this.scopeName = scopeName;
  }
};
var TopLevelRepositoryReference = class {
  constructor(scopeName, ruleName) {
    __publicField(this, "scopeName");
    __publicField(this, "ruleName");
    __publicField(this, "kind", 4);
    this.scopeName = scopeName;
    this.ruleName = ruleName;
  }
};
function parseInclude(include) {
  if (include === "$base") {
    return new BaseReference();
  } else if (include === "$self") {
    return new SelfReference();
  }
  const indexOfSharp = include.indexOf("#");
  if (indexOfSharp === -1) {
    return new TopLevelReference(include);
  } else if (indexOfSharp === 0) {
    return new RelativeReference(include.substring(1));
  } else {
    const scopeName = include.substring(0, indexOfSharp);
    const ruleName = include.substring(indexOfSharp + 1);
    return new TopLevelRepositoryReference(scopeName, ruleName);
  }
}
var HAS_BACK_REFERENCES = /\\(\d+)/;
var BACK_REFERENCING_END = /\\(\d+)/g;
var endRuleId = -1;
var whileRuleId = -2;
function ruleIdFromNumber(id) {
  return id;
}
function ruleIdToNumber(id) {
  return id;
}
var Rule = class {
  constructor($location, id, name, contentName) {
    __publicField(this, "$location");
    __publicField(this, "id");
    __publicField(this, "_nameIsCapturing");
    __publicField(this, "_name");
    __publicField(this, "_contentNameIsCapturing");
    __publicField(this, "_contentName");
    this.$location = $location;
    this.id = id;
    this._name = name || null;
    this._nameIsCapturing = RegexSource.hasCaptures(this._name);
    this._contentName = contentName || null;
    this._contentNameIsCapturing = RegexSource.hasCaptures(this._contentName);
  }
  get debugName() {
    const location = this.$location ? `${basename(this.$location.filename)}:${this.$location.line}` : "unknown";
    return `${this.constructor.name}#${this.id} @ ${location}`;
  }
  getName(lineText, captureIndices) {
    if (!this._nameIsCapturing || this._name === null || lineText === null || captureIndices === null) {
      return this._name;
    }
    return RegexSource.replaceCaptures(this._name, lineText, captureIndices);
  }
  getContentName(lineText, captureIndices) {
    if (!this._contentNameIsCapturing || this._contentName === null) {
      return this._contentName;
    }
    return RegexSource.replaceCaptures(this._contentName, lineText, captureIndices);
  }
};
var CaptureRule = class extends Rule {
  constructor($location, id, name, contentName, retokenizeCapturedWithRuleId) {
    super($location, id, name, contentName);
    __publicField(this, "retokenizeCapturedWithRuleId");
    this.retokenizeCapturedWithRuleId = retokenizeCapturedWithRuleId;
  }
  dispose() {
  }
  collectPatterns(grammar, out) {
    throw new Error("Not supported!");
  }
  compile(grammar, endRegexSource) {
    throw new Error("Not supported!");
  }
  compileAG(grammar, endRegexSource, allowA, allowG) {
    throw new Error("Not supported!");
  }
};
var MatchRule = class extends Rule {
  constructor($location, id, name, match, captures) {
    super($location, id, name, null);
    __publicField(this, "_match");
    __publicField(this, "captures");
    __publicField(this, "_cachedCompiledPatterns");
    this._match = new RegExpSource(match, this.id);
    this.captures = captures;
    this._cachedCompiledPatterns = null;
  }
  dispose() {
    if (this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns.dispose();
      this._cachedCompiledPatterns = null;
    }
  }
  get debugMatchRegExp() {
    return `${this._match.source}`;
  }
  collectPatterns(grammar, out) {
    out.push(this._match);
  }
  compile(grammar, endRegexSource) {
    return this._getCachedCompiledPatterns(grammar).compile(grammar);
  }
  compileAG(grammar, endRegexSource, allowA, allowG) {
    return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);
  }
  _getCachedCompiledPatterns(grammar) {
    if (!this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns = new RegExpSourceList();
      this.collectPatterns(grammar, this._cachedCompiledPatterns);
    }
    return this._cachedCompiledPatterns;
  }
};
var IncludeOnlyRule = class extends Rule {
  constructor($location, id, name, contentName, patterns) {
    super($location, id, name, contentName);
    __publicField(this, "hasMissingPatterns");
    __publicField(this, "patterns");
    __publicField(this, "_cachedCompiledPatterns");
    this.patterns = patterns.patterns;
    this.hasMissingPatterns = patterns.hasMissingPatterns;
    this._cachedCompiledPatterns = null;
  }
  dispose() {
    if (this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns.dispose();
      this._cachedCompiledPatterns = null;
    }
  }
  collectPatterns(grammar, out) {
    for (const pattern of this.patterns) {
      const rule = grammar.getRule(pattern);
      rule.collectPatterns(grammar, out);
    }
  }
  compile(grammar, endRegexSource) {
    return this._getCachedCompiledPatterns(grammar).compile(grammar);
  }
  compileAG(grammar, endRegexSource, allowA, allowG) {
    return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);
  }
  _getCachedCompiledPatterns(grammar) {
    if (!this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns = new RegExpSourceList();
      this.collectPatterns(grammar, this._cachedCompiledPatterns);
    }
    return this._cachedCompiledPatterns;
  }
};
var BeginEndRule = class extends Rule {
  constructor($location, id, name, contentName, begin, beginCaptures, end, endCaptures, applyEndPatternLast, patterns) {
    super($location, id, name, contentName);
    __publicField(this, "_begin");
    __publicField(this, "beginCaptures");
    __publicField(this, "_end");
    __publicField(this, "endHasBackReferences");
    __publicField(this, "endCaptures");
    __publicField(this, "applyEndPatternLast");
    __publicField(this, "hasMissingPatterns");
    __publicField(this, "patterns");
    __publicField(this, "_cachedCompiledPatterns");
    this._begin = new RegExpSource(begin, this.id);
    this.beginCaptures = beginCaptures;
    this._end = new RegExpSource(end ? end : "￿", -1);
    this.endHasBackReferences = this._end.hasBackReferences;
    this.endCaptures = endCaptures;
    this.applyEndPatternLast = applyEndPatternLast || false;
    this.patterns = patterns.patterns;
    this.hasMissingPatterns = patterns.hasMissingPatterns;
    this._cachedCompiledPatterns = null;
  }
  dispose() {
    if (this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns.dispose();
      this._cachedCompiledPatterns = null;
    }
  }
  get debugBeginRegExp() {
    return `${this._begin.source}`;
  }
  get debugEndRegExp() {
    return `${this._end.source}`;
  }
  getEndWithResolvedBackReferences(lineText, captureIndices) {
    return this._end.resolveBackReferences(lineText, captureIndices);
  }
  collectPatterns(grammar, out) {
    out.push(this._begin);
  }
  compile(grammar, endRegexSource) {
    return this._getCachedCompiledPatterns(grammar, endRegexSource).compile(grammar);
  }
  compileAG(grammar, endRegexSource, allowA, allowG) {
    return this._getCachedCompiledPatterns(grammar, endRegexSource).compileAG(grammar, allowA, allowG);
  }
  _getCachedCompiledPatterns(grammar, endRegexSource) {
    if (!this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns = new RegExpSourceList();
      for (const pattern of this.patterns) {
        const rule = grammar.getRule(pattern);
        rule.collectPatterns(grammar, this._cachedCompiledPatterns);
      }
      if (this.applyEndPatternLast) {
        this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end);
      } else {
        this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end);
      }
    }
    if (this._end.hasBackReferences) {
      if (this.applyEndPatternLast) {
        this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, endRegexSource);
      } else {
        this._cachedCompiledPatterns.setSource(0, endRegexSource);
      }
    }
    return this._cachedCompiledPatterns;
  }
};
var BeginWhileRule = class extends Rule {
  constructor($location, id, name, contentName, begin, beginCaptures, _while, whileCaptures, patterns) {
    super($location, id, name, contentName);
    __publicField(this, "_begin");
    __publicField(this, "beginCaptures");
    __publicField(this, "whileCaptures");
    __publicField(this, "_while");
    __publicField(this, "whileHasBackReferences");
    __publicField(this, "hasMissingPatterns");
    __publicField(this, "patterns");
    __publicField(this, "_cachedCompiledPatterns");
    __publicField(this, "_cachedCompiledWhilePatterns");
    this._begin = new RegExpSource(begin, this.id);
    this.beginCaptures = beginCaptures;
    this.whileCaptures = whileCaptures;
    this._while = new RegExpSource(_while, whileRuleId);
    this.whileHasBackReferences = this._while.hasBackReferences;
    this.patterns = patterns.patterns;
    this.hasMissingPatterns = patterns.hasMissingPatterns;
    this._cachedCompiledPatterns = null;
    this._cachedCompiledWhilePatterns = null;
  }
  dispose() {
    if (this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns.dispose();
      this._cachedCompiledPatterns = null;
    }
    if (this._cachedCompiledWhilePatterns) {
      this._cachedCompiledWhilePatterns.dispose();
      this._cachedCompiledWhilePatterns = null;
    }
  }
  get debugBeginRegExp() {
    return `${this._begin.source}`;
  }
  get debugWhileRegExp() {
    return `${this._while.source}`;
  }
  getWhileWithResolvedBackReferences(lineText, captureIndices) {
    return this._while.resolveBackReferences(lineText, captureIndices);
  }
  collectPatterns(grammar, out) {
    out.push(this._begin);
  }
  compile(grammar, endRegexSource) {
    return this._getCachedCompiledPatterns(grammar).compile(grammar);
  }
  compileAG(grammar, endRegexSource, allowA, allowG) {
    return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);
  }
  _getCachedCompiledPatterns(grammar) {
    if (!this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns = new RegExpSourceList();
      for (const pattern of this.patterns) {
        const rule = grammar.getRule(pattern);
        rule.collectPatterns(grammar, this._cachedCompiledPatterns);
      }
    }
    return this._cachedCompiledPatterns;
  }
  compileWhile(grammar, endRegexSource) {
    return this._getCachedCompiledWhilePatterns(grammar, endRegexSource).compile(grammar);
  }
  compileWhileAG(grammar, endRegexSource, allowA, allowG) {
    return this._getCachedCompiledWhilePatterns(grammar, endRegexSource).compileAG(grammar, allowA, allowG);
  }
  _getCachedCompiledWhilePatterns(grammar, endRegexSource) {
    if (!this._cachedCompiledWhilePatterns) {
      this._cachedCompiledWhilePatterns = new RegExpSourceList();
      this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while);
    }
    if (this._while.hasBackReferences) {
      this._cachedCompiledWhilePatterns.setSource(0, endRegexSource ? endRegexSource : "￿");
    }
    return this._cachedCompiledWhilePatterns;
  }
};
var RuleFactory = class _RuleFactory {
  static createCaptureRule(helper, $location, name, contentName, retokenizeCapturedWithRuleId) {
    return helper.registerRule((id) => {
      return new CaptureRule($location, id, name, contentName, retokenizeCapturedWithRuleId);
    });
  }
  static getCompiledRuleId(desc, helper, repository) {
    if (!desc.id) {
      helper.registerRule((id) => {
        desc.id = id;
        if (desc.match) {
          return new MatchRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.match, _RuleFactory._compileCaptures(desc.captures, helper, repository));
        }
        if (typeof desc.begin === "undefined") {
          if (desc.repository) {
            repository = mergeObjects({}, repository, desc.repository);
          }
          let patterns = desc.patterns;
          if (typeof patterns === "undefined" && desc.include) {
            patterns = [{ include: desc.include }];
          }
          return new IncludeOnlyRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.contentName, _RuleFactory._compilePatterns(patterns, helper, repository));
        }
        if (desc.while) {
          return new BeginWhileRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.contentName, desc.begin, _RuleFactory._compileCaptures(desc.beginCaptures || desc.captures, helper, repository), desc.while, _RuleFactory._compileCaptures(desc.whileCaptures || desc.captures, helper, repository), _RuleFactory._compilePatterns(desc.patterns, helper, repository));
        }
        return new BeginEndRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.contentName, desc.begin, _RuleFactory._compileCaptures(desc.beginCaptures || desc.captures, helper, repository), desc.end, _RuleFactory._compileCaptures(desc.endCaptures || desc.captures, helper, repository), desc.applyEndPatternLast, _RuleFactory._compilePatterns(desc.patterns, helper, repository));
      });
    }
    return desc.id;
  }
  static _compileCaptures(captures, helper, repository) {
    let r = [];
    if (captures) {
      let maximumCaptureId = 0;
      for (const captureId in captures) {
        if (captureId === "$vscodeTextmateLocation") {
          continue;
        }
        const numericCaptureId = parseInt(captureId, 10);
        if (numericCaptureId > maximumCaptureId) {
          maximumCaptureId = numericCaptureId;
        }
      }
      for (let i = 0; i <= maximumCaptureId; i++) {
        r[i] = null;
      }
      for (const captureId in captures) {
        if (captureId === "$vscodeTextmateLocation") {
          continue;
        }
        const numericCaptureId = parseInt(captureId, 10);
        let retokenizeCapturedWithRuleId = 0;
        if (captures[captureId].patterns) {
          retokenizeCapturedWithRuleId = _RuleFactory.getCompiledRuleId(captures[captureId], helper, repository);
        }
        r[numericCaptureId] = _RuleFactory.createCaptureRule(helper, captures[captureId].$vscodeTextmateLocation, captures[captureId].name, captures[captureId].contentName, retokenizeCapturedWithRuleId);
      }
    }
    return r;
  }
  static _compilePatterns(patterns, helper, repository) {
    let r = [];
    if (patterns) {
      for (let i = 0, len = patterns.length; i < len; i++) {
        const pattern = patterns[i];
        let ruleId = -1;
        if (pattern.include) {
          const reference = parseInclude(pattern.include);
          switch (reference.kind) {
            case 0:
            case 1:
              ruleId = _RuleFactory.getCompiledRuleId(repository[pattern.include], helper, repository);
              break;
            case 2:
              let localIncludedRule = repository[reference.ruleName];
              if (localIncludedRule) {
                ruleId = _RuleFactory.getCompiledRuleId(localIncludedRule, helper, repository);
              }
              break;
            case 3:
            case 4:
              const externalGrammarName = reference.scopeName;
              const externalGrammarInclude = reference.kind === 4 ? reference.ruleName : null;
              const externalGrammar = helper.getExternalGrammar(externalGrammarName, repository);
              if (externalGrammar) {
                if (externalGrammarInclude) {
                  let externalIncludedRule = externalGrammar.repository[externalGrammarInclude];
                  if (externalIncludedRule) {
                    ruleId = _RuleFactory.getCompiledRuleId(externalIncludedRule, helper, externalGrammar.repository);
                  }
                } else {
                  ruleId = _RuleFactory.getCompiledRuleId(externalGrammar.repository.$self, helper, externalGrammar.repository);
                }
              }
              break;
          }
        } else {
          ruleId = _RuleFactory.getCompiledRuleId(pattern, helper, repository);
        }
        if (ruleId !== -1) {
          const rule = helper.getRule(ruleId);
          let skipRule = false;
          if (rule instanceof IncludeOnlyRule || rule instanceof BeginEndRule || rule instanceof BeginWhileRule) {
            if (rule.hasMissingPatterns && rule.patterns.length === 0) {
              skipRule = true;
            }
          }
          if (skipRule) {
            continue;
          }
          r.push(ruleId);
        }
      }
    }
    return {
      patterns: r,
      hasMissingPatterns: (patterns ? patterns.length : 0) !== r.length
    };
  }
};
var RegExpSource = class _RegExpSource {
  constructor(regExpSource, ruleId) {
    __publicField(this, "source");
    __publicField(this, "ruleId");
    __publicField(this, "hasAnchor");
    __publicField(this, "hasBackReferences");
    __publicField(this, "_anchorCache");
    if (regExpSource) {
      const len = regExpSource.length;
      let lastPushedPos = 0;
      let output = [];
      let hasAnchor = false;
      for (let pos = 0; pos < len; pos++) {
        const ch = regExpSource.charAt(pos);
        if (ch === "\\") {
          if (pos + 1 < len) {
            const nextCh = regExpSource.charAt(pos + 1);
            if (nextCh === "z") {
              output.push(regExpSource.substring(lastPushedPos, pos));
              output.push("$(?!\\n)(?<!\\n)");
              lastPushedPos = pos + 2;
            } else if (nextCh === "A" || nextCh === "G") {
              hasAnchor = true;
            }
            pos++;
          }
        }
      }
      this.hasAnchor = hasAnchor;
      if (lastPushedPos === 0) {
        this.source = regExpSource;
      } else {
        output.push(regExpSource.substring(lastPushedPos, len));
        this.source = output.join("");
      }
    } else {
      this.hasAnchor = false;
      this.source = regExpSource;
    }
    if (this.hasAnchor) {
      this._anchorCache = this._buildAnchorCache();
    } else {
      this._anchorCache = null;
    }
    this.ruleId = ruleId;
    this.hasBackReferences = HAS_BACK_REFERENCES.test(this.source);
  }
  clone() {
    return new _RegExpSource(this.source, this.ruleId);
  }
  setSource(newSource) {
    if (this.source === newSource) {
      return;
    }
    this.source = newSource;
    if (this.hasAnchor) {
      this._anchorCache = this._buildAnchorCache();
    }
  }
  resolveBackReferences(lineText, captureIndices) {
    let capturedValues = captureIndices.map((capture) => {
      return lineText.substring(capture.start, capture.end);
    });
    BACK_REFERENCING_END.lastIndex = 0;
    return this.source.replace(BACK_REFERENCING_END, (match, g1) => {
      return escapeRegExpCharacters(capturedValues[parseInt(g1, 10)] || "");
    });
  }
  _buildAnchorCache() {
    let A0_G0_result = [];
    let A0_G1_result = [];
    let A1_G0_result = [];
    let A1_G1_result = [];
    let pos, len, ch, nextCh;
    for (pos = 0, len = this.source.length; pos < len; pos++) {
      ch = this.source.charAt(pos);
      A0_G0_result[pos] = ch;
      A0_G1_result[pos] = ch;
      A1_G0_result[pos] = ch;
      A1_G1_result[pos] = ch;
      if (ch === "\\") {
        if (pos + 1 < len) {
          nextCh = this.source.charAt(pos + 1);
          if (nextCh === "A") {
            A0_G0_result[pos + 1] = "￿";
            A0_G1_result[pos + 1] = "￿";
            A1_G0_result[pos + 1] = "A";
            A1_G1_result[pos + 1] = "A";
          } else if (nextCh === "G") {
            A0_G0_result[pos + 1] = "￿";
            A0_G1_result[pos + 1] = "G";
            A1_G0_result[pos + 1] = "￿";
            A1_G1_result[pos + 1] = "G";
          } else {
            A0_G0_result[pos + 1] = nextCh;
            A0_G1_result[pos + 1] = nextCh;
            A1_G0_result[pos + 1] = nextCh;
            A1_G1_result[pos + 1] = nextCh;
          }
          pos++;
        }
      }
    }
    return {
      A0_G0: A0_G0_result.join(""),
      A0_G1: A0_G1_result.join(""),
      A1_G0: A1_G0_result.join(""),
      A1_G1: A1_G1_result.join("")
    };
  }
  resolveAnchors(allowA, allowG) {
    if (!this.hasAnchor || !this._anchorCache) {
      return this.source;
    }
    if (allowA) {
      if (allowG) {
        return this._anchorCache.A1_G1;
      } else {
        return this._anchorCache.A1_G0;
      }
    } else {
      if (allowG) {
        return this._anchorCache.A0_G1;
      } else {
        return this._anchorCache.A0_G0;
      }
    }
  }
};
var RegExpSourceList = class {
  constructor() {
    __publicField(this, "_items");
    __publicField(this, "_hasAnchors");
    __publicField(this, "_cached");
    __publicField(this, "_anchorCache");
    this._items = [];
    this._hasAnchors = false;
    this._cached = null;
    this._anchorCache = {
      A0_G0: null,
      A0_G1: null,
      A1_G0: null,
      A1_G1: null
    };
  }
  dispose() {
    this._disposeCaches();
  }
  _disposeCaches() {
    if (this._cached) {
      this._cached.dispose();
      this._cached = null;
    }
    if (this._anchorCache.A0_G0) {
      this._anchorCache.A0_G0.dispose();
      this._anchorCache.A0_G0 = null;
    }
    if (this._anchorCache.A0_G1) {
      this._anchorCache.A0_G1.dispose();
      this._anchorCache.A0_G1 = null;
    }
    if (this._anchorCache.A1_G0) {
      this._anchorCache.A1_G0.dispose();
      this._anchorCache.A1_G0 = null;
    }
    if (this._anchorCache.A1_G1) {
      this._anchorCache.A1_G1.dispose();
      this._anchorCache.A1_G1 = null;
    }
  }
  push(item) {
    this._items.push(item);
    this._hasAnchors = this._hasAnchors || item.hasAnchor;
  }
  unshift(item) {
    this._items.unshift(item);
    this._hasAnchors = this._hasAnchors || item.hasAnchor;
  }
  length() {
    return this._items.length;
  }
  setSource(index, newSource) {
    if (this._items[index].source !== newSource) {
      this._disposeCaches();
      this._items[index].setSource(newSource);
    }
  }
  compile(onigLib) {
    if (!this._cached) {
      let regExps = this._items.map((e) => e.source);
      this._cached = new CompiledRule(onigLib, regExps, this._items.map((e) => e.ruleId));
    }
    return this._cached;
  }
  compileAG(onigLib, allowA, allowG) {
    if (!this._hasAnchors) {
      return this.compile(onigLib);
    } else {
      if (allowA) {
        if (allowG) {
          if (!this._anchorCache.A1_G1) {
            this._anchorCache.A1_G1 = this._resolveAnchors(onigLib, allowA, allowG);
          }
          return this._anchorCache.A1_G1;
        } else {
          if (!this._anchorCache.A1_G0) {
            this._anchorCache.A1_G0 = this._resolveAnchors(onigLib, allowA, allowG);
          }
          return this._anchorCache.A1_G0;
        }
      } else {
        if (allowG) {
          if (!this._anchorCache.A0_G1) {
            this._anchorCache.A0_G1 = this._resolveAnchors(onigLib, allowA, allowG);
          }
          return this._anchorCache.A0_G1;
        } else {
          if (!this._anchorCache.A0_G0) {
            this._anchorCache.A0_G0 = this._resolveAnchors(onigLib, allowA, allowG);
          }
          return this._anchorCache.A0_G0;
        }
      }
    }
  }
  _resolveAnchors(onigLib, allowA, allowG) {
    let regExps = this._items.map((e) => e.resolveAnchors(allowA, allowG));
    return new CompiledRule(onigLib, regExps, this._items.map((e) => e.ruleId));
  }
};
var CompiledRule = class {
  constructor(onigLib, regExps, rules) {
    __publicField(this, "regExps");
    __publicField(this, "rules");
    __publicField(this, "scanner");
    this.regExps = regExps;
    this.rules = rules;
    this.scanner = onigLib.createOnigScanner(regExps);
  }
  dispose() {
    if (typeof this.scanner.dispose === "function") {
      this.scanner.dispose();
    }
  }
  toString() {
    const r = [];
    for (let i = 0, len = this.rules.length; i < len; i++) {
      r.push("   - " + this.rules[i] + ": " + this.regExps[i]);
    }
    return r.join("\n");
  }
  findNextMatchSync(string, startPosition, options) {
    const result = this.scanner.findNextMatchSync(string, startPosition, options);
    if (!result) {
      return null;
    }
    return {
      ruleId: this.rules[result.index],
      captureIndices: result.captureIndices
    };
  }
};
var Theme = class {
  constructor(_colorMap, _defaults, _root) {
    __publicField(this, "_colorMap");
    __publicField(this, "_defaults");
    __publicField(this, "_root");
    __publicField(this, "_cachedMatchRoot", new CachedFn((scopeName) => this._root.match(scopeName)));
    this._colorMap = _colorMap;
    this._defaults = _defaults;
    this._root = _root;
  }
  static createFromRawTheme(source, colorMap) {
    return this.createFromParsedTheme(parseTheme(source), colorMap);
  }
  static createFromParsedTheme(source, colorMap) {
    return resolveParsedThemeRules(source, colorMap);
  }
  getColorMap() {
    return this._colorMap.getColorMap();
  }
  getDefaults() {
    return this._defaults;
  }
  match(scopePath) {
    if (scopePath === null) {
      return this._defaults;
    }
    const scopeName = scopePath.scopeName;
    const matchingTrieElements = this._cachedMatchRoot.get(scopeName);
    const effectiveRule = matchingTrieElements.find((v) => _scopePathMatchesParentScopes(scopePath.parent, v.parentScopes));
    if (!effectiveRule) {
      return null;
    }
    return new StyleAttributes(effectiveRule.fontStyle, effectiveRule.foreground, effectiveRule.background);
  }
};
var ScopeStack = class _ScopeStack {
  constructor(parent, scopeName) {
    __publicField(this, "parent");
    __publicField(this, "scopeName");
    this.parent = parent;
    this.scopeName = scopeName;
  }
  static push(path, scopeNames) {
    for (const name of scopeNames) {
      path = new _ScopeStack(path, name);
    }
    return path;
  }
  static from(...segments) {
    let result = null;
    for (let i = 0; i < segments.length; i++) {
      result = new _ScopeStack(result, segments[i]);
    }
    return result;
  }
  push(scopeName) {
    return new _ScopeStack(this, scopeName);
  }
  getSegments() {
    let item = this;
    const result = [];
    while (item) {
      result.push(item.scopeName);
      item = item.parent;
    }
    result.reverse();
    return result;
  }
  toString() {
    return this.getSegments().join(" ");
  }
  extends(other) {
    if (this === other) {
      return true;
    }
    if (this.parent === null) {
      return false;
    }
    return this.parent.extends(other);
  }
  getExtensionIfDefined(base) {
    const result = [];
    let item = this;
    while (item && item !== base) {
      result.push(item.scopeName);
      item = item.parent;
    }
    return item === base ? result.reverse() : void 0;
  }
};
function _scopePathMatchesParentScopes(scopePath, parentScopes) {
  if (parentScopes === null) {
    return true;
  }
  let index = 0;
  let scopePattern = parentScopes[index];
  while (scopePath) {
    if (_matchesScope(scopePath.scopeName, scopePattern)) {
      index++;
      if (index === parentScopes.length) {
        return true;
      }
      scopePattern = parentScopes[index];
    }
    scopePath = scopePath.parent;
  }
  return false;
}
function _matchesScope(scopeName, scopePattern) {
  return scopePattern === scopeName || scopeName.startsWith(scopePattern) && scopeName[scopePattern.length] === ".";
}
var StyleAttributes = class {
  constructor(fontStyle, foregroundId, backgroundId) {
    __publicField(this, "fontStyle");
    __publicField(this, "foregroundId");
    __publicField(this, "backgroundId");
    this.fontStyle = fontStyle;
    this.foregroundId = foregroundId;
    this.backgroundId = backgroundId;
  }
};
function parseTheme(source) {
  if (!source) {
    return [];
  }
  if (!source.settings || !Array.isArray(source.settings)) {
    return [];
  }
  let settings = source.settings;
  let result = [], resultLen = 0;
  for (let i = 0, len = settings.length; i < len; i++) {
    let entry = settings[i];
    if (!entry.settings) {
      continue;
    }
    let scopes;
    if (typeof entry.scope === "string") {
      let _scope = entry.scope;
      _scope = _scope.replace(/^[,]+/, "");
      _scope = _scope.replace(/[,]+$/, "");
      scopes = _scope.split(",");
    } else if (Array.isArray(entry.scope)) {
      scopes = entry.scope;
    } else {
      scopes = [""];
    }
    let fontStyle = -1;
    if (typeof entry.settings.fontStyle === "string") {
      fontStyle = 0;
      let segments = entry.settings.fontStyle.split(" ");
      for (let j = 0, lenJ = segments.length; j < lenJ; j++) {
        let segment = segments[j];
        switch (segment) {
          case "italic":
            fontStyle = fontStyle | 1;
            break;
          case "bold":
            fontStyle = fontStyle | 2;
            break;
          case "underline":
            fontStyle = fontStyle | 4;
            break;
          case "strikethrough":
            fontStyle = fontStyle | 8;
            break;
        }
      }
    }
    let foreground = null;
    if (typeof entry.settings.foreground === "string" && isValidHexColor(entry.settings.foreground)) {
      foreground = entry.settings.foreground;
    }
    let background = null;
    if (typeof entry.settings.background === "string" && isValidHexColor(entry.settings.background)) {
      background = entry.settings.background;
    }
    for (let j = 0, lenJ = scopes.length; j < lenJ; j++) {
      let _scope = scopes[j].trim();
      let segments = _scope.split(" ");
      let scope = segments[segments.length - 1];
      let parentScopes = null;
      if (segments.length > 1) {
        parentScopes = segments.slice(0, segments.length - 1);
        parentScopes.reverse();
      }
      result[resultLen++] = new ParsedThemeRule(scope, parentScopes, i, fontStyle, foreground, background);
    }
  }
  return result;
}
var ParsedThemeRule = class {
  constructor(scope, parentScopes, index, fontStyle, foreground, background) {
    __publicField(this, "scope");
    __publicField(this, "parentScopes");
    __publicField(this, "index");
    __publicField(this, "fontStyle");
    __publicField(this, "foreground");
    __publicField(this, "background");
    this.scope = scope;
    this.parentScopes = parentScopes;
    this.index = index;
    this.fontStyle = fontStyle;
    this.foreground = foreground;
    this.background = background;
  }
};
function resolveParsedThemeRules(parsedThemeRules, _colorMap) {
  parsedThemeRules.sort((a, b) => {
    let r = strcmp(a.scope, b.scope);
    if (r !== 0) {
      return r;
    }
    r = strArrCmp(a.parentScopes, b.parentScopes);
    if (r !== 0) {
      return r;
    }
    return a.index - b.index;
  });
  let defaultFontStyle = 0;
  let defaultForeground = "#000000";
  let defaultBackground = "#ffffff";
  while (parsedThemeRules.length >= 1 && parsedThemeRules[0].scope === "") {
    let incomingDefaults = parsedThemeRules.shift();
    if (incomingDefaults.fontStyle !== -1) {
      defaultFontStyle = incomingDefaults.fontStyle;
    }
    if (incomingDefaults.foreground !== null) {
      defaultForeground = incomingDefaults.foreground;
    }
    if (incomingDefaults.background !== null) {
      defaultBackground = incomingDefaults.background;
    }
  }
  let colorMap = new ColorMap(_colorMap);
  let defaults = new StyleAttributes(defaultFontStyle, colorMap.getId(defaultForeground), colorMap.getId(defaultBackground));
  let root2 = new ThemeTrieElement(new ThemeTrieElementRule(0, null, -1, 0, 0), []);
  for (let i = 0, len = parsedThemeRules.length; i < len; i++) {
    let rule = parsedThemeRules[i];
    root2.insert(0, rule.scope, rule.parentScopes, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));
  }
  return new Theme(colorMap, defaults, root2);
}
var ColorMap = class {
  constructor(_colorMap) {
    __publicField(this, "_isFrozen");
    __publicField(this, "_lastColorId");
    __publicField(this, "_id2color");
    __publicField(this, "_color2id");
    this._lastColorId = 0;
    this._id2color = [];
    this._color2id = /* @__PURE__ */ Object.create(null);
    if (Array.isArray(_colorMap)) {
      this._isFrozen = true;
      for (let i = 0, len = _colorMap.length; i < len; i++) {
        this._color2id[_colorMap[i]] = i;
        this._id2color[i] = _colorMap[i];
      }
    } else {
      this._isFrozen = false;
    }
  }
  getId(color) {
    if (color === null) {
      return 0;
    }
    color = color.toUpperCase();
    let value = this._color2id[color];
    if (value) {
      return value;
    }
    if (this._isFrozen) {
      throw new Error(`Missing color in color map - ${color}`);
    }
    value = ++this._lastColorId;
    this._color2id[color] = value;
    this._id2color[value] = color;
    return value;
  }
  getColorMap() {
    return this._id2color.slice(0);
  }
};
var ThemeTrieElementRule = class _ThemeTrieElementRule {
  constructor(scopeDepth, parentScopes, fontStyle, foreground, background) {
    __publicField(this, "scopeDepth");
    __publicField(this, "parentScopes");
    __publicField(this, "fontStyle");
    __publicField(this, "foreground");
    __publicField(this, "background");
    this.scopeDepth = scopeDepth;
    this.parentScopes = parentScopes;
    this.fontStyle = fontStyle;
    this.foreground = foreground;
    this.background = background;
  }
  clone() {
    return new _ThemeTrieElementRule(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background);
  }
  static cloneArr(arr) {
    let r = [];
    for (let i = 0, len = arr.length; i < len; i++) {
      r[i] = arr[i].clone();
    }
    return r;
  }
  acceptOverwrite(scopeDepth, fontStyle, foreground, background) {
    if (this.scopeDepth > scopeDepth) {
      console.log("how did this happen?");
    } else {
      this.scopeDepth = scopeDepth;
    }
    if (fontStyle !== -1) {
      this.fontStyle = fontStyle;
    }
    if (foreground !== 0) {
      this.foreground = foreground;
    }
    if (background !== 0) {
      this.background = background;
    }
  }
};
var ThemeTrieElement = class _ThemeTrieElement {
  constructor(_mainRule, rulesWithParentScopes = [], _children = {}) {
    __publicField(this, "_mainRule");
    __publicField(this, "_children");
    __publicField(this, "_rulesWithParentScopes");
    this._mainRule = _mainRule;
    this._children = _children;
    this._rulesWithParentScopes = rulesWithParentScopes;
  }
  static _sortBySpecificity(arr) {
    if (arr.length === 1) {
      return arr;
    }
    arr.sort(this._cmpBySpecificity);
    return arr;
  }
  static _cmpBySpecificity(a, b) {
    if (a.scopeDepth === b.scopeDepth) {
      const aParentScopes = a.parentScopes;
      const bParentScopes = b.parentScopes;
      let aParentScopesLen = aParentScopes === null ? 0 : aParentScopes.length;
      let bParentScopesLen = bParentScopes === null ? 0 : bParentScopes.length;
      if (aParentScopesLen === bParentScopesLen) {
        for (let i = 0; i < aParentScopesLen; i++) {
          const aLen = aParentScopes[i].length;
          const bLen = bParentScopes[i].length;
          if (aLen !== bLen) {
            return bLen - aLen;
          }
        }
      }
      return bParentScopesLen - aParentScopesLen;
    }
    return b.scopeDepth - a.scopeDepth;
  }
  match(scope) {
    if (scope === "") {
      return _ThemeTrieElement._sortBySpecificity([].concat(this._mainRule).concat(this._rulesWithParentScopes));
    }
    let dotIndex = scope.indexOf(".");
    let head2;
    let tail;
    if (dotIndex === -1) {
      head2 = scope;
      tail = "";
    } else {
      head2 = scope.substring(0, dotIndex);
      tail = scope.substring(dotIndex + 1);
    }
    if (this._children.hasOwnProperty(head2)) {
      return this._children[head2].match(tail);
    }
    return _ThemeTrieElement._sortBySpecificity([].concat(this._mainRule).concat(this._rulesWithParentScopes));
  }
  insert(scopeDepth, scope, parentScopes, fontStyle, foreground, background) {
    if (scope === "") {
      this._doInsertHere(scopeDepth, parentScopes, fontStyle, foreground, background);
      return;
    }
    let dotIndex = scope.indexOf(".");
    let head2;
    let tail;
    if (dotIndex === -1) {
      head2 = scope;
      tail = "";
    } else {
      head2 = scope.substring(0, dotIndex);
      tail = scope.substring(dotIndex + 1);
    }
    let child;
    if (this._children.hasOwnProperty(head2)) {
      child = this._children[head2];
    } else {
      child = new _ThemeTrieElement(this._mainRule.clone(), ThemeTrieElementRule.cloneArr(this._rulesWithParentScopes));
      this._children[head2] = child;
    }
    child.insert(scopeDepth + 1, tail, parentScopes, fontStyle, foreground, background);
  }
  _doInsertHere(scopeDepth, parentScopes, fontStyle, foreground, background) {
    if (parentScopes === null) {
      this._mainRule.acceptOverwrite(scopeDepth, fontStyle, foreground, background);
      return;
    }
    for (let i = 0, len = this._rulesWithParentScopes.length; i < len; i++) {
      let rule = this._rulesWithParentScopes[i];
      if (strArrCmp(rule.parentScopes, parentScopes) === 0) {
        rule.acceptOverwrite(scopeDepth, fontStyle, foreground, background);
        return;
      }
    }
    if (fontStyle === -1) {
      fontStyle = this._mainRule.fontStyle;
    }
    if (foreground === 0) {
      foreground = this._mainRule.foreground;
    }
    if (background === 0) {
      background = this._mainRule.background;
    }
    this._rulesWithParentScopes.push(new ThemeTrieElementRule(scopeDepth, parentScopes, fontStyle, foreground, background));
  }
};
var BasicScopeAttributes = class {
  constructor(languageId, tokenType) {
    __publicField(this, "languageId");
    __publicField(this, "tokenType");
    this.languageId = languageId;
    this.tokenType = tokenType;
  }
};
var _BasicScopeAttributesProvider = class _BasicScopeAttributesProvider {
  constructor(initialLanguageId, embeddedLanguages) {
    __publicField(this, "_defaultAttributes");
    __publicField(this, "_embeddedLanguagesMatcher");
    __publicField(this, "_getBasicScopeAttributes", new CachedFn((scopeName) => {
      const languageId = this._scopeToLanguage(scopeName);
      const standardTokenType = this._toStandardTokenType(scopeName);
      return new BasicScopeAttributes(languageId, standardTokenType);
    }));
    this._defaultAttributes = new BasicScopeAttributes(
      initialLanguageId,
      8
      /* OptionalStandardTokenType.NotSet */
    );
    this._embeddedLanguagesMatcher = new ScopeMatcher(Object.entries(embeddedLanguages || {}));
  }
  getDefaultAttributes() {
    return this._defaultAttributes;
  }
  getBasicScopeAttributes(scopeName) {
    if (scopeName === null) {
      return _BasicScopeAttributesProvider._NULL_SCOPE_METADATA;
    }
    return this._getBasicScopeAttributes.get(scopeName);
  }
  /**
   * Given a produced TM scope, return the language that token describes or null if unknown.
   * e.g. source.html => html, source.css.embedded.html => css, punctuation.definition.tag.html => null
   */
  _scopeToLanguage(scope) {
    return this._embeddedLanguagesMatcher.match(scope) || 0;
  }
  _toStandardTokenType(scopeName) {
    const m = scopeName.match(_BasicScopeAttributesProvider.STANDARD_TOKEN_TYPE_REGEXP);
    if (!m) {
      return 8;
    }
    switch (m[1]) {
      case "comment":
        return 1;
      case "string":
        return 2;
      case "regex":
        return 3;
      case "meta.embedded":
        return 0;
    }
    throw new Error("Unexpected match for standard token type!");
  }
};
__publicField(_BasicScopeAttributesProvider, "_NULL_SCOPE_METADATA", new BasicScopeAttributes(0, 0));
__publicField(_BasicScopeAttributesProvider, "STANDARD_TOKEN_TYPE_REGEXP", /\b(comment|string|regex|meta\.embedded)\b/);
var BasicScopeAttributesProvider = _BasicScopeAttributesProvider;
var ScopeMatcher = class {
  constructor(values) {
    __publicField(this, "values");
    __publicField(this, "scopesRegExp");
    if (values.length === 0) {
      this.values = null;
      this.scopesRegExp = null;
    } else {
      this.values = new Map(values);
      const escapedScopes = values.map(([scopeName, value]) => escapeRegExpCharacters(scopeName));
      escapedScopes.sort();
      escapedScopes.reverse();
      this.scopesRegExp = new RegExp(`^((${escapedScopes.join(")|(")}))($|\\.)`, "");
    }
  }
  match(scope) {
    if (!this.scopesRegExp) {
      return void 0;
    }
    const m = scope.match(this.scopesRegExp);
    if (!m) {
      return void 0;
    }
    return this.values.get(m[1]);
  }
};
var TokenizeStringResult = class {
  constructor(stack, stoppedEarly) {
    __publicField(this, "stack");
    __publicField(this, "stoppedEarly");
    this.stack = stack;
    this.stoppedEarly = stoppedEarly;
  }
};
function _tokenizeString(grammar, lineText, isFirstLine, linePos, stack, lineTokens, checkWhileConditions, timeLimit) {
  const lineLength = lineText.content.length;
  let STOP = false;
  let anchorPosition = -1;
  if (checkWhileConditions) {
    const whileCheckResult = _checkWhileConditions(grammar, lineText, isFirstLine, linePos, stack, lineTokens);
    stack = whileCheckResult.stack;
    linePos = whileCheckResult.linePos;
    isFirstLine = whileCheckResult.isFirstLine;
    anchorPosition = whileCheckResult.anchorPosition;
  }
  const startTime = Date.now();
  while (!STOP) {
    if (timeLimit !== 0) {
      const elapsedTime = Date.now() - startTime;
      if (elapsedTime > timeLimit) {
        return new TokenizeStringResult(stack, true);
      }
    }
    scanNext();
  }
  return new TokenizeStringResult(stack, false);
  function scanNext() {
    const r = matchRuleOrInjections(grammar, lineText, isFirstLine, linePos, stack, anchorPosition);
    if (!r) {
      lineTokens.produce(stack, lineLength);
      STOP = true;
      return;
    }
    const captureIndices = r.captureIndices;
    const matchedRuleId = r.matchedRuleId;
    const hasAdvanced = captureIndices && captureIndices.length > 0 ? captureIndices[0].end > linePos : false;
    if (matchedRuleId === endRuleId) {
      const poppedRule = stack.getRule(grammar);
      lineTokens.produce(stack, captureIndices[0].start);
      stack = stack.withContentNameScopesList(stack.nameScopesList);
      handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, poppedRule.endCaptures, captureIndices);
      lineTokens.produce(stack, captureIndices[0].end);
      const popped = stack;
      stack = stack.parent;
      anchorPosition = popped.getAnchorPos();
      if (!hasAdvanced && popped.getEnterPos() === linePos) {
        stack = popped;
        lineTokens.produce(stack, lineLength);
        STOP = true;
        return;
      }
    } else {
      const _rule = grammar.getRule(matchedRuleId);
      lineTokens.produce(stack, captureIndices[0].start);
      const beforePush = stack;
      const scopeName = _rule.getName(lineText.content, captureIndices);
      const nameScopesList = stack.contentNameScopesList.pushAttributed(scopeName, grammar);
      stack = stack.push(matchedRuleId, linePos, anchorPosition, captureIndices[0].end === lineLength, null, nameScopesList, nameScopesList);
      if (_rule instanceof BeginEndRule) {
        const pushedRule = _rule;
        handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, pushedRule.beginCaptures, captureIndices);
        lineTokens.produce(stack, captureIndices[0].end);
        anchorPosition = captureIndices[0].end;
        const contentName = pushedRule.getContentName(lineText.content, captureIndices);
        const contentNameScopesList = nameScopesList.pushAttributed(contentName, grammar);
        stack = stack.withContentNameScopesList(contentNameScopesList);
        if (pushedRule.endHasBackReferences) {
          stack = stack.withEndRule(pushedRule.getEndWithResolvedBackReferences(lineText.content, captureIndices));
        }
        if (!hasAdvanced && beforePush.hasSameRuleAs(stack)) {
          stack = stack.pop();
          lineTokens.produce(stack, lineLength);
          STOP = true;
          return;
        }
      } else if (_rule instanceof BeginWhileRule) {
        const pushedRule = _rule;
        handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, pushedRule.beginCaptures, captureIndices);
        lineTokens.produce(stack, captureIndices[0].end);
        anchorPosition = captureIndices[0].end;
        const contentName = pushedRule.getContentName(lineText.content, captureIndices);
        const contentNameScopesList = nameScopesList.pushAttributed(contentName, grammar);
        stack = stack.withContentNameScopesList(contentNameScopesList);
        if (pushedRule.whileHasBackReferences) {
          stack = stack.withEndRule(pushedRule.getWhileWithResolvedBackReferences(lineText.content, captureIndices));
        }
        if (!hasAdvanced && beforePush.hasSameRuleAs(stack)) {
          stack = stack.pop();
          lineTokens.produce(stack, lineLength);
          STOP = true;
          return;
        }
      } else {
        const matchingRule = _rule;
        handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, matchingRule.captures, captureIndices);
        lineTokens.produce(stack, captureIndices[0].end);
        stack = stack.pop();
        if (!hasAdvanced) {
          stack = stack.safePop();
          lineTokens.produce(stack, lineLength);
          STOP = true;
          return;
        }
      }
    }
    if (captureIndices[0].end > linePos) {
      linePos = captureIndices[0].end;
      isFirstLine = false;
    }
  }
}
function _checkWhileConditions(grammar, lineText, isFirstLine, linePos, stack, lineTokens) {
  let anchorPosition = stack.beginRuleCapturedEOL ? 0 : -1;
  const whileRules = [];
  for (let node = stack; node; node = node.pop()) {
    const nodeRule = node.getRule(grammar);
    if (nodeRule instanceof BeginWhileRule) {
      whileRules.push({
        rule: nodeRule,
        stack: node
      });
    }
  }
  for (let whileRule = whileRules.pop(); whileRule; whileRule = whileRules.pop()) {
    const { ruleScanner, findOptions } = prepareRuleWhileSearch(whileRule.rule, grammar, whileRule.stack.endRule, isFirstLine, linePos === anchorPosition);
    const r = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);
    if (r) {
      const matchedRuleId = r.ruleId;
      if (matchedRuleId !== whileRuleId) {
        stack = whileRule.stack.pop();
        break;
      }
      if (r.captureIndices && r.captureIndices.length) {
        lineTokens.produce(whileRule.stack, r.captureIndices[0].start);
        handleCaptures(grammar, lineText, isFirstLine, whileRule.stack, lineTokens, whileRule.rule.whileCaptures, r.captureIndices);
        lineTokens.produce(whileRule.stack, r.captureIndices[0].end);
        anchorPosition = r.captureIndices[0].end;
        if (r.captureIndices[0].end > linePos) {
          linePos = r.captureIndices[0].end;
          isFirstLine = false;
        }
      }
    } else {
      stack = whileRule.stack.pop();
      break;
    }
  }
  return { stack, linePos, anchorPosition, isFirstLine };
}
function matchRuleOrInjections(grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {
  const matchResult = matchRule(grammar, lineText, isFirstLine, linePos, stack, anchorPosition);
  const injections = grammar.getInjections();
  if (injections.length === 0) {
    return matchResult;
  }
  const injectionResult = matchInjections(injections, grammar, lineText, isFirstLine, linePos, stack, anchorPosition);
  if (!injectionResult) {
    return matchResult;
  }
  if (!matchResult) {
    return injectionResult;
  }
  const matchResultScore = matchResult.captureIndices[0].start;
  const injectionResultScore = injectionResult.captureIndices[0].start;
  if (injectionResultScore < matchResultScore || injectionResult.priorityMatch && injectionResultScore === matchResultScore) {
    return injectionResult;
  }
  return matchResult;
}
function matchRule(grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {
  const rule = stack.getRule(grammar);
  const { ruleScanner, findOptions } = prepareRuleSearch(rule, grammar, stack.endRule, isFirstLine, linePos === anchorPosition);
  const r = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);
  if (r) {
    return {
      captureIndices: r.captureIndices,
      matchedRuleId: r.ruleId
    };
  }
  return null;
}
function matchInjections(injections, grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {
  let bestMatchRating = Number.MAX_VALUE;
  let bestMatchCaptureIndices = null;
  let bestMatchRuleId;
  let bestMatchResultPriority = 0;
  const scopes = stack.contentNameScopesList.getScopeNames();
  for (let i = 0, len = injections.length; i < len; i++) {
    const injection = injections[i];
    if (!injection.matcher(scopes)) {
      continue;
    }
    const rule = grammar.getRule(injection.ruleId);
    const { ruleScanner, findOptions } = prepareRuleSearch(rule, grammar, null, isFirstLine, linePos === anchorPosition);
    const matchResult = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);
    if (!matchResult) {
      continue;
    }
    const matchRating = matchResult.captureIndices[0].start;
    if (matchRating >= bestMatchRating) {
      continue;
    }
    bestMatchRating = matchRating;
    bestMatchCaptureIndices = matchResult.captureIndices;
    bestMatchRuleId = matchResult.ruleId;
    bestMatchResultPriority = injection.priority;
    if (bestMatchRating === linePos) {
      break;
    }
  }
  if (bestMatchCaptureIndices) {
    return {
      priorityMatch: bestMatchResultPriority === -1,
      captureIndices: bestMatchCaptureIndices,
      matchedRuleId: bestMatchRuleId
    };
  }
  return null;
}
function prepareRuleSearch(rule, grammar, endRegexSource, allowA, allowG) {
  const ruleScanner = rule.compileAG(grammar, endRegexSource, allowA, allowG);
  return {
    ruleScanner,
    findOptions: 0
    /* FindOption.None */
  };
}
function prepareRuleWhileSearch(rule, grammar, endRegexSource, allowA, allowG) {
  const ruleScanner = rule.compileWhileAG(grammar, endRegexSource, allowA, allowG);
  return {
    ruleScanner,
    findOptions: 0
    /* FindOption.None */
  };
}
function handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, captures, captureIndices) {
  if (captures.length === 0) {
    return;
  }
  const lineTextContent = lineText.content;
  const len = Math.min(captures.length, captureIndices.length);
  const localStack = [];
  const maxEnd = captureIndices[0].end;
  for (let i = 0; i < len; i++) {
    const captureRule = captures[i];
    if (captureRule === null) {
      continue;
    }
    const captureIndex = captureIndices[i];
    if (captureIndex.length === 0) {
      continue;
    }
    if (captureIndex.start > maxEnd) {
      break;
    }
    while (localStack.length > 0 && localStack[localStack.length - 1].endPos <= captureIndex.start) {
      lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, localStack[localStack.length - 1].endPos);
      localStack.pop();
    }
    if (localStack.length > 0) {
      lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, captureIndex.start);
    } else {
      lineTokens.produce(stack, captureIndex.start);
    }
    if (captureRule.retokenizeCapturedWithRuleId) {
      const scopeName = captureRule.getName(lineTextContent, captureIndices);
      const nameScopesList = stack.contentNameScopesList.pushAttributed(scopeName, grammar);
      const contentName = captureRule.getContentName(lineTextContent, captureIndices);
      const contentNameScopesList = nameScopesList.pushAttributed(contentName, grammar);
      const stackClone = stack.push(captureRule.retokenizeCapturedWithRuleId, captureIndex.start, -1, false, null, nameScopesList, contentNameScopesList);
      const onigSubStr = grammar.createOnigString(lineTextContent.substring(0, captureIndex.end));
      _tokenizeString(
        grammar,
        onigSubStr,
        isFirstLine && captureIndex.start === 0,
        captureIndex.start,
        stackClone,
        lineTokens,
        false,
        /* no time limit */
        0
      );
      disposeOnigString(onigSubStr);
      continue;
    }
    const captureRuleScopeName = captureRule.getName(lineTextContent, captureIndices);
    if (captureRuleScopeName !== null) {
      const base = localStack.length > 0 ? localStack[localStack.length - 1].scopes : stack.contentNameScopesList;
      const captureRuleScopesList = base.pushAttributed(captureRuleScopeName, grammar);
      localStack.push(new LocalStackElement(captureRuleScopesList, captureIndex.end));
    }
  }
  while (localStack.length > 0) {
    lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, localStack[localStack.length - 1].endPos);
    localStack.pop();
  }
}
var LocalStackElement = class {
  constructor(scopes, endPos) {
    __publicField(this, "scopes");
    __publicField(this, "endPos");
    this.scopes = scopes;
    this.endPos = endPos;
  }
};
function createGrammar(scopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, onigLib) {
  return new Grammar(scopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, onigLib);
}
function collectInjections(result, selector, rule, ruleFactoryHelper, grammar) {
  const matchers = createMatchers(selector, nameMatcher);
  const ruleId = RuleFactory.getCompiledRuleId(rule, ruleFactoryHelper, grammar.repository);
  for (const matcher of matchers) {
    result.push({
      debugSelector: selector,
      matcher: matcher.matcher,
      ruleId,
      grammar,
      priority: matcher.priority
    });
  }
}
function nameMatcher(identifers, scopes) {
  if (scopes.length < identifers.length) {
    return false;
  }
  let lastIndex = 0;
  return identifers.every((identifier) => {
    for (let i = lastIndex; i < scopes.length; i++) {
      if (scopesAreMatching(scopes[i], identifier)) {
        lastIndex = i + 1;
        return true;
      }
    }
    return false;
  });
}
function scopesAreMatching(thisScopeName, scopeName) {
  if (!thisScopeName) {
    return false;
  }
  if (thisScopeName === scopeName) {
    return true;
  }
  const len = scopeName.length;
  return thisScopeName.length > len && thisScopeName.substr(0, len) === scopeName && thisScopeName[len] === ".";
}
var Grammar = class {
  constructor(_rootScopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, _onigLib) {
    __publicField(this, "_rootScopeName");
    __publicField(this, "balancedBracketSelectors");
    __publicField(this, "_onigLib");
    __publicField(this, "_rootId");
    __publicField(this, "_lastRuleId");
    __publicField(this, "_ruleId2desc");
    __publicField(this, "_includedGrammars");
    __publicField(this, "_grammarRepository");
    __publicField(this, "_grammar");
    __publicField(this, "_injections");
    __publicField(this, "_basicScopeAttributesProvider");
    __publicField(this, "_tokenTypeMatchers");
    this._rootScopeName = _rootScopeName;
    this.balancedBracketSelectors = balancedBracketSelectors;
    this._onigLib = _onigLib;
    this._basicScopeAttributesProvider = new BasicScopeAttributesProvider(initialLanguage, embeddedLanguages);
    this._rootId = -1;
    this._lastRuleId = 0;
    this._ruleId2desc = [null];
    this._includedGrammars = {};
    this._grammarRepository = grammarRepository;
    this._grammar = initGrammar(grammar, null);
    this._injections = null;
    this._tokenTypeMatchers = [];
    if (tokenTypes) {
      for (const selector of Object.keys(tokenTypes)) {
        const matchers = createMatchers(selector, nameMatcher);
        for (const matcher of matchers) {
          this._tokenTypeMatchers.push({
            matcher: matcher.matcher,
            type: tokenTypes[selector]
          });
        }
      }
    }
  }
  get themeProvider() {
    return this._grammarRepository;
  }
  dispose() {
    for (const rule of this._ruleId2desc) {
      if (rule) {
        rule.dispose();
      }
    }
  }
  createOnigScanner(sources) {
    return this._onigLib.createOnigScanner(sources);
  }
  createOnigString(sources) {
    return this._onigLib.createOnigString(sources);
  }
  getMetadataForScope(scope) {
    return this._basicScopeAttributesProvider.getBasicScopeAttributes(scope);
  }
  _collectInjections() {
    const grammarRepository = {
      lookup: (scopeName2) => {
        if (scopeName2 === this._rootScopeName) {
          return this._grammar;
        }
        return this.getExternalGrammar(scopeName2);
      },
      injections: (scopeName2) => {
        return this._grammarRepository.injections(scopeName2);
      }
    };
    const result = [];
    const scopeName = this._rootScopeName;
    const grammar = grammarRepository.lookup(scopeName);
    if (grammar) {
      const rawInjections = grammar.injections;
      if (rawInjections) {
        for (let expression in rawInjections) {
          collectInjections(result, expression, rawInjections[expression], this, grammar);
        }
      }
      const injectionScopeNames = this._grammarRepository.injections(scopeName);
      if (injectionScopeNames) {
        injectionScopeNames.forEach((injectionScopeName) => {
          const injectionGrammar = this.getExternalGrammar(injectionScopeName);
          if (injectionGrammar) {
            const selector = injectionGrammar.injectionSelector;
            if (selector) {
              collectInjections(result, selector, injectionGrammar, this, injectionGrammar);
            }
          }
        });
      }
    }
    result.sort((i1, i2) => i1.priority - i2.priority);
    return result;
  }
  getInjections() {
    if (this._injections === null) {
      this._injections = this._collectInjections();
    }
    return this._injections;
  }
  registerRule(factory) {
    const id = ++this._lastRuleId;
    const result = factory(ruleIdFromNumber(id));
    this._ruleId2desc[id] = result;
    return result;
  }
  getRule(ruleId) {
    return this._ruleId2desc[ruleIdToNumber(ruleId)];
  }
  getExternalGrammar(scopeName, repository) {
    if (this._includedGrammars[scopeName]) {
      return this._includedGrammars[scopeName];
    } else if (this._grammarRepository) {
      const rawIncludedGrammar = this._grammarRepository.lookup(scopeName);
      if (rawIncludedGrammar) {
        this._includedGrammars[scopeName] = initGrammar(rawIncludedGrammar, repository && repository.$base);
        return this._includedGrammars[scopeName];
      }
    }
    return void 0;
  }
  tokenizeLine(lineText, prevState, timeLimit = 0) {
    const r = this._tokenize(lineText, prevState, false, timeLimit);
    return {
      tokens: r.lineTokens.getResult(r.ruleStack, r.lineLength),
      ruleStack: r.ruleStack,
      stoppedEarly: r.stoppedEarly
    };
  }
  tokenizeLine2(lineText, prevState, timeLimit = 0) {
    const r = this._tokenize(lineText, prevState, true, timeLimit);
    return {
      tokens: r.lineTokens.getBinaryResult(r.ruleStack, r.lineLength),
      ruleStack: r.ruleStack,
      stoppedEarly: r.stoppedEarly
    };
  }
  _tokenize(lineText, prevState, emitBinaryTokens, timeLimit) {
    if (this._rootId === -1) {
      this._rootId = RuleFactory.getCompiledRuleId(this._grammar.repository.$self, this, this._grammar.repository);
      this.getInjections();
    }
    let isFirstLine;
    if (!prevState || prevState === StateStackImpl.NULL) {
      isFirstLine = true;
      const rawDefaultMetadata = this._basicScopeAttributesProvider.getDefaultAttributes();
      const defaultStyle = this.themeProvider.getDefaults();
      const defaultMetadata = EncodedTokenAttributes.set(0, rawDefaultMetadata.languageId, rawDefaultMetadata.tokenType, null, defaultStyle.fontStyle, defaultStyle.foregroundId, defaultStyle.backgroundId);
      const rootScopeName = this.getRule(this._rootId).getName(null, null);
      let scopeList;
      if (rootScopeName) {
        scopeList = AttributedScopeStack.createRootAndLookUpScopeName(rootScopeName, defaultMetadata, this);
      } else {
        scopeList = AttributedScopeStack.createRoot("unknown", defaultMetadata);
      }
      prevState = new StateStackImpl(null, this._rootId, -1, -1, false, null, scopeList, scopeList);
    } else {
      isFirstLine = false;
      prevState.reset();
    }
    lineText = lineText + "\n";
    const onigLineText = this.createOnigString(lineText);
    const lineLength = onigLineText.content.length;
    const lineTokens = new LineTokens(emitBinaryTokens, lineText, this._tokenTypeMatchers, this.balancedBracketSelectors);
    const r = _tokenizeString(this, onigLineText, isFirstLine, 0, prevState, lineTokens, true, timeLimit);
    disposeOnigString(onigLineText);
    return {
      lineLength,
      lineTokens,
      ruleStack: r.stack,
      stoppedEarly: r.stoppedEarly
    };
  }
};
function initGrammar(grammar, base) {
  grammar = clone(grammar);
  grammar.repository = grammar.repository || {};
  grammar.repository.$self = {
    $vscodeTextmateLocation: grammar.$vscodeTextmateLocation,
    patterns: grammar.patterns,
    name: grammar.scopeName
  };
  grammar.repository.$base = base || grammar.repository.$self;
  return grammar;
}
var AttributedScopeStack = class _AttributedScopeStack {
  /**
   * Invariant:
   * ```
   * if (parent && !scopePath.extends(parent.scopePath)) {
   * 	throw new Error();
   * }
   * ```
   */
  constructor(parent, scopePath, tokenAttributes) {
    __publicField(this, "parent");
    __publicField(this, "scopePath");
    __publicField(this, "tokenAttributes");
    this.parent = parent;
    this.scopePath = scopePath;
    this.tokenAttributes = tokenAttributes;
  }
  static fromExtension(namesScopeList, contentNameScopesList) {
    let current = namesScopeList;
    let scopeNames = (namesScopeList == null ? void 0 : namesScopeList.scopePath) ?? null;
    for (const frame of contentNameScopesList) {
      scopeNames = ScopeStack.push(scopeNames, frame.scopeNames);
      current = new _AttributedScopeStack(current, scopeNames, frame.encodedTokenAttributes);
    }
    return current;
  }
  static createRoot(scopeName, tokenAttributes) {
    return new _AttributedScopeStack(null, new ScopeStack(null, scopeName), tokenAttributes);
  }
  static createRootAndLookUpScopeName(scopeName, tokenAttributes, grammar) {
    const rawRootMetadata = grammar.getMetadataForScope(scopeName);
    const scopePath = new ScopeStack(null, scopeName);
    const rootStyle = grammar.themeProvider.themeMatch(scopePath);
    const resolvedTokenAttributes = _AttributedScopeStack.mergeAttributes(tokenAttributes, rawRootMetadata, rootStyle);
    return new _AttributedScopeStack(null, scopePath, resolvedTokenAttributes);
  }
  get scopeName() {
    return this.scopePath.scopeName;
  }
  toString() {
    return this.getScopeNames().join(" ");
  }
  equals(other) {
    return _AttributedScopeStack.equals(this, other);
  }
  static equals(a, b) {
    do {
      if (a === b) {
        return true;
      }
      if (!a && !b) {
        return true;
      }
      if (!a || !b) {
        return false;
      }
      if (a.scopeName !== b.scopeName || a.tokenAttributes !== b.tokenAttributes) {
        return false;
      }
      a = a.parent;
      b = b.parent;
    } while (true);
  }
  static mergeAttributes(existingTokenAttributes, basicScopeAttributes, styleAttributes) {
    let fontStyle = -1;
    let foreground = 0;
    let background = 0;
    if (styleAttributes !== null) {
      fontStyle = styleAttributes.fontStyle;
      foreground = styleAttributes.foregroundId;
      background = styleAttributes.backgroundId;
    }
    return EncodedTokenAttributes.set(existingTokenAttributes, basicScopeAttributes.languageId, basicScopeAttributes.tokenType, null, fontStyle, foreground, background);
  }
  pushAttributed(scopePath, grammar) {
    if (scopePath === null) {
      return this;
    }
    if (scopePath.indexOf(" ") === -1) {
      return _AttributedScopeStack._pushAttributed(this, scopePath, grammar);
    }
    const scopes = scopePath.split(/ /g);
    let result = this;
    for (const scope of scopes) {
      result = _AttributedScopeStack._pushAttributed(result, scope, grammar);
    }
    return result;
  }
  static _pushAttributed(target, scopeName, grammar) {
    const rawMetadata = grammar.getMetadataForScope(scopeName);
    const newPath = target.scopePath.push(scopeName);
    const scopeThemeMatchResult = grammar.themeProvider.themeMatch(newPath);
    const metadata = _AttributedScopeStack.mergeAttributes(target.tokenAttributes, rawMetadata, scopeThemeMatchResult);
    return new _AttributedScopeStack(target, newPath, metadata);
  }
  getScopeNames() {
    return this.scopePath.getSegments();
  }
  getExtensionIfDefined(base) {
    var _a;
    const result = [];
    let self = this;
    while (self && self !== base) {
      result.push({
        encodedTokenAttributes: self.tokenAttributes,
        scopeNames: self.scopePath.getExtensionIfDefined(((_a = self.parent) == null ? void 0 : _a.scopePath) ?? null)
      });
      self = self.parent;
    }
    return self === base ? result.reverse() : void 0;
  }
};
var _StateStackImpl = class _StateStackImpl {
  /**
   * Invariant:
   * ```
   * if (contentNameScopesList !== nameScopesList && contentNameScopesList?.parent !== nameScopesList) {
   * 	throw new Error();
   * }
   * if (this.parent && !nameScopesList.extends(this.parent.contentNameScopesList)) {
   * 	throw new Error();
   * }
   * ```
   */
  constructor(parent, ruleId, enterPos, anchorPos, beginRuleCapturedEOL, endRule, nameScopesList, contentNameScopesList) {
    __publicField(this, "parent");
    __publicField(this, "ruleId");
    __publicField(this, "beginRuleCapturedEOL");
    __publicField(this, "endRule");
    __publicField(this, "nameScopesList");
    __publicField(this, "contentNameScopesList");
    __publicField(this, "_stackElementBrand");
    /**
     * The position on the current line where this state was pushed.
     * This is relevant only while tokenizing a line, to detect endless loops.
     * Its value is meaningless across lines.
     */
    __publicField(this, "_enterPos");
    /**
     * The captured anchor position when this stack element was pushed.
     * This is relevant only while tokenizing a line, to restore the anchor position when popping.
     * Its value is meaningless across lines.
     */
    __publicField(this, "_anchorPos");
    /**
     * The depth of the stack.
     */
    __publicField(this, "depth");
    this.parent = parent;
    this.ruleId = ruleId;
    this.beginRuleCapturedEOL = beginRuleCapturedEOL;
    this.endRule = endRule;
    this.nameScopesList = nameScopesList;
    this.contentNameScopesList = contentNameScopesList;
    this.depth = this.parent ? this.parent.depth + 1 : 1;
    this._enterPos = enterPos;
    this._anchorPos = anchorPos;
  }
  equals(other) {
    if (other === null) {
      return false;
    }
    return _StateStackImpl._equals(this, other);
  }
  static _equals(a, b) {
    if (a === b) {
      return true;
    }
    if (!this._structuralEquals(a, b)) {
      return false;
    }
    return AttributedScopeStack.equals(a.contentNameScopesList, b.contentNameScopesList);
  }
  /**
   * A structural equals check. Does not take into account `scopes`.
   */
  static _structuralEquals(a, b) {
    do {
      if (a === b) {
        return true;
      }
      if (!a && !b) {
        return true;
      }
      if (!a || !b) {
        return false;
      }
      if (a.depth !== b.depth || a.ruleId !== b.ruleId || a.endRule !== b.endRule) {
        return false;
      }
      a = a.parent;
      b = b.parent;
    } while (true);
  }
  clone() {
    return this;
  }
  static _reset(el) {
    while (el) {
      el._enterPos = -1;
      el._anchorPos = -1;
      el = el.parent;
    }
  }
  reset() {
    _StateStackImpl._reset(this);
  }
  pop() {
    return this.parent;
  }
  safePop() {
    if (this.parent) {
      return this.parent;
    }
    return this;
  }
  push(ruleId, enterPos, anchorPos, beginRuleCapturedEOL, endRule, nameScopesList, contentNameScopesList) {
    return new _StateStackImpl(this, ruleId, enterPos, anchorPos, beginRuleCapturedEOL, endRule, nameScopesList, contentNameScopesList);
  }
  getEnterPos() {
    return this._enterPos;
  }
  getAnchorPos() {
    return this._anchorPos;
  }
  getRule(grammar) {
    return grammar.getRule(this.ruleId);
  }
  toString() {
    const r = [];
    this._writeString(r, 0);
    return "[" + r.join(",") + "]";
  }
  _writeString(res, outIndex) {
    var _a, _b;
    if (this.parent) {
      outIndex = this.parent._writeString(res, outIndex);
    }
    res[outIndex++] = `(${this.ruleId}, ${(_a = this.nameScopesList) == null ? void 0 : _a.toString()}, ${(_b = this.contentNameScopesList) == null ? void 0 : _b.toString()})`;
    return outIndex;
  }
  withContentNameScopesList(contentNameScopeStack) {
    if (this.contentNameScopesList === contentNameScopeStack) {
      return this;
    }
    return this.parent.push(this.ruleId, this._enterPos, this._anchorPos, this.beginRuleCapturedEOL, this.endRule, this.nameScopesList, contentNameScopeStack);
  }
  withEndRule(endRule) {
    if (this.endRule === endRule) {
      return this;
    }
    return new _StateStackImpl(this.parent, this.ruleId, this._enterPos, this._anchorPos, this.beginRuleCapturedEOL, endRule, this.nameScopesList, this.contentNameScopesList);
  }
  // Used to warn of endless loops
  hasSameRuleAs(other) {
    let el = this;
    while (el && el._enterPos === other._enterPos) {
      if (el.ruleId === other.ruleId) {
        return true;
      }
      el = el.parent;
    }
    return false;
  }
  toStateStackFrame() {
    var _a, _b, _c;
    return {
      ruleId: ruleIdToNumber(this.ruleId),
      beginRuleCapturedEOL: this.beginRuleCapturedEOL,
      endRule: this.endRule,
      nameScopesList: ((_b = this.nameScopesList) == null ? void 0 : _b.getExtensionIfDefined(((_a = this.parent) == null ? void 0 : _a.nameScopesList) ?? null)) ?? [],
      contentNameScopesList: ((_c = this.contentNameScopesList) == null ? void 0 : _c.getExtensionIfDefined(this.nameScopesList)) ?? []
    };
  }
  static pushFrame(self, frame) {
    const namesScopeList = AttributedScopeStack.fromExtension((self == null ? void 0 : self.nameScopesList) ?? null, frame.nameScopesList);
    return new _StateStackImpl(self, ruleIdFromNumber(frame.ruleId), frame.enterPos ?? -1, frame.anchorPos ?? -1, frame.beginRuleCapturedEOL, frame.endRule, namesScopeList, AttributedScopeStack.fromExtension(namesScopeList, frame.contentNameScopesList));
  }
};
// TODO remove me
__publicField(_StateStackImpl, "NULL", new _StateStackImpl(null, 0, 0, 0, false, null, null, null));
var StateStackImpl = _StateStackImpl;
var BalancedBracketSelectors = class {
  constructor(balancedBracketScopes, unbalancedBracketScopes) {
    __publicField(this, "balancedBracketScopes");
    __publicField(this, "unbalancedBracketScopes");
    __publicField(this, "allowAny", false);
    this.balancedBracketScopes = balancedBracketScopes.flatMap((selector) => {
      if (selector === "*") {
        this.allowAny = true;
        return [];
      }
      return createMatchers(selector, nameMatcher).map((m) => m.matcher);
    });
    this.unbalancedBracketScopes = unbalancedBracketScopes.flatMap((selector) => createMatchers(selector, nameMatcher).map((m) => m.matcher));
  }
  get matchesAlways() {
    return this.allowAny && this.unbalancedBracketScopes.length === 0;
  }
  get matchesNever() {
    return this.balancedBracketScopes.length === 0 && !this.allowAny;
  }
  match(scopes) {
    for (const excluder of this.unbalancedBracketScopes) {
      if (excluder(scopes)) {
        return false;
      }
    }
    for (const includer of this.balancedBracketScopes) {
      if (includer(scopes)) {
        return true;
      }
    }
    return this.allowAny;
  }
};
var LineTokens = class {
  constructor(emitBinaryTokens, lineText, tokenTypeOverrides, balancedBracketSelectors) {
    __publicField(this, "balancedBracketSelectors");
    __publicField(this, "_emitBinaryTokens");
    /**
     * defined only if `false`.
     */
    __publicField(this, "_lineText");
    /**
     * used only if `_emitBinaryTokens` is false.
     */
    __publicField(this, "_tokens");
    /**
     * used only if `_emitBinaryTokens` is true.
     */
    __publicField(this, "_binaryTokens");
    __publicField(this, "_lastTokenEndIndex");
    __publicField(this, "_tokenTypeOverrides");
    this.balancedBracketSelectors = balancedBracketSelectors;
    this._emitBinaryTokens = emitBinaryTokens;
    this._tokenTypeOverrides = tokenTypeOverrides;
    {
      this._lineText = null;
    }
    this._tokens = [];
    this._binaryTokens = [];
    this._lastTokenEndIndex = 0;
  }
  produce(stack, endIndex) {
    this.produceFromScopes(stack.contentNameScopesList, endIndex);
  }
  produceFromScopes(scopesList, endIndex) {
    var _a;
    if (this._lastTokenEndIndex >= endIndex) {
      return;
    }
    if (this._emitBinaryTokens) {
      let metadata = (scopesList == null ? void 0 : scopesList.tokenAttributes) ?? 0;
      let containsBalancedBrackets = false;
      if ((_a = this.balancedBracketSelectors) == null ? void 0 : _a.matchesAlways) {
        containsBalancedBrackets = true;
      }
      if (this._tokenTypeOverrides.length > 0 || this.balancedBracketSelectors && !this.balancedBracketSelectors.matchesAlways && !this.balancedBracketSelectors.matchesNever) {
        const scopes2 = (scopesList == null ? void 0 : scopesList.getScopeNames()) ?? [];
        for (const tokenType of this._tokenTypeOverrides) {
          if (tokenType.matcher(scopes2)) {
            metadata = EncodedTokenAttributes.set(metadata, 0, toOptionalTokenType(tokenType.type), null, -1, 0, 0);
          }
        }
        if (this.balancedBracketSelectors) {
          containsBalancedBrackets = this.balancedBracketSelectors.match(scopes2);
        }
      }
      if (containsBalancedBrackets) {
        metadata = EncodedTokenAttributes.set(metadata, 0, 8, containsBalancedBrackets, -1, 0, 0);
      }
      if (this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === metadata) {
        this._lastTokenEndIndex = endIndex;
        return;
      }
      this._binaryTokens.push(this._lastTokenEndIndex);
      this._binaryTokens.push(metadata);
      this._lastTokenEndIndex = endIndex;
      return;
    }
    const scopes = (scopesList == null ? void 0 : scopesList.getScopeNames()) ?? [];
    this._tokens.push({
      startIndex: this._lastTokenEndIndex,
      endIndex,
      // value: lineText.substring(lastTokenEndIndex, endIndex),
      scopes
    });
    this._lastTokenEndIndex = endIndex;
  }
  getResult(stack, lineLength) {
    if (this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === lineLength - 1) {
      this._tokens.pop();
    }
    if (this._tokens.length === 0) {
      this._lastTokenEndIndex = -1;
      this.produce(stack, lineLength);
      this._tokens[this._tokens.length - 1].startIndex = 0;
    }
    return this._tokens;
  }
  getBinaryResult(stack, lineLength) {
    if (this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === lineLength - 1) {
      this._binaryTokens.pop();
      this._binaryTokens.pop();
    }
    if (this._binaryTokens.length === 0) {
      this._lastTokenEndIndex = -1;
      this.produce(stack, lineLength);
      this._binaryTokens[this._binaryTokens.length - 2] = 0;
    }
    const result = new Uint32Array(this._binaryTokens.length);
    for (let i = 0, len = this._binaryTokens.length; i < len; i++) {
      result[i] = this._binaryTokens[i];
    }
    return result;
  }
};
var SyncRegistry = class {
  constructor(theme, _onigLibPromise) {
    __publicField(this, "_onigLibPromise");
    __publicField(this, "_grammars", /* @__PURE__ */ new Map());
    __publicField(this, "_rawGrammars", /* @__PURE__ */ new Map());
    __publicField(this, "_injectionGrammars", /* @__PURE__ */ new Map());
    __publicField(this, "_theme");
    this._onigLibPromise = _onigLibPromise;
    this._theme = theme;
  }
  dispose() {
    for (const grammar of this._grammars.values()) {
      grammar.dispose();
    }
  }
  setTheme(theme) {
    this._theme = theme;
  }
  getColorMap() {
    return this._theme.getColorMap();
  }
  /**
   * Add `grammar` to registry and return a list of referenced scope names
   */
  addGrammar(grammar, injectionScopeNames) {
    this._rawGrammars.set(grammar.scopeName, grammar);
    if (injectionScopeNames) {
      this._injectionGrammars.set(grammar.scopeName, injectionScopeNames);
    }
  }
  /**
   * Lookup a raw grammar.
   */
  lookup(scopeName) {
    return this._rawGrammars.get(scopeName);
  }
  /**
   * Returns the injections for the given grammar
   */
  injections(targetScope) {
    return this._injectionGrammars.get(targetScope);
  }
  /**
   * Get the default theme settings
   */
  getDefaults() {
    return this._theme.getDefaults();
  }
  /**
   * Match a scope in the theme.
   */
  themeMatch(scopePath) {
    return this._theme.match(scopePath);
  }
  /**
   * Lookup a grammar.
   */
  async grammarForScopeName(scopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors) {
    if (!this._grammars.has(scopeName)) {
      let rawGrammar = this._rawGrammars.get(scopeName);
      if (!rawGrammar) {
        return null;
      }
      this._grammars.set(scopeName, createGrammar(scopeName, rawGrammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, this, await this._onigLibPromise));
    }
    return this._grammars.get(scopeName);
  }
};
var Registry$1 = class Registry {
  constructor(options) {
    __publicField(this, "_options");
    __publicField(this, "_syncRegistry");
    __publicField(this, "_ensureGrammarCache");
    this._options = options;
    this._syncRegistry = new SyncRegistry(Theme.createFromRawTheme(options.theme, options.colorMap), options.onigLib);
    this._ensureGrammarCache = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._syncRegistry.dispose();
  }
  /**
   * Change the theme. Once called, no previous `ruleStack` should be used anymore.
   */
  setTheme(theme, colorMap) {
    this._syncRegistry.setTheme(Theme.createFromRawTheme(theme, colorMap));
  }
  /**
   * Returns a lookup array for color ids.
   */
  getColorMap() {
    return this._syncRegistry.getColorMap();
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   * Please do not use language id 0.
   */
  loadGrammarWithEmbeddedLanguages(initialScopeName, initialLanguage, embeddedLanguages) {
    return this.loadGrammarWithConfiguration(initialScopeName, initialLanguage, { embeddedLanguages });
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   * Please do not use language id 0.
   */
  loadGrammarWithConfiguration(initialScopeName, initialLanguage, configuration) {
    return this._loadGrammar(initialScopeName, initialLanguage, configuration.embeddedLanguages, configuration.tokenTypes, new BalancedBracketSelectors(configuration.balancedBracketSelectors || [], configuration.unbalancedBracketSelectors || []));
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   */
  loadGrammar(initialScopeName) {
    return this._loadGrammar(initialScopeName, 0, null, null, null);
  }
  async _loadGrammar(initialScopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors) {
    const dependencyProcessor = new ScopeDependencyProcessor(this._syncRegistry, initialScopeName);
    while (dependencyProcessor.Q.length > 0) {
      await Promise.all(dependencyProcessor.Q.map((request) => this._loadSingleGrammar(request.scopeName)));
      dependencyProcessor.processQueue();
    }
    return this._grammarForScopeName(initialScopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors);
  }
  async _loadSingleGrammar(scopeName) {
    if (!this._ensureGrammarCache.has(scopeName)) {
      this._ensureGrammarCache.set(scopeName, this._doLoadSingleGrammar(scopeName));
    }
    return this._ensureGrammarCache.get(scopeName);
  }
  async _doLoadSingleGrammar(scopeName) {
    const grammar = await this._options.loadGrammar(scopeName);
    if (grammar) {
      const injections = typeof this._options.getInjections === "function" ? this._options.getInjections(scopeName) : void 0;
      this._syncRegistry.addGrammar(grammar, injections);
    }
  }
  /**
   * Adds a rawGrammar.
   */
  async addGrammar(rawGrammar, injections = [], initialLanguage = 0, embeddedLanguages = null) {
    this._syncRegistry.addGrammar(rawGrammar, injections);
    return await this._grammarForScopeName(rawGrammar.scopeName, initialLanguage, embeddedLanguages);
  }
  /**
   * Get the grammar for `scopeName`. The grammar must first be created via `loadGrammar` or `addGrammar`.
   */
  _grammarForScopeName(scopeName, initialLanguage = 0, embeddedLanguages = null, tokenTypes = null, balancedBracketSelectors = null) {
    return this._syncRegistry.grammarForScopeName(scopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors);
  }
};
var INITIAL = StateStackImpl.NULL;
var MetadataConsts = {
  LANGUAGEID_MASK: 255,
  TOKEN_TYPE_MASK: 768,
  BALANCED_BRACKETS_MASK: 1024,
  FONT_STYLE_MASK: 14336,
  FOREGROUND_MASK: 8372224,
  BACKGROUND_MASK: 4286578688,
  LANGUAGEID_OFFSET: 0,
  TOKEN_TYPE_OFFSET: 8,
  BALANCED_BRACKETS_OFFSET: 10,
  FONT_STYLE_OFFSET: 11,
  FOREGROUND_OFFSET: 15,
  BACKGROUND_OFFSET: 24
};
var StackElementMetadata = class _StackElementMetadata {
  static toBinaryStr(metadata) {
    let r = metadata.toString(2);
    while (r.length < 32)
      r = `0${r}`;
    return r;
  }
  // public static printMetadata(metadata: number): void {
  //   const languageId = StackElementMetadata.getLanguageId(metadata)
  //   const tokenType = StackElementMetadata.getTokenType(metadata)
  //   const fontStyle = StackElementMetadata.getFontStyle(metadata)
  //   const foreground = StackElementMetadata.getForeground(metadata)
  //   const background = StackElementMetadata.getBackground(metadata)
  //   console.log({
  //     languageId,
  //     tokenType,
  //     fontStyle,
  //     foreground,
  //     background,
  //   })
  // }
  static getLanguageId(metadata) {
    return (metadata & MetadataConsts.LANGUAGEID_MASK) >>> MetadataConsts.LANGUAGEID_OFFSET;
  }
  static getTokenType(metadata) {
    return (metadata & MetadataConsts.TOKEN_TYPE_MASK) >>> MetadataConsts.TOKEN_TYPE_OFFSET;
  }
  static getFontStyle(metadata) {
    return (metadata & MetadataConsts.FONT_STYLE_MASK) >>> MetadataConsts.FONT_STYLE_OFFSET;
  }
  static getForeground(metadata) {
    return (metadata & MetadataConsts.FOREGROUND_MASK) >>> MetadataConsts.FOREGROUND_OFFSET;
  }
  static getBackground(metadata) {
    return (metadata & MetadataConsts.BACKGROUND_MASK) >>> MetadataConsts.BACKGROUND_OFFSET;
  }
  static containsBalancedBrackets(metadata) {
    return (metadata & MetadataConsts.BALANCED_BRACKETS_MASK) !== 0;
  }
  static set(metadata, languageId, tokenType, fontStyle, foreground, background) {
    let _languageId = _StackElementMetadata.getLanguageId(metadata);
    let _tokenType = _StackElementMetadata.getTokenType(metadata);
    let _fontStyle = _StackElementMetadata.getFontStyle(metadata);
    let _foreground = _StackElementMetadata.getForeground(metadata);
    let _background = _StackElementMetadata.getBackground(metadata);
    const _containsBalancedBracketsBit = _StackElementMetadata.containsBalancedBrackets(metadata) ? 1 : 0;
    if (languageId !== 0)
      _languageId = languageId;
    if (tokenType !== 0) {
      _tokenType = tokenType === 8 ? 0 : tokenType;
    }
    if (fontStyle !== FontStyle.NotSet)
      _fontStyle = fontStyle;
    if (foreground !== 0)
      _foreground = foreground;
    if (background !== 0)
      _background = background;
    return (_languageId << MetadataConsts.LANGUAGEID_OFFSET | _tokenType << MetadataConsts.TOKEN_TYPE_OFFSET | _fontStyle << MetadataConsts.FONT_STYLE_OFFSET | _containsBalancedBracketsBit << MetadataConsts.BALANCED_BRACKETS_OFFSET | _foreground << MetadataConsts.FOREGROUND_OFFSET | _background << MetadataConsts.BACKGROUND_OFFSET) >>> 0;
  }
};
var htmlVoidElements = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
var Schema = class {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(property, normal, space) {
    this.property = property;
    this.normal = normal;
    if (space) {
      this.space = space;
    }
  }
};
Schema.prototype.property = {};
Schema.prototype.normal = {};
Schema.prototype.space = null;
function merge(definitions, space) {
  const property = {};
  const normal = {};
  let index = -1;
  while (++index < definitions.length) {
    Object.assign(property, definitions[index].property);
    Object.assign(normal, definitions[index].normal);
  }
  return new Schema(property, normal, space);
}
function normalize(value) {
  return value.toLowerCase();
}
var Info = class {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(property, attribute) {
    this.property = property;
    this.attribute = attribute;
  }
};
Info.prototype.space = null;
Info.prototype.boolean = false;
Info.prototype.booleanish = false;
Info.prototype.overloadedBoolean = false;
Info.prototype.number = false;
Info.prototype.commaSeparated = false;
Info.prototype.spaceSeparated = false;
Info.prototype.commaOrSpaceSeparated = false;
Info.prototype.mustUseProperty = false;
Info.prototype.defined = false;
var powers = 0;
var boolean = increment();
var booleanish = increment();
var overloadedBoolean = increment();
var number = increment();
var spaceSeparated = increment();
var commaSeparated = increment();
var commaOrSpaceSeparated = increment();
function increment() {
  return 2 ** ++powers;
}
var types = Object.freeze({
  __proto__: null,
  boolean,
  booleanish,
  commaOrSpaceSeparated,
  commaSeparated,
  number,
  overloadedBoolean,
  spaceSeparated
});
var checks = Object.keys(types);
var DefinedInfo = class extends Info {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(property, attribute, mask, space) {
    let index = -1;
    super(property, attribute);
    mark(this, "space", space);
    if (typeof mask === "number") {
      while (++index < checks.length) {
        const check = checks[index];
        mark(this, checks[index], (mask & types[check]) === types[check]);
      }
    }
  }
};
DefinedInfo.prototype.defined = true;
function mark(values, key2, value) {
  if (value) {
    values[key2] = value;
  }
}
var own$3 = {}.hasOwnProperty;
function create(definition) {
  const property = {};
  const normal = {};
  let prop;
  for (prop in definition.properties) {
    if (own$3.call(definition.properties, prop)) {
      const value = definition.properties[prop];
      const info = new DefinedInfo(
        prop,
        definition.transform(definition.attributes || {}, prop),
        value,
        definition.space
      );
      if (definition.mustUseProperty && definition.mustUseProperty.includes(prop)) {
        info.mustUseProperty = true;
      }
      property[prop] = info;
      normal[normalize(prop)] = prop;
      normal[normalize(info.attribute)] = prop;
    }
  }
  return new Schema(property, normal, definition.space);
}
var xlink = create({
  space: "xlink",
  transform(_, prop) {
    return "xlink:" + prop.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
});
var xml = create({
  space: "xml",
  transform(_, prop) {
    return "xml:" + prop.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function caseSensitiveTransform(attributes, attribute) {
  return attribute in attributes ? attributes[attribute] : attribute;
}
function caseInsensitiveTransform(attributes, property) {
  return caseSensitiveTransform(attributes, property.toLowerCase());
}
var xmlns = create({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: caseInsensitiveTransform,
  properties: { xmlns: null, xmlnsXLink: null }
});
var aria = create({
  transform(_, prop) {
    return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish,
    ariaAutoComplete: null,
    ariaBusy: booleanish,
    ariaChecked: booleanish,
    ariaColCount: number,
    ariaColIndex: number,
    ariaColSpan: number,
    ariaControls: spaceSeparated,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated,
    ariaDetails: null,
    ariaDisabled: booleanish,
    ariaDropEffect: spaceSeparated,
    ariaErrorMessage: null,
    ariaExpanded: booleanish,
    ariaFlowTo: spaceSeparated,
    ariaGrabbed: booleanish,
    ariaHasPopup: null,
    ariaHidden: booleanish,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated,
    ariaLevel: number,
    ariaLive: null,
    ariaModal: booleanish,
    ariaMultiLine: booleanish,
    ariaMultiSelectable: booleanish,
    ariaOrientation: null,
    ariaOwns: spaceSeparated,
    ariaPlaceholder: null,
    ariaPosInSet: number,
    ariaPressed: booleanish,
    ariaReadOnly: booleanish,
    ariaRelevant: null,
    ariaRequired: booleanish,
    ariaRoleDescription: spaceSeparated,
    ariaRowCount: number,
    ariaRowIndex: number,
    ariaRowSpan: number,
    ariaSelected: booleanish,
    ariaSetSize: number,
    ariaSort: null,
    ariaValueMax: number,
    ariaValueMin: number,
    ariaValueNow: number,
    ariaValueText: null,
    role: null
  }
});
var html$3 = create({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: caseInsensitiveTransform,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    capture: boolean,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number,
    hidden: boolean,
    high: number,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number,
    manifest: null,
    max: null,
    maxLength: number,
    media: null,
    method: null,
    min: null,
    minLength: number,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number,
    rowSpan: number,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shape: null,
    size: number,
    sizes: null,
    slot: null,
    span: number,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: number,
    step: null,
    style: null,
    tabIndex: number,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number,
    wrap: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: number,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: boolean,
    // Lists. Use CSS to reduce space between items instead
    declare: boolean,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: number,
    // `<img>` and `<object>`
    leftMargin: number,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: number,
    // `<body>`
    marginWidth: number,
    // `<body>`
    noResize: boolean,
    // `<frame>`
    noHref: boolean,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: number,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: booleanish,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: number,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number,
    security: null,
    unselectable: null
  }
});
var svg$1 = create({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: caseSensitiveTransform,
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number,
    amplitude: number,
    arabicForm: null,
    ascent: number,
    attributeName: null,
    attributeType: null,
    azimuth: number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number,
    by: null,
    calcMode: null,
    capHeight: number,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number,
    diffuseConstant: number,
    direction: null,
    display: null,
    dur: null,
    divisor: number,
    dominantBaseline: null,
    download: boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number,
    horizOriginX: number,
    horizOriginY: number,
    id: null,
    ideographic: number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number,
    k: number,
    k1: number,
    k2: number,
    k3: number,
    k4: number,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number,
    overlineThickness: number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number,
    pointsAtY: number,
    pointsAtZ: number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number,
    specularExponent: number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number,
    strikethroughThickness: number,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number,
    strokeOpacity: number,
    strokeWidth: null,
    style: null,
    surfaceScale: number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number,
    tableValues: null,
    target: null,
    targetX: number,
    targetY: number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    u1: null,
    u2: null,
    underlinePosition: number,
    underlineThickness: number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number,
    values: null,
    vAlphabetic: number,
    vMathematical: number,
    vectorEffect: null,
    vHanging: number,
    vIdeographic: number,
    version: null,
    vertAdvY: number,
    vertOriginX: number,
    vertOriginY: number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
});
var valid = /^data[-\w.:]+$/i;
var dash = /-[a-z]/g;
var cap = /[A-Z]/g;
function find(schema, value) {
  const normal = normalize(value);
  let prop = value;
  let Type = Info;
  if (normal in schema.normal) {
    return schema.property[schema.normal[normal]];
  }
  if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
    if (value.charAt(4) === "-") {
      const rest = value.slice(5).replace(dash, camelcase);
      prop = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
    } else {
      const rest = value.slice(4);
      if (!dash.test(rest)) {
        let dashes = rest.replace(cap, kebab);
        if (dashes.charAt(0) !== "-") {
          dashes = "-" + dashes;
        }
        value = "data" + dashes;
      }
    }
    Type = DefinedInfo;
  }
  return new Type(prop, value);
}
function kebab($0) {
  return "-" + $0.toLowerCase();
}
function camelcase($0) {
  return $0.charAt(1).toUpperCase();
}
var html$2 = merge([xml, xlink, xmlns, aria, html$3], "html");
var svg = merge([xml, xlink, xmlns, aria, svg$1], "svg");
var own$2 = {}.hasOwnProperty;
function zwitch(key2, options) {
  const settings = options || {};
  function one2(value, ...parameters) {
    let fn = one2.invalid;
    const handlers = one2.handlers;
    if (value && own$2.call(value, key2)) {
      const id = String(value[key2]);
      fn = own$2.call(handlers, id) ? handlers[id] : one2.unknown;
    }
    if (fn) {
      return fn.call(this, value, ...parameters);
    }
  }
  one2.handlers = settings.handlers || {};
  one2.invalid = settings.invalid;
  one2.unknown = settings.unknown;
  return one2;
}
function core(value, options) {
  value = value.replace(
    options.subset ? charactersToExpression(options.subset) : /["&'<>`]/g,
    basic
  );
  if (options.subset || options.escapeOnly) {
    return value;
  }
  return value.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, surrogate).replace(
    // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
    /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g,
    basic
  );
  function surrogate(pair, index, all2) {
    return options.format(
      (pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536,
      all2.charCodeAt(index + 2),
      options
    );
  }
  function basic(character, index, all2) {
    return options.format(
      character.charCodeAt(0),
      all2.charCodeAt(index + 1),
      options
    );
  }
}
function charactersToExpression(subset) {
  const groups = [];
  let index = -1;
  while (++index < subset.length) {
    groups.push(subset[index].replace(/[|\\{}()[\]^$+*?.]/g, "\\$&"));
  }
  return new RegExp("(?:" + groups.join("|") + ")", "g");
}
function toHexadecimal(code, next, omit) {
  const value = "&#x" + code.toString(16).toUpperCase();
  return omit && next && !/[\dA-Fa-f]/.test(String.fromCharCode(next)) ? value : value + ";";
}
function toDecimal(code, next, omit) {
  const value = "&#" + String(code);
  return omit && next && !/\d/.test(String.fromCharCode(next)) ? value : value + ";";
}
var characterEntitiesLegacy = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
];
var characterEntitiesHtml4 = {
  nbsp: " ",
  iexcl: "¡",
  cent: "¢",
  pound: "£",
  curren: "¤",
  yen: "¥",
  brvbar: "¦",
  sect: "§",
  uml: "¨",
  copy: "©",
  ordf: "ª",
  laquo: "«",
  not: "¬",
  shy: "­",
  reg: "®",
  macr: "¯",
  deg: "°",
  plusmn: "±",
  sup2: "²",
  sup3: "³",
  acute: "´",
  micro: "µ",
  para: "¶",
  middot: "·",
  cedil: "¸",
  sup1: "¹",
  ordm: "º",
  raquo: "»",
  frac14: "¼",
  frac12: "½",
  frac34: "¾",
  iquest: "¿",
  Agrave: "À",
  Aacute: "Á",
  Acirc: "Â",
  Atilde: "Ã",
  Auml: "Ä",
  Aring: "Å",
  AElig: "Æ",
  Ccedil: "Ç",
  Egrave: "È",
  Eacute: "É",
  Ecirc: "Ê",
  Euml: "Ë",
  Igrave: "Ì",
  Iacute: "Í",
  Icirc: "Î",
  Iuml: "Ï",
  ETH: "Ð",
  Ntilde: "Ñ",
  Ograve: "Ò",
  Oacute: "Ó",
  Ocirc: "Ô",
  Otilde: "Õ",
  Ouml: "Ö",
  times: "×",
  Oslash: "Ø",
  Ugrave: "Ù",
  Uacute: "Ú",
  Ucirc: "Û",
  Uuml: "Ü",
  Yacute: "Ý",
  THORN: "Þ",
  szlig: "ß",
  agrave: "à",
  aacute: "á",
  acirc: "â",
  atilde: "ã",
  auml: "ä",
  aring: "å",
  aelig: "æ",
  ccedil: "ç",
  egrave: "è",
  eacute: "é",
  ecirc: "ê",
  euml: "ë",
  igrave: "ì",
  iacute: "í",
  icirc: "î",
  iuml: "ï",
  eth: "ð",
  ntilde: "ñ",
  ograve: "ò",
  oacute: "ó",
  ocirc: "ô",
  otilde: "õ",
  ouml: "ö",
  divide: "÷",
  oslash: "ø",
  ugrave: "ù",
  uacute: "ú",
  ucirc: "û",
  uuml: "ü",
  yacute: "ý",
  thorn: "þ",
  yuml: "ÿ",
  fnof: "ƒ",
  Alpha: "Α",
  Beta: "Β",
  Gamma: "Γ",
  Delta: "Δ",
  Epsilon: "Ε",
  Zeta: "Ζ",
  Eta: "Η",
  Theta: "Θ",
  Iota: "Ι",
  Kappa: "Κ",
  Lambda: "Λ",
  Mu: "Μ",
  Nu: "Ν",
  Xi: "Ξ",
  Omicron: "Ο",
  Pi: "Π",
  Rho: "Ρ",
  Sigma: "Σ",
  Tau: "Τ",
  Upsilon: "Υ",
  Phi: "Φ",
  Chi: "Χ",
  Psi: "Ψ",
  Omega: "Ω",
  alpha: "α",
  beta: "β",
  gamma: "γ",
  delta: "δ",
  epsilon: "ε",
  zeta: "ζ",
  eta: "η",
  theta: "θ",
  iota: "ι",
  kappa: "κ",
  lambda: "λ",
  mu: "μ",
  nu: "ν",
  xi: "ξ",
  omicron: "ο",
  pi: "π",
  rho: "ρ",
  sigmaf: "ς",
  sigma: "σ",
  tau: "τ",
  upsilon: "υ",
  phi: "φ",
  chi: "χ",
  psi: "ψ",
  omega: "ω",
  thetasym: "ϑ",
  upsih: "ϒ",
  piv: "ϖ",
  bull: "•",
  hellip: "…",
  prime: "′",
  Prime: "″",
  oline: "‾",
  frasl: "⁄",
  weierp: "℘",
  image: "ℑ",
  real: "ℜ",
  trade: "™",
  alefsym: "ℵ",
  larr: "←",
  uarr: "↑",
  rarr: "→",
  darr: "↓",
  harr: "↔",
  crarr: "↵",
  lArr: "⇐",
  uArr: "⇑",
  rArr: "⇒",
  dArr: "⇓",
  hArr: "⇔",
  forall: "∀",
  part: "∂",
  exist: "∃",
  empty: "∅",
  nabla: "∇",
  isin: "∈",
  notin: "∉",
  ni: "∋",
  prod: "∏",
  sum: "∑",
  minus: "−",
  lowast: "∗",
  radic: "√",
  prop: "∝",
  infin: "∞",
  ang: "∠",
  and: "∧",
  or: "∨",
  cap: "∩",
  cup: "∪",
  int: "∫",
  there4: "∴",
  sim: "∼",
  cong: "≅",
  asymp: "≈",
  ne: "≠",
  equiv: "≡",
  le: "≤",
  ge: "≥",
  sub: "⊂",
  sup: "⊃",
  nsub: "⊄",
  sube: "⊆",
  supe: "⊇",
  oplus: "⊕",
  otimes: "⊗",
  perp: "⊥",
  sdot: "⋅",
  lceil: "⌈",
  rceil: "⌉",
  lfloor: "⌊",
  rfloor: "⌋",
  lang: "〈",
  rang: "〉",
  loz: "◊",
  spades: "♠",
  clubs: "♣",
  hearts: "♥",
  diams: "♦",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "Œ",
  oelig: "œ",
  Scaron: "Š",
  scaron: "š",
  Yuml: "Ÿ",
  circ: "ˆ",
  tilde: "˜",
  ensp: " ",
  emsp: " ",
  thinsp: " ",
  zwnj: "‌",
  zwj: "‍",
  lrm: "‎",
  rlm: "‏",
  ndash: "–",
  mdash: "—",
  lsquo: "‘",
  rsquo: "’",
  sbquo: "‚",
  ldquo: "“",
  rdquo: "”",
  bdquo: "„",
  dagger: "†",
  Dagger: "‡",
  permil: "‰",
  lsaquo: "‹",
  rsaquo: "›",
  euro: "€"
};
var dangerous = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
];
var own$1 = {}.hasOwnProperty;
var characters = {};
var key;
for (key in characterEntitiesHtml4) {
  if (own$1.call(characterEntitiesHtml4, key)) {
    characters[characterEntitiesHtml4[key]] = key;
  }
}
function toNamed(code, next, omit, attribute) {
  const character = String.fromCharCode(code);
  if (own$1.call(characters, character)) {
    const name = characters[character];
    const value = "&" + name;
    if (omit && characterEntitiesLegacy.includes(name) && !dangerous.includes(name) && (!attribute || next && next !== 61 && /[^\da-z]/i.test(String.fromCharCode(next)))) {
      return value;
    }
    return value + ";";
  }
  return "";
}
function formatSmart(code, next, options) {
  let numeric = toHexadecimal(code, next, options.omitOptionalSemicolons);
  let named;
  if (options.useNamedReferences || options.useShortestReferences) {
    named = toNamed(
      code,
      next,
      options.omitOptionalSemicolons,
      options.attribute
    );
  }
  if ((options.useShortestReferences || !named) && options.useShortestReferences) {
    const decimal = toDecimal(code, next, options.omitOptionalSemicolons);
    if (decimal.length < numeric.length) {
      numeric = decimal;
    }
  }
  return named && (!options.useShortestReferences || named.length < numeric.length) ? named : numeric;
}
function stringifyEntities(value, options) {
  return core(value, Object.assign({ format: formatSmart }, options));
}
function comment(node, _1, _2, state) {
  return state.settings.bogusComments ? "<?" + stringifyEntities(
    node.value,
    Object.assign({}, state.settings.characterReferences, { subset: [">"] })
  ) + ">" : "<!--" + node.value.replace(/^>|^->|<!--|-->|--!>|<!-$/g, encode) + "-->";
  function encode($0) {
    return stringifyEntities(
      $0,
      Object.assign({}, state.settings.characterReferences, {
        subset: ["<", ">"]
      })
    );
  }
}
function doctype(_1, _2, _3, state) {
  return "<!" + (state.settings.upperDoctype ? "DOCTYPE" : "doctype") + (state.settings.tightDoctype ? "" : " ") + "html>";
}
function ccount(value, character) {
  const source = String(value);
  if (typeof character !== "string") {
    throw new TypeError("Expected character");
  }
  let count = 0;
  let index = source.indexOf(character);
  while (index !== -1) {
    count++;
    index = source.indexOf(character, index + character.length);
  }
  return count;
}
function stringify$1(values, options) {
  const settings = options || {};
  const input = values[values.length - 1] === "" ? [...values, ""] : values;
  return input.join(
    (settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")
  ).trim();
}
function stringify(values) {
  return values.join(" ").trim();
}
var re = /[ \t\n\f\r]/g;
function whitespace(thing) {
  return typeof thing === "object" ? thing.type === "text" ? empty(thing.value) : false : empty(thing);
}
function empty(value) {
  return value.replace(re, "") === "";
}
var siblingAfter = siblings(1);
var siblingBefore = siblings(-1);
var emptyChildren$1 = [];
function siblings(increment2) {
  return sibling;
  function sibling(parent, index, includeWhitespace) {
    const siblings2 = parent ? parent.children : emptyChildren$1;
    let offset = (index || 0) + increment2;
    let next = siblings2[offset];
    if (!includeWhitespace) {
      while (next && whitespace(next)) {
        offset += increment2;
        next = siblings2[offset];
      }
    }
    return next;
  }
}
var own = {}.hasOwnProperty;
function omission(handlers) {
  return omit;
  function omit(node, index, parent) {
    return own.call(handlers, node.tagName) && handlers[node.tagName](node, index, parent);
  }
}
var closing = omission({
  body: body$1,
  caption: headOrColgroupOrCaption,
  colgroup: headOrColgroupOrCaption,
  dd,
  dt,
  head: headOrColgroupOrCaption,
  html: html$1,
  li,
  optgroup,
  option,
  p,
  rp: rubyElement,
  rt: rubyElement,
  tbody: tbody$1,
  td: cells,
  tfoot,
  th: cells,
  thead,
  tr
});
function headOrColgroupOrCaption(_, index, parent) {
  const next = siblingAfter(parent, index, true);
  return !next || next.type !== "comment" && !(next.type === "text" && whitespace(next.value.charAt(0)));
}
function html$1(_, index, parent) {
  const next = siblingAfter(parent, index);
  return !next || next.type !== "comment";
}
function body$1(_, index, parent) {
  const next = siblingAfter(parent, index);
  return !next || next.type !== "comment";
}
function p(_, index, parent) {
  const next = siblingAfter(parent, index);
  return next ? next.type === "element" && (next.tagName === "address" || next.tagName === "article" || next.tagName === "aside" || next.tagName === "blockquote" || next.tagName === "details" || next.tagName === "div" || next.tagName === "dl" || next.tagName === "fieldset" || next.tagName === "figcaption" || next.tagName === "figure" || next.tagName === "footer" || next.tagName === "form" || next.tagName === "h1" || next.tagName === "h2" || next.tagName === "h3" || next.tagName === "h4" || next.tagName === "h5" || next.tagName === "h6" || next.tagName === "header" || next.tagName === "hgroup" || next.tagName === "hr" || next.tagName === "main" || next.tagName === "menu" || next.tagName === "nav" || next.tagName === "ol" || next.tagName === "p" || next.tagName === "pre" || next.tagName === "section" || next.tagName === "table" || next.tagName === "ul") : !parent || // Confusing parent.
  !(parent.type === "element" && (parent.tagName === "a" || parent.tagName === "audio" || parent.tagName === "del" || parent.tagName === "ins" || parent.tagName === "map" || parent.tagName === "noscript" || parent.tagName === "video"));
}
function li(_, index, parent) {
  const next = siblingAfter(parent, index);
  return !next || next.type === "element" && next.tagName === "li";
}
function dt(_, index, parent) {
  const next = siblingAfter(parent, index);
  return Boolean(
    next && next.type === "element" && (next.tagName === "dt" || next.tagName === "dd")
  );
}
function dd(_, index, parent) {
  const next = siblingAfter(parent, index);
  return !next || next.type === "element" && (next.tagName === "dt" || next.tagName === "dd");
}
function rubyElement(_, index, parent) {
  const next = siblingAfter(parent, index);
  return !next || next.type === "element" && (next.tagName === "rp" || next.tagName === "rt");
}
function optgroup(_, index, parent) {
  const next = siblingAfter(parent, index);
  return !next || next.type === "element" && next.tagName === "optgroup";
}
function option(_, index, parent) {
  const next = siblingAfter(parent, index);
  return !next || next.type === "element" && (next.tagName === "option" || next.tagName === "optgroup");
}
function thead(_, index, parent) {
  const next = siblingAfter(parent, index);
  return Boolean(
    next && next.type === "element" && (next.tagName === "tbody" || next.tagName === "tfoot")
  );
}
function tbody$1(_, index, parent) {
  const next = siblingAfter(parent, index);
  return !next || next.type === "element" && (next.tagName === "tbody" || next.tagName === "tfoot");
}
function tfoot(_, index, parent) {
  return !siblingAfter(parent, index);
}
function tr(_, index, parent) {
  const next = siblingAfter(parent, index);
  return !next || next.type === "element" && next.tagName === "tr";
}
function cells(_, index, parent) {
  const next = siblingAfter(parent, index);
  return !next || next.type === "element" && (next.tagName === "td" || next.tagName === "th");
}
var opening = omission({
  body,
  colgroup,
  head,
  html: html$4,
  tbody
});
function html$4(node) {
  const head2 = siblingAfter(node, -1);
  return !head2 || head2.type !== "comment";
}
function head(node) {
  const children = node.children;
  const seen = [];
  let index = -1;
  while (++index < children.length) {
    const child = children[index];
    if (child.type === "element" && (child.tagName === "title" || child.tagName === "base")) {
      if (seen.includes(child.tagName))
        return false;
      seen.push(child.tagName);
    }
  }
  return children.length > 0;
}
function body(node) {
  const head2 = siblingAfter(node, -1, true);
  return !head2 || head2.type !== "comment" && !(head2.type === "text" && whitespace(head2.value.charAt(0))) && !(head2.type === "element" && (head2.tagName === "meta" || head2.tagName === "link" || head2.tagName === "script" || head2.tagName === "style" || head2.tagName === "template"));
}
function colgroup(node, index, parent) {
  const previous = siblingBefore(parent, index);
  const head2 = siblingAfter(node, -1, true);
  if (parent && previous && previous.type === "element" && previous.tagName === "colgroup" && closing(previous, parent.children.indexOf(previous), parent)) {
    return false;
  }
  return Boolean(head2 && head2.type === "element" && head2.tagName === "col");
}
function tbody(node, index, parent) {
  const previous = siblingBefore(parent, index);
  const head2 = siblingAfter(node, -1);
  if (parent && previous && previous.type === "element" && (previous.tagName === "thead" || previous.tagName === "tbody") && closing(previous, parent.children.indexOf(previous), parent)) {
    return false;
  }
  return Boolean(head2 && head2.type === "element" && head2.tagName === "tr");
}
var constants = {
  // See: <https://html.spec.whatwg.org/#attribute-name-state>.
  name: [
    ["	\n\f\r &/=>".split(""), "	\n\f\r \"&'/=>`".split("")],
    [`\0	
\f\r "&'/<=>`.split(""), "\0	\n\f\r \"&'/<=>`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
  unquoted: [
    ["	\n\f\r &>".split(""), "\0	\n\f\r \"&'<=>`".split("")],
    ["\0	\n\f\r \"&'<=>`".split(""), "\0	\n\f\r \"&'<=>`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
  single: [
    ["&'".split(""), "\"&'`".split("")],
    ["\0&'".split(""), "\0\"&'`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
  double: [
    ['"&'.split(""), "\"&'`".split("")],
    ['\0"&'.split(""), "\0\"&'`".split("")]
  ]
};
function element(node, index, parent, state) {
  const schema = state.schema;
  const omit = schema.space === "svg" ? false : state.settings.omitOptionalTags;
  let selfClosing = schema.space === "svg" ? state.settings.closeEmptyElements : state.settings.voids.includes(node.tagName.toLowerCase());
  const parts = [];
  let last;
  if (schema.space === "html" && node.tagName === "svg") {
    state.schema = svg;
  }
  const attrs = serializeAttributes(state, node.properties);
  const content = state.all(
    schema.space === "html" && node.tagName === "template" ? node.content : node
  );
  state.schema = schema;
  if (content)
    selfClosing = false;
  if (attrs || !omit || !opening(node, index, parent)) {
    parts.push("<", node.tagName, attrs ? " " + attrs : "");
    if (selfClosing && (schema.space === "svg" || state.settings.closeSelfClosing)) {
      last = attrs.charAt(attrs.length - 1);
      if (!state.settings.tightSelfClosing || last === "/" || last && last !== '"' && last !== "'") {
        parts.push(" ");
      }
      parts.push("/");
    }
    parts.push(">");
  }
  parts.push(content);
  if (!selfClosing && (!omit || !closing(node, index, parent))) {
    parts.push("</" + node.tagName + ">");
  }
  return parts.join("");
}
function serializeAttributes(state, props) {
  const values = [];
  let index = -1;
  let key2;
  if (props) {
    for (key2 in props) {
      if (props[key2] !== null && props[key2] !== void 0) {
        const value = serializeAttribute(state, key2, props[key2]);
        if (value)
          values.push(value);
      }
    }
  }
  while (++index < values.length) {
    const last = state.settings.tightAttributes ? values[index].charAt(values[index].length - 1) : void 0;
    if (index !== values.length - 1 && last !== '"' && last !== "'") {
      values[index] += " ";
    }
  }
  return values.join("");
}
function serializeAttribute(state, key2, value) {
  const info = find(state.schema, key2);
  const x = state.settings.allowParseErrors && state.schema.space === "html" ? 0 : 1;
  const y = state.settings.allowDangerousCharacters ? 0 : 1;
  let quote = state.quote;
  let result;
  if (info.overloadedBoolean && (value === info.attribute || value === "")) {
    value = true;
  } else if (info.boolean || info.overloadedBoolean && typeof value !== "string") {
    value = Boolean(value);
  }
  if (value === null || value === void 0 || value === false || typeof value === "number" && Number.isNaN(value)) {
    return "";
  }
  const name = stringifyEntities(
    info.attribute,
    Object.assign({}, state.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: constants.name[x][y]
    })
  );
  if (value === true)
    return name;
  value = Array.isArray(value) ? (info.commaSeparated ? stringify$1 : stringify)(value, {
    padLeft: !state.settings.tightCommaSeparatedLists
  }) : String(value);
  if (state.settings.collapseEmptyAttributes && !value)
    return name;
  if (state.settings.preferUnquoted) {
    result = stringifyEntities(
      value,
      Object.assign({}, state.settings.characterReferences, {
        attribute: true,
        subset: constants.unquoted[x][y]
      })
    );
  }
  if (result !== value) {
    if (state.settings.quoteSmart && ccount(value, quote) > ccount(value, state.alternative)) {
      quote = state.alternative;
    }
    result = quote + stringifyEntities(
      value,
      Object.assign({}, state.settings.characterReferences, {
        // Always encode without parse errors in non-HTML.
        subset: (quote === "'" ? constants.single : constants.double)[x][y],
        attribute: true
      })
    ) + quote;
  }
  return name + (result ? "=" + result : result);
}
function text(node, _, parent, state) {
  return parent && parent.type === "element" && (parent.tagName === "script" || parent.tagName === "style") ? node.value : stringifyEntities(
    node.value,
    Object.assign({}, state.settings.characterReferences, {
      subset: ["<", "&"]
    })
  );
}
function raw(node, index, parent, state) {
  return state.settings.allowDangerousHtml ? node.value : text(node, index, parent, state);
}
function root(node, _1, _2, state) {
  return state.all(node);
}
var handle = zwitch("type", {
  invalid,
  unknown,
  handlers: { comment, doctype, element, raw, root, text }
});
function invalid(node) {
  throw new Error("Expected node, not `" + node + "`");
}
function unknown(node_) {
  const node = (
    /** @type {Nodes} */
    node_
  );
  throw new Error("Cannot compile unknown node `" + node.type + "`");
}
var emptyOptions = {};
var emptyCharacterReferences = {};
var emptyChildren = [];
function toHtml(tree, options) {
  const options_ = options || emptyOptions;
  const quote = options_.quote || '"';
  const alternative = quote === '"' ? "'" : '"';
  if (quote !== '"' && quote !== "'") {
    throw new Error("Invalid quote `" + quote + "`, expected `'` or `\"`");
  }
  const state = {
    one,
    all,
    settings: {
      omitOptionalTags: options_.omitOptionalTags || false,
      allowParseErrors: options_.allowParseErrors || false,
      allowDangerousCharacters: options_.allowDangerousCharacters || false,
      quoteSmart: options_.quoteSmart || false,
      preferUnquoted: options_.preferUnquoted || false,
      tightAttributes: options_.tightAttributes || false,
      upperDoctype: options_.upperDoctype || false,
      tightDoctype: options_.tightDoctype || false,
      bogusComments: options_.bogusComments || false,
      tightCommaSeparatedLists: options_.tightCommaSeparatedLists || false,
      tightSelfClosing: options_.tightSelfClosing || false,
      collapseEmptyAttributes: options_.collapseEmptyAttributes || false,
      allowDangerousHtml: options_.allowDangerousHtml || false,
      voids: options_.voids || htmlVoidElements,
      characterReferences: options_.characterReferences || emptyCharacterReferences,
      closeSelfClosing: options_.closeSelfClosing || false,
      closeEmptyElements: options_.closeEmptyElements || false
    },
    schema: options_.space === "svg" ? svg : html$2,
    quote,
    alternative
  };
  return state.one(
    Array.isArray(tree) ? { type: "root", children: tree } : tree,
    void 0,
    void 0
  );
}
function one(node, index, parent) {
  return handle(node, index, parent, this);
}
function all(parent) {
  const results = [];
  const children = parent && parent.children || emptyChildren;
  let index = -1;
  while (++index < children.length) {
    results[index] = this.one(children[index], index, parent);
  }
  return results.join("");
}
function isPlaintext(lang2) {
  return !lang2 || ["plaintext", "txt", "text", "plain"].includes(lang2);
}
var namedColors = [
  "black",
  "red",
  "green",
  "yellow",
  "blue",
  "magenta",
  "cyan",
  "white",
  "brightBlack",
  "brightRed",
  "brightGreen",
  "brightYellow",
  "brightBlue",
  "brightMagenta",
  "brightCyan",
  "brightWhite"
];
var decorations = {
  1: "bold",
  2: "dim",
  3: "italic",
  4: "underline",
  7: "reverse",
  9: "strikethrough"
};
function findSequence(value, position) {
  const nextEscape = value.indexOf("\x1B[", position);
  if (nextEscape !== -1) {
    const nextClose = value.indexOf("m", nextEscape);
    return {
      sequence: value.substring(nextEscape + 2, nextClose).split(";"),
      startPosition: nextEscape,
      position: nextClose + 1
    };
  }
  return {
    position: value.length
  };
}
function parseColor(sequence, index) {
  let offset = 1;
  const colorMode = sequence[index + offset++];
  let color;
  if (colorMode === "2") {
    const rgb = [
      sequence[index + offset++],
      sequence[index + offset++],
      sequence[index + offset]
    ].map((x) => Number.parseInt(x));
    if (rgb.length === 3 && !rgb.some((x) => Number.isNaN(x))) {
      color = {
        type: "rgb",
        rgb
      };
    }
  } else if (colorMode === "5") {
    const colorIndex = Number.parseInt(sequence[index + offset]);
    if (!Number.isNaN(colorIndex)) {
      color = { type: "table", index: Number(colorIndex) };
    }
  }
  return [offset, color];
}
function parseSequence(sequence) {
  const commands = [];
  for (let i = 0; i < sequence.length; i++) {
    const code = sequence[i];
    const codeInt = Number.parseInt(code);
    if (Number.isNaN(codeInt))
      continue;
    if (codeInt === 0) {
      commands.push({ type: "resetAll" });
    } else if (codeInt <= 9) {
      const decoration = decorations[codeInt];
      if (decoration) {
        commands.push({
          type: "setDecoration",
          value: decorations[codeInt]
        });
      }
    } else if (codeInt <= 29) {
      const decoration = decorations[codeInt - 20];
      if (decoration) {
        commands.push({
          type: "resetDecoration",
          value: decoration
        });
      }
    } else if (codeInt <= 37) {
      commands.push({
        type: "setForegroundColor",
        value: { type: "named", name: namedColors[codeInt - 30] }
      });
    } else if (codeInt === 38) {
      const [offset, color] = parseColor(sequence, i);
      if (color) {
        commands.push({
          type: "setForegroundColor",
          value: color
        });
      }
      i += offset;
    } else if (codeInt === 39) {
      commands.push({
        type: "resetForegroundColor"
      });
    } else if (codeInt <= 47) {
      commands.push({
        type: "setBackgroundColor",
        value: { type: "named", name: namedColors[codeInt - 40] }
      });
    } else if (codeInt === 48) {
      const [offset, color] = parseColor(sequence, i);
      if (color) {
        commands.push({
          type: "setBackgroundColor",
          value: color
        });
      }
      i += offset;
    } else if (codeInt === 49) {
      commands.push({
        type: "resetBackgroundColor"
      });
    } else if (codeInt >= 90 && codeInt <= 97) {
      commands.push({
        type: "setForegroundColor",
        value: { type: "named", name: namedColors[codeInt - 90 + 8] }
      });
    } else if (codeInt >= 100 && codeInt <= 107) {
      commands.push({
        type: "setBackgroundColor",
        value: { type: "named", name: namedColors[codeInt - 100 + 8] }
      });
    }
  }
  return commands;
}
function createAnsiSequenceParser() {
  let foreground = null;
  let background = null;
  let decorations2 = /* @__PURE__ */ new Set();
  return {
    parse(value) {
      const tokens = [];
      let position = 0;
      do {
        const findResult = findSequence(value, position);
        const text2 = findResult.sequence ? value.substring(position, findResult.startPosition) : value.substring(position);
        if (text2.length > 0) {
          tokens.push({
            value: text2,
            foreground,
            background,
            decorations: new Set(decorations2)
          });
        }
        if (findResult.sequence) {
          const commands = parseSequence(findResult.sequence);
          for (const styleToken of commands) {
            if (styleToken.type === "resetAll") {
              foreground = null;
              background = null;
              decorations2.clear();
            } else if (styleToken.type === "resetForegroundColor") {
              foreground = null;
            } else if (styleToken.type === "resetBackgroundColor") {
              background = null;
            } else if (styleToken.type === "resetDecoration") {
              decorations2.delete(styleToken.value);
            }
          }
          for (const styleToken of commands) {
            if (styleToken.type === "setForegroundColor") {
              foreground = styleToken.value;
            } else if (styleToken.type === "setBackgroundColor") {
              background = styleToken.value;
            } else if (styleToken.type === "setDecoration") {
              decorations2.add(styleToken.value);
            }
          }
        }
        position = findResult.position;
      } while (position < value.length);
      return tokens;
    }
  };
}
var defaultNamedColorsMap = {
  black: "#000000",
  red: "#bb0000",
  green: "#00bb00",
  yellow: "#bbbb00",
  blue: "#0000bb",
  magenta: "#ff00ff",
  cyan: "#00bbbb",
  white: "#eeeeee",
  brightBlack: "#555555",
  brightRed: "#ff5555",
  brightGreen: "#00ff00",
  brightYellow: "#ffff55",
  brightBlue: "#5555ff",
  brightMagenta: "#ff55ff",
  brightCyan: "#55ffff",
  brightWhite: "#ffffff"
};
function createColorPalette(namedColorsMap = defaultNamedColorsMap) {
  function namedColor(name) {
    return namedColorsMap[name];
  }
  function rgbColor(rgb) {
    return `#${rgb.map((x) => Math.max(0, Math.min(x, 255)).toString(16).padStart(2, "0")).join("")}`;
  }
  let colorTable;
  function getColorTable() {
    if (colorTable) {
      return colorTable;
    }
    colorTable = [];
    for (let i = 0; i < namedColors.length; i++) {
      colorTable.push(namedColor(namedColors[i]));
    }
    let levels = [0, 95, 135, 175, 215, 255];
    for (let r = 0; r < 6; r++) {
      for (let g = 0; g < 6; g++) {
        for (let b = 0; b < 6; b++) {
          colorTable.push(rgbColor([levels[r], levels[g], levels[b]]));
        }
      }
    }
    let level = 8;
    for (let i = 0; i < 24; i++, level += 10) {
      colorTable.push(rgbColor([level, level, level]));
    }
    return colorTable;
  }
  function tableColor(index) {
    return getColorTable()[index];
  }
  function value(color) {
    switch (color.type) {
      case "named":
        return namedColor(color.name);
      case "rgb":
        return rgbColor(color.rgb);
      case "table":
        return tableColor(color.index);
    }
  }
  return {
    value
  };
}
function tokenizeAnsiWithTheme(theme, fileContents, options) {
  const colorReplacements = {
    ...theme.colorReplacements,
    ...options == null ? void 0 : options.colorReplacements
  };
  const lines = fileContents.split(/\r?\n/);
  const colorPalette = createColorPalette(Object.fromEntries(namedColors.map((name) => {
    var _a;
    return [
      name,
      (_a = theme.colors) == null ? void 0 : _a[`terminal.ansi${name[0].toUpperCase()}${name.substring(1)}`]
    ];
  })));
  const parser = createAnsiSequenceParser();
  return lines.map((line) => parser.parse(line).map((token) => {
    let color;
    if (token.decorations.has("reverse"))
      color = token.background ? colorPalette.value(token.background) : theme.bg;
    else
      color = token.foreground ? colorPalette.value(token.foreground) : theme.fg;
    color = applyColorReplacements(color, colorReplacements);
    if (token.decorations.has("dim"))
      color = dimColor(color);
    let fontStyle = FontStyle.None;
    if (token.decorations.has("bold"))
      fontStyle |= FontStyle.Bold;
    if (token.decorations.has("italic"))
      fontStyle |= FontStyle.Italic;
    if (token.decorations.has("underline"))
      fontStyle |= FontStyle.Underline;
    return {
      content: token.value,
      color,
      fontStyle
    };
  }));
}
function dimColor(color) {
  const hexMatch = color.match(/#([0-9a-f]{3})([0-9a-f]{3})?([0-9a-f]{2})?/);
  if (hexMatch) {
    if (hexMatch[3]) {
      const alpha = Math.round(Number.parseInt(hexMatch[3], 16) / 2).toString(16).padStart(2, "0");
      return `#${hexMatch[1]}${hexMatch[2]}${alpha}`;
    } else if (hexMatch[2]) {
      return `#${hexMatch[1]}${hexMatch[2]}80`;
    } else {
      return `#${Array.from(hexMatch[1]).map((x) => `${x}${x}`).join("")}80`;
    }
  }
  const cssVarMatch = color.match(/var\((--[\w-]+-ansi-[\w-]+)\)/);
  if (cssVarMatch)
    return `var(${cssVarMatch[1]}-dim)`;
  return color;
}
function codeToThemedTokens(internal, code, options = {}) {
  const { lang: lang2 = "text", theme: themeName = internal.getLoadedThemes()[0] } = options;
  if (isPlaintext(lang2)) {
    const lines = code.split(/\r\n|\r|\n/);
    return [...lines.map((line) => [{ content: line }])];
  }
  const { theme, colorMap } = internal.setTheme(themeName);
  if (lang2 === "ansi")
    return tokenizeAnsiWithTheme(theme, code, options);
  const _grammar = internal.getLangGrammar(lang2);
  return tokenizeWithTheme(code, _grammar, theme, colorMap, options);
}
function tokenizeWithTheme(code, grammar, theme, colorMap, options) {
  const colorReplacements = {
    ...theme.colorReplacements,
    ...options == null ? void 0 : options.colorReplacements
  };
  const lines = code.split(/\r\n|\r|\n/);
  let ruleStack = INITIAL;
  let actual = [];
  const final = [];
  for (let i = 0, len = lines.length; i < len; i++) {
    const line = lines[i];
    if (line === "") {
      actual = [];
      final.push([]);
      continue;
    }
    let resultWithScopes;
    let tokensWithScopes;
    let tokensWithScopesIndex;
    if (options.includeExplanation) {
      resultWithScopes = grammar.tokenizeLine(line, ruleStack);
      tokensWithScopes = resultWithScopes.tokens;
      tokensWithScopesIndex = 0;
    }
    const result = grammar.tokenizeLine2(line, ruleStack);
    const tokensLength = result.tokens.length / 2;
    for (let j = 0; j < tokensLength; j++) {
      const startIndex = result.tokens[2 * j];
      const nextStartIndex = j + 1 < tokensLength ? result.tokens[2 * j + 2] : line.length;
      if (startIndex === nextStartIndex)
        continue;
      const metadata = result.tokens[2 * j + 1];
      const foreground = StackElementMetadata.getForeground(metadata);
      const foregroundColor = applyColorReplacements(colorMap[foreground], colorReplacements);
      const fontStyle = StackElementMetadata.getFontStyle(metadata);
      const token = {
        content: line.substring(startIndex, nextStartIndex),
        color: foregroundColor,
        fontStyle
      };
      if (options.includeExplanation) {
        token.explanation = [];
        let offset = 0;
        while (startIndex + offset < nextStartIndex) {
          const tokenWithScopes = tokensWithScopes[tokensWithScopesIndex];
          const tokenWithScopesText = line.substring(tokenWithScopes.startIndex, tokenWithScopes.endIndex);
          offset += tokenWithScopesText.length;
          token.explanation.push({
            content: tokenWithScopesText,
            scopes: explainThemeScopes(theme, tokenWithScopes.scopes)
          });
          tokensWithScopesIndex += 1;
        }
      }
      actual.push(token);
    }
    final.push(actual);
    actual = [];
    ruleStack = result.ruleStack;
  }
  return final;
}
function explainThemeScopes(theme, scopes) {
  const result = [];
  for (let i = 0, len = scopes.length; i < len; i++) {
    const parentScopes = scopes.slice(0, i);
    const scope = scopes[i];
    result[i] = {
      scopeName: scope,
      themeMatches: explainThemeScope(theme, scope, parentScopes)
    };
  }
  return result;
}
function matchesOne(selector, scope) {
  const selectorPrefix = `${selector}.`;
  if (selector === scope || scope.substring(0, selectorPrefix.length) === selectorPrefix)
    return true;
  return false;
}
function matches(selector, selectorParentScopes, scope, parentScopes) {
  if (!matchesOne(selector, scope))
    return false;
  let selectorParentIndex = selectorParentScopes.length - 1;
  let parentIndex = parentScopes.length - 1;
  while (selectorParentIndex >= 0 && parentIndex >= 0) {
    if (matchesOne(selectorParentScopes[selectorParentIndex], parentScopes[parentIndex]))
      selectorParentIndex -= 1;
    parentIndex -= 1;
  }
  if (selectorParentIndex === -1)
    return true;
  return false;
}
function explainThemeScope(theme, scope, parentScopes) {
  const result = [];
  let resultLen = 0;
  for (let i = 0, len = theme.settings.length; i < len; i++) {
    const setting = theme.settings[i];
    let selectors;
    if (typeof setting.scope === "string")
      selectors = setting.scope.split(/,/).map((scope2) => scope2.trim());
    else if (Array.isArray(setting.scope))
      selectors = setting.scope;
    else
      continue;
    for (let j = 0, lenJ = selectors.length; j < lenJ; j++) {
      const rawSelector = selectors[j];
      const rawSelectorPieces = rawSelector.split(/ /);
      const selector = rawSelectorPieces[rawSelectorPieces.length - 1];
      const selectorParentScopes = rawSelectorPieces.slice(0, rawSelectorPieces.length - 1);
      if (matches(selector, selectorParentScopes, scope, parentScopes)) {
        result[resultLen++] = setting;
        j = lenJ;
      }
    }
  }
  return result;
}
function applyColorReplacements(color, replacements) {
  return (replacements == null ? void 0 : replacements[color.toLowerCase()]) || color;
}
function codeToTokensWithThemes(internal, code, options) {
  const themes = Object.entries(options.themes).filter((i) => i[1]).map((i) => ({ color: i[0], theme: i[1] }));
  const tokens = syncThemesTokenization(...themes.map((t) => codeToThemedTokens(internal, code, {
    ...options,
    theme: t.theme,
    includeExplanation: false
  })));
  const mergedTokens = tokens[0].map((line, lineIdx) => line.map((_token, tokenIdx) => {
    const mergedToken = {
      content: _token.content,
      variants: {}
    };
    tokens.forEach((t, themeIdx) => {
      const { content: _, explanation: __, ...styles } = t[lineIdx][tokenIdx];
      mergedToken.variants[themes[themeIdx].color] = styles;
    });
    return mergedToken;
  }));
  return mergedTokens;
}
function syncThemesTokenization(...themes) {
  const outThemes = themes.map(() => []);
  const count = themes.length;
  for (let i = 0; i < themes[0].length; i++) {
    const lines = themes.map((t) => t[i]);
    const outLines = outThemes.map(() => []);
    outThemes.forEach((t, i2) => t.push(outLines[i2]));
    const indexes = lines.map(() => 0);
    const current = lines.map((l) => l[0]);
    while (current.every((t) => t)) {
      const minLength = Math.min(...current.map((t) => t.content.length));
      for (let n = 0; n < count; n++) {
        const token = current[n];
        if (token.content.length === minLength) {
          outLines[n].push(token);
          indexes[n] += 1;
          current[n] = lines[n][indexes[n]];
        } else {
          outLines[n].push({
            ...token,
            content: token.content.slice(0, minLength)
          });
          current[n] = {
            ...token,
            content: token.content.slice(minLength)
          };
        }
      }
    }
  }
  return outThemes;
}
function codeToHast(internal, code, options, transformerContext = {
  meta: {},
  options,
  codeToHast: (_code, _options) => codeToHast(internal, _code, _options)
}) {
  var _a;
  let input = code;
  for (const transformer of options.transformers || [])
    input = ((_a = transformer.preprocess) == null ? void 0 : _a.call(transformerContext, input, options)) || input;
  let bg;
  let fg;
  let tokens;
  let themeName;
  let rootStyle;
  if ("themes" in options) {
    const { defaultColor = "light", cssVariablePrefix = "--shiki-" } = options;
    const themes = Object.entries(options.themes).filter((i) => i[1]).map((i) => ({ color: i[0], theme: i[1] })).sort((a, b) => a.color === defaultColor ? -1 : b.color === defaultColor ? 1 : 0);
    if (themes.length === 0)
      throw new Error("[shikiji] `themes` option must not be empty");
    const themeTokens = codeToTokensWithThemes(internal, input, options);
    if (defaultColor && !themes.find((t) => t.color === defaultColor))
      throw new Error(`[shikiji] \`themes\` option must contain the defaultColor key \`${defaultColor}\``);
    const themeRegs = themes.map((t) => internal.getTheme(t.theme));
    const themesOrder = themes.map((t) => t.color);
    tokens = themeTokens.map((line) => line.map((token) => mergeToken(token, themesOrder, cssVariablePrefix, defaultColor)));
    fg = themes.map((t, idx) => (idx === 0 && defaultColor ? "" : `${cssVariablePrefix + t.color}:`) + themeRegs[idx].fg).join(";");
    bg = themes.map((t, idx) => (idx === 0 && defaultColor ? "" : `${cssVariablePrefix + t.color}-bg:`) + themeRegs[idx].bg).join(";");
    themeName = `shiki-themes ${themeRegs.map((t) => t.name).join(" ")}`;
    rootStyle = defaultColor ? void 0 : [fg, bg].join(";");
  } else if ("theme" in options) {
    tokens = codeToThemedTokens(internal, input, {
      ...options,
      includeExplanation: false
    });
    const _theme = internal.getTheme(options.theme);
    bg = _theme.bg;
    fg = _theme.fg;
    themeName = _theme.name;
  } else {
    throw new Error("[shikiji] Invalid options, either `theme` or `themes` must be provided");
  }
  return tokensToHast(tokens, {
    ...options,
    fg,
    bg,
    themeName,
    rootStyle
  }, transformerContext);
}
function mergeToken(merged, variantsOrder, cssVariablePrefix, defaultColor) {
  const token = {
    content: merged.content,
    explanation: merged.explanation
  };
  const styles = variantsOrder.map((t) => getTokenStyleObject(merged.variants[t]));
  const styleKeys = new Set(styles.flatMap((t) => Object.keys(t)));
  const mergedStyles = styles.reduce((acc, cur, idx) => {
    for (const key2 of styleKeys) {
      const value = cur[key2] || "inherit";
      if (idx === 0 && defaultColor) {
        acc[key2] = value;
      } else {
        const varKey = cssVariablePrefix + variantsOrder[idx] + (key2 === "color" ? "" : `-${key2}`);
        if (acc[key2])
          acc[key2] += `;${varKey}:${value}`;
        else
          acc[key2] = `${varKey}:${value}`;
      }
    }
    return acc;
  }, {});
  token.htmlStyle = defaultColor ? stringifyTokenStyle(mergedStyles) : Object.values(mergedStyles).join(";");
  return token;
}
function tokensToHast(tokens, options, transformerContext) {
  var _a, _b, _c;
  const { mergeWhitespaces = true, transformers = [] } = options;
  if (options.transforms) {
    transformers.push(options.transforms);
    console.warn("[shikiji] `transforms` option is deprecated, use `transformers` instead");
  }
  if (mergeWhitespaces === true)
    tokens = mergeWhitespaceTokens(tokens);
  else if (mergeWhitespaces === "never")
    tokens = splitWhitespaceTokens(tokens);
  const lines = [];
  const tree = {
    type: "root",
    children: []
  };
  let preNode = {
    type: "element",
    tagName: "pre",
    properties: {
      class: `shiki ${options.themeName || ""}`,
      style: options.rootStyle || `background-color:${options.bg};color:${options.fg}`,
      tabindex: "0",
      ...Object.fromEntries(Array.from(Object.entries(options.meta || {})).filter(([key2]) => !key2.startsWith("_")))
    },
    children: []
  };
  let codeNode = {
    type: "element",
    tagName: "code",
    properties: {},
    children: lines
  };
  const lineNodes = [];
  const context = {
    ...transformerContext,
    get tokens() {
      return tokens;
    },
    get options() {
      return options;
    },
    get root() {
      return tree;
    },
    get pre() {
      return preNode;
    },
    get code() {
      return codeNode;
    },
    get lines() {
      return lineNodes;
    }
  };
  tokens.forEach((line, idx) => {
    var _a2, _b2;
    if (idx)
      lines.push({ type: "text", value: "\n" });
    let lineNode = {
      type: "element",
      tagName: "span",
      properties: { class: "line" },
      children: []
    };
    let col = 0;
    for (const token of line) {
      let tokenNode = {
        type: "element",
        tagName: "span",
        properties: {},
        children: [{ type: "text", value: token.content }]
      };
      const style = token.htmlStyle || stringifyTokenStyle(getTokenStyleObject(token));
      if (style)
        tokenNode.properties.style = style;
      for (const transformer of transformers)
        tokenNode = ((_a2 = transformer == null ? void 0 : transformer.token) == null ? void 0 : _a2.call(context, tokenNode, idx + 1, col, lineNode)) || tokenNode;
      lineNode.children.push(tokenNode);
      col += token.content.length;
    }
    for (const transformer of transformers)
      lineNode = ((_b2 = transformer == null ? void 0 : transformer.line) == null ? void 0 : _b2.call(context, lineNode, idx + 1)) || lineNode;
    lineNodes.push(lineNode);
    lines.push(lineNode);
  });
  for (const transformer of transformers)
    codeNode = ((_a = transformer == null ? void 0 : transformer.code) == null ? void 0 : _a.call(context, codeNode)) || codeNode;
  preNode.children.push(codeNode);
  for (const transformer of transformers)
    preNode = ((_b = transformer == null ? void 0 : transformer.pre) == null ? void 0 : _b.call(context, preNode)) || preNode;
  tree.children.push(preNode);
  let result = tree;
  for (const transformer of transformers)
    result = ((_c = transformer == null ? void 0 : transformer.root) == null ? void 0 : _c.call(context, result)) || result;
  return result;
}
function getTokenStyleObject(token) {
  const styles = {};
  if (token.color)
    styles.color = token.color;
  if (token.fontStyle) {
    if (token.fontStyle & FontStyle.Italic)
      styles["font-style"] = "italic";
    if (token.fontStyle & FontStyle.Bold)
      styles["font-weight"] = "bold";
    if (token.fontStyle & FontStyle.Underline)
      styles["text-decoration"] = "underline";
  }
  return styles;
}
function stringifyTokenStyle(token) {
  return Object.entries(token).map(([key2, value]) => `${key2}:${value}`).join(";");
}
function mergeWhitespaceTokens(tokens) {
  return tokens.map((line) => {
    const newLine = [];
    let carryOnContent = "";
    line.forEach((token, idx) => {
      const isUnderline = token.fontStyle && token.fontStyle & FontStyle.Underline;
      const couldMerge = !isUnderline;
      if (couldMerge && token.content.match(/^\s+$/) && line[idx + 1]) {
        carryOnContent += token.content;
      } else {
        if (carryOnContent) {
          if (couldMerge) {
            newLine.push({
              ...token,
              content: carryOnContent + token.content
            });
          } else {
            newLine.push({
              content: carryOnContent
            }, token);
          }
          carryOnContent = "";
        } else {
          newLine.push(token);
        }
      }
    });
    return newLine;
  });
}
function splitWhitespaceTokens(tokens) {
  return tokens.map((line) => {
    return line.flatMap((token) => {
      if (token.content.match(/^\s+$/))
        return token;
      const match = token.content.match(/^(\s*)(.*?)(\s*)$/);
      if (!match)
        return token;
      const [, leading, content, trailing] = match;
      if (!leading && !trailing)
        return token;
      const expanded = [{
        ...token,
        content
      }];
      if (leading)
        expanded.unshift({ content: leading });
      if (trailing)
        expanded.push({ content: trailing });
      return expanded;
    });
  });
}
function codeToHtml(internal, code, options) {
  var _a;
  const context = {
    meta: {},
    options,
    codeToHast: (_code, _options) => codeToHast(internal, _code, _options)
  };
  let result = toHtml(codeToHast(internal, code, options, context));
  for (const transformer of options.transformers || [])
    result = ((_a = transformer.postprocess) == null ? void 0 : _a.call(context, result, options)) || result;
  return result;
}
async function main(init) {
  let wasmMemory;
  let buffer;
  const binding = {};
  function updateGlobalBufferAndViews(buf) {
    buffer = buf;
    binding.HEAPU8 = new Uint8Array(buf);
    binding.HEAPU32 = new Uint32Array(buf);
  }
  function _emscripten_get_now() {
    return typeof performance !== "undefined" ? performance.now() : Date.now();
  }
  function _emscripten_memcpy_big(dest, src, num) {
    binding.HEAPU8.copyWithin(dest, src, src + num);
  }
  function getHeapMax() {
    return 2147483648;
  }
  function emscripten_realloc_buffer(size) {
    try {
      wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
      updateGlobalBufferAndViews(wasmMemory.buffer);
      return 1;
    } catch (e) {
    }
  }
  function _emscripten_resize_heap(requestedSize) {
    const oldSize = binding.HEAPU8.length;
    requestedSize = requestedSize >>> 0;
    const maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize)
      return false;
    const alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
    for (let cutDown = 1; cutDown <= 4; cutDown *= 2) {
      let overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
      const newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
      const replacement = emscripten_realloc_buffer(newSize);
      if (replacement)
        return true;
    }
    return false;
  }
  const asmLibraryArg = {
    emscripten_get_now: _emscripten_get_now,
    emscripten_memcpy_big: _emscripten_memcpy_big,
    emscripten_resize_heap: _emscripten_resize_heap,
    fd_write: () => 0
  };
  async function createWasm() {
    const info = {
      env: asmLibraryArg,
      wasi_snapshot_preview1: asmLibraryArg
    };
    const exports = await init(info);
    wasmMemory = exports.memory;
    updateGlobalBufferAndViews(wasmMemory.buffer);
    Object.assign(binding, exports);
  }
  await createWasm();
  return binding;
}
var onigBinding = null;
var defaultDebugCall = false;
function throwLastOnigError(onigBinding2) {
  throw new Error(onigBinding2.UTF8ToString(onigBinding2.getLastOnigError()));
}
var UtfString = class _UtfString {
  constructor(str) {
    __publicField(this, "utf16Length");
    __publicField(this, "utf8Length");
    __publicField(this, "utf16Value");
    __publicField(this, "utf8Value");
    __publicField(this, "utf16OffsetToUtf8");
    __publicField(this, "utf8OffsetToUtf16");
    const utf16Length = str.length;
    const utf8Length = _UtfString._utf8ByteLength(str);
    const computeIndicesMapping = utf8Length !== utf16Length;
    const utf16OffsetToUtf8 = computeIndicesMapping ? new Uint32Array(utf16Length + 1) : null;
    if (computeIndicesMapping)
      utf16OffsetToUtf8[utf16Length] = utf8Length;
    const utf8OffsetToUtf16 = computeIndicesMapping ? new Uint32Array(utf8Length + 1) : null;
    if (computeIndicesMapping)
      utf8OffsetToUtf16[utf8Length] = utf16Length;
    const utf8Value = new Uint8Array(utf8Length);
    let i8 = 0;
    for (let i16 = 0; i16 < utf16Length; i16++) {
      const charCode = str.charCodeAt(i16);
      let codePoint = charCode;
      let wasSurrogatePair = false;
      if (charCode >= 55296 && charCode <= 56319) {
        if (i16 + 1 < utf16Length) {
          const nextCharCode = str.charCodeAt(i16 + 1);
          if (nextCharCode >= 56320 && nextCharCode <= 57343) {
            codePoint = (charCode - 55296 << 10) + 65536 | nextCharCode - 56320;
            wasSurrogatePair = true;
          }
        }
      }
      if (computeIndicesMapping) {
        utf16OffsetToUtf8[i16] = i8;
        if (wasSurrogatePair)
          utf16OffsetToUtf8[i16 + 1] = i8;
        if (codePoint <= 127) {
          utf8OffsetToUtf16[i8 + 0] = i16;
        } else if (codePoint <= 2047) {
          utf8OffsetToUtf16[i8 + 0] = i16;
          utf8OffsetToUtf16[i8 + 1] = i16;
        } else if (codePoint <= 65535) {
          utf8OffsetToUtf16[i8 + 0] = i16;
          utf8OffsetToUtf16[i8 + 1] = i16;
          utf8OffsetToUtf16[i8 + 2] = i16;
        } else {
          utf8OffsetToUtf16[i8 + 0] = i16;
          utf8OffsetToUtf16[i8 + 1] = i16;
          utf8OffsetToUtf16[i8 + 2] = i16;
          utf8OffsetToUtf16[i8 + 3] = i16;
        }
      }
      if (codePoint <= 127) {
        utf8Value[i8++] = codePoint;
      } else if (codePoint <= 2047) {
        utf8Value[i8++] = 192 | (codePoint & 1984) >>> 6;
        utf8Value[i8++] = 128 | (codePoint & 63) >>> 0;
      } else if (codePoint <= 65535) {
        utf8Value[i8++] = 224 | (codePoint & 61440) >>> 12;
        utf8Value[i8++] = 128 | (codePoint & 4032) >>> 6;
        utf8Value[i8++] = 128 | (codePoint & 63) >>> 0;
      } else {
        utf8Value[i8++] = 240 | (codePoint & 1835008) >>> 18;
        utf8Value[i8++] = 128 | (codePoint & 258048) >>> 12;
        utf8Value[i8++] = 128 | (codePoint & 4032) >>> 6;
        utf8Value[i8++] = 128 | (codePoint & 63) >>> 0;
      }
      if (wasSurrogatePair)
        i16++;
    }
    this.utf16Length = utf16Length;
    this.utf8Length = utf8Length;
    this.utf16Value = str;
    this.utf8Value = utf8Value;
    this.utf16OffsetToUtf8 = utf16OffsetToUtf8;
    this.utf8OffsetToUtf16 = utf8OffsetToUtf16;
  }
  static _utf8ByteLength(str) {
    let result = 0;
    for (let i = 0, len = str.length; i < len; i++) {
      const charCode = str.charCodeAt(i);
      let codepoint = charCode;
      let wasSurrogatePair = false;
      if (charCode >= 55296 && charCode <= 56319) {
        if (i + 1 < len) {
          const nextCharCode = str.charCodeAt(i + 1);
          if (nextCharCode >= 56320 && nextCharCode <= 57343) {
            codepoint = (charCode - 55296 << 10) + 65536 | nextCharCode - 56320;
            wasSurrogatePair = true;
          }
        }
      }
      if (codepoint <= 127)
        result += 1;
      else if (codepoint <= 2047)
        result += 2;
      else if (codepoint <= 65535)
        result += 3;
      else
        result += 4;
      if (wasSurrogatePair)
        i++;
    }
    return result;
  }
  createString(onigBinding2) {
    const result = onigBinding2.omalloc(this.utf8Length);
    onigBinding2.HEAPU8.set(this.utf8Value, result);
    return result;
  }
};
var _OnigString = class _OnigString {
  constructor(str) {
    __publicField(this, "id", ++_OnigString.LAST_ID);
    __publicField(this, "_onigBinding");
    __publicField(this, "content");
    __publicField(this, "utf16Length");
    __publicField(this, "utf8Length");
    __publicField(this, "utf16OffsetToUtf8");
    __publicField(this, "utf8OffsetToUtf16");
    __publicField(this, "ptr");
    if (!onigBinding)
      throw new Error("Must invoke loadWasm first.");
    this._onigBinding = onigBinding;
    this.content = str;
    const utfString = new UtfString(str);
    this.utf16Length = utfString.utf16Length;
    this.utf8Length = utfString.utf8Length;
    this.utf16OffsetToUtf8 = utfString.utf16OffsetToUtf8;
    this.utf8OffsetToUtf16 = utfString.utf8OffsetToUtf16;
    if (this.utf8Length < 1e4 && !_OnigString._sharedPtrInUse) {
      if (!_OnigString._sharedPtr)
        _OnigString._sharedPtr = onigBinding.omalloc(1e4);
      _OnigString._sharedPtrInUse = true;
      onigBinding.HEAPU8.set(utfString.utf8Value, _OnigString._sharedPtr);
      this.ptr = _OnigString._sharedPtr;
    } else {
      this.ptr = utfString.createString(onigBinding);
    }
  }
  convertUtf8OffsetToUtf16(utf8Offset) {
    if (this.utf8OffsetToUtf16) {
      if (utf8Offset < 0)
        return 0;
      if (utf8Offset > this.utf8Length)
        return this.utf16Length;
      return this.utf8OffsetToUtf16[utf8Offset];
    }
    return utf8Offset;
  }
  convertUtf16OffsetToUtf8(utf16Offset) {
    if (this.utf16OffsetToUtf8) {
      if (utf16Offset < 0)
        return 0;
      if (utf16Offset > this.utf16Length)
        return this.utf8Length;
      return this.utf16OffsetToUtf8[utf16Offset];
    }
    return utf16Offset;
  }
  dispose() {
    if (this.ptr === _OnigString._sharedPtr)
      _OnigString._sharedPtrInUse = false;
    else
      this._onigBinding.ofree(this.ptr);
  }
};
__publicField(_OnigString, "LAST_ID", 0);
__publicField(_OnigString, "_sharedPtr", 0);
// a pointer to a string of 10000 bytes
__publicField(_OnigString, "_sharedPtrInUse", false);
var OnigString = _OnigString;
var OnigScanner = class {
  constructor(patterns) {
    __publicField(this, "_onigBinding");
    __publicField(this, "_ptr");
    if (!onigBinding)
      throw new Error("Must invoke loadWasm first.");
    const strPtrsArr = [];
    const strLenArr = [];
    for (let i = 0, len = patterns.length; i < len; i++) {
      const utfString = new UtfString(patterns[i]);
      strPtrsArr[i] = utfString.createString(onigBinding);
      strLenArr[i] = utfString.utf8Length;
    }
    const strPtrsPtr = onigBinding.omalloc(4 * patterns.length);
    onigBinding.HEAPU32.set(strPtrsArr, strPtrsPtr / 4);
    const strLenPtr = onigBinding.omalloc(4 * patterns.length);
    onigBinding.HEAPU32.set(strLenArr, strLenPtr / 4);
    const scannerPtr = onigBinding.createOnigScanner(strPtrsPtr, strLenPtr, patterns.length);
    for (let i = 0, len = patterns.length; i < len; i++)
      onigBinding.ofree(strPtrsArr[i]);
    onigBinding.ofree(strLenPtr);
    onigBinding.ofree(strPtrsPtr);
    if (scannerPtr === 0)
      throwLastOnigError(onigBinding);
    this._onigBinding = onigBinding;
    this._ptr = scannerPtr;
  }
  dispose() {
    this._onigBinding.freeOnigScanner(this._ptr);
  }
  findNextMatchSync(string, startPosition, arg) {
    let debugCall = defaultDebugCall;
    let options = 0;
    if (typeof arg === "number") {
      if (arg & 8)
        debugCall = true;
      options = arg;
    } else if (typeof arg === "boolean") {
      debugCall = arg;
    }
    if (typeof string === "string") {
      string = new OnigString(string);
      const result = this._findNextMatchSync(string, startPosition, debugCall, options);
      string.dispose();
      return result;
    }
    return this._findNextMatchSync(string, startPosition, debugCall, options);
  }
  _findNextMatchSync(string, startPosition, debugCall, options) {
    const onigBinding2 = this._onigBinding;
    let resultPtr;
    if (debugCall)
      resultPtr = onigBinding2.findNextOnigScannerMatchDbg(this._ptr, string.id, string.ptr, string.utf8Length, string.convertUtf16OffsetToUtf8(startPosition), options);
    else
      resultPtr = onigBinding2.findNextOnigScannerMatch(this._ptr, string.id, string.ptr, string.utf8Length, string.convertUtf16OffsetToUtf8(startPosition), options);
    if (resultPtr === 0) {
      return null;
    }
    const HEAPU32 = onigBinding2.HEAPU32;
    let offset = resultPtr / 4;
    const index = HEAPU32[offset++];
    const count = HEAPU32[offset++];
    const captureIndices = [];
    for (let i = 0; i < count; i++) {
      const beg = string.convertUtf8OffsetToUtf16(HEAPU32[offset++]);
      const end = string.convertUtf8OffsetToUtf16(HEAPU32[offset++]);
      captureIndices[i] = {
        start: beg,
        end,
        length: end - beg
      };
    }
    return {
      index,
      captureIndices
    };
  }
};
function isInstantiatorOptionsObject(dataOrOptions) {
  return typeof dataOrOptions.instantiator === "function";
}
function isInstantiatorModule(dataOrOptions) {
  return typeof dataOrOptions.default === "function";
}
function isDataOptionsObject(dataOrOptions) {
  return typeof dataOrOptions.data !== "undefined";
}
function isResponse(dataOrOptions) {
  return typeof Response !== "undefined" && dataOrOptions instanceof Response;
}
function isArrayBuffer(data) {
  return typeof ArrayBuffer !== "undefined" && (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) || typeof Buffer !== "undefined" && Buffer.isBuffer(data) || typeof SharedArrayBuffer !== "undefined" && data instanceof SharedArrayBuffer || typeof Uint32Array !== "undefined" && data instanceof Uint32Array;
}
var initPromise;
function loadWasm(options) {
  if (initPromise)
    return initPromise;
  async function _load() {
    onigBinding = await main(async (info) => {
      let instance = options;
      if (typeof instance === "function")
        instance = await instance(info);
      if (typeof instance === "function")
        instance = await instance(info);
      if (isInstantiatorOptionsObject(instance)) {
        instance = await instance.instantiator(info);
      } else if (isInstantiatorModule(instance)) {
        instance = await instance.default(info);
      } else {
        if (isDataOptionsObject(instance))
          instance = instance.data;
        if (isResponse(instance)) {
          if (typeof WebAssembly.instantiateStreaming === "function")
            instance = await _makeResponseStreamingLoader(instance)(info);
          else
            instance = await _makeResponseNonStreamingLoader(instance)(info);
        } else if (isArrayBuffer(instance)) {
          instance = await _makeArrayBufferLoader(instance)(info);
        }
      }
      if ("instance" in instance)
        instance = instance.instance;
      if ("exports" in instance)
        instance = instance.exports;
      return instance;
    });
  }
  initPromise = _load();
  return initPromise;
}
function _makeArrayBufferLoader(data) {
  return (importObject) => WebAssembly.instantiate(data, importObject);
}
function _makeResponseStreamingLoader(data) {
  return (importObject) => WebAssembly.instantiateStreaming(data, importObject);
}
function _makeResponseNonStreamingLoader(data) {
  return async (importObject) => {
    const arrayBuffer = await data.arrayBuffer();
    return WebAssembly.instantiate(arrayBuffer, importObject);
  };
}
function createOnigString(str) {
  return new OnigString(str);
}
function createOnigScanner(patterns) {
  return new OnigScanner(patterns);
}
var VSCODE_FALLBACK_EDITOR_FG = { light: "#333333", dark: "#bbbbbb" };
var VSCODE_FALLBACK_EDITOR_BG = { light: "#fffffe", dark: "#1e1e1e" };
var RESOLVED_KEY = "__shiki_resolved";
function normalizeTheme(rawTheme) {
  var _a, _b, _c, _d, _e;
  if (rawTheme == null ? void 0 : rawTheme[RESOLVED_KEY])
    return rawTheme;
  const theme = {
    ...rawTheme
  };
  if (theme.tokenColors && !theme.settings) {
    theme.settings = theme.tokenColors;
    delete theme.tokenColors;
  }
  theme.type || (theme.type = "dark");
  theme.colorReplacements = { ...theme.colorReplacements };
  theme.settings || (theme.settings = []);
  let { bg, fg } = theme;
  if (!bg || !fg) {
    const globalSetting = theme.settings ? theme.settings.find((s) => !s.name && !s.scope) : void 0;
    if ((_a = globalSetting == null ? void 0 : globalSetting.settings) == null ? void 0 : _a.foreground)
      fg = globalSetting.settings.foreground;
    if ((_b = globalSetting == null ? void 0 : globalSetting.settings) == null ? void 0 : _b.background)
      bg = globalSetting.settings.background;
    if (!fg && ((_c = theme == null ? void 0 : theme.colors) == null ? void 0 : _c["editor.foreground"]))
      fg = theme.colors["editor.foreground"];
    if (!bg && ((_d = theme == null ? void 0 : theme.colors) == null ? void 0 : _d["editor.background"]))
      bg = theme.colors["editor.background"];
    if (!fg)
      fg = theme.type === "light" ? VSCODE_FALLBACK_EDITOR_FG.light : VSCODE_FALLBACK_EDITOR_FG.dark;
    if (!bg)
      bg = theme.type === "light" ? VSCODE_FALLBACK_EDITOR_BG.light : VSCODE_FALLBACK_EDITOR_BG.dark;
    theme.fg = fg;
    theme.bg = bg;
  }
  if (!(theme.settings[0] && theme.settings[0].settings && !theme.settings[0].scope)) {
    theme.settings.unshift({
      settings: {
        foreground: theme.fg,
        background: theme.bg
      }
    });
  }
  let replacementCount = 0;
  const replacementMap = /* @__PURE__ */ new Map();
  function getReplacementColor(value) {
    var _a2;
    if (replacementMap.has(value))
      return replacementMap.get(value);
    replacementCount += 1;
    const hex = `#${replacementCount.toString(16).padStart(8, "0").toLowerCase()}`;
    if ((_a2 = theme.colorReplacements) == null ? void 0 : _a2[`#${hex}`])
      return getReplacementColor(value);
    replacementMap.set(value, hex);
    return hex;
  }
  theme.settings = theme.settings.map((setting) => {
    var _a2, _b2;
    const replaceFg = ((_a2 = setting.settings) == null ? void 0 : _a2.foreground) && !setting.settings.foreground.startsWith("#");
    const replaceBg = ((_b2 = setting.settings) == null ? void 0 : _b2.background) && !setting.settings.background.startsWith("#");
    if (!replaceFg && !replaceBg)
      return setting;
    const clone2 = {
      ...setting,
      settings: {
        ...setting.settings
      }
    };
    if (replaceFg) {
      const replacement = getReplacementColor(setting.settings.foreground);
      theme.colorReplacements[replacement] = setting.settings.foreground;
      clone2.settings.foreground = replacement;
    }
    if (replaceBg) {
      const replacement = getReplacementColor(setting.settings.background);
      theme.colorReplacements[replacement] = setting.settings.background;
      clone2.settings.background = replacement;
    }
    return clone2;
  });
  for (const key2 of Object.keys(theme.colors || {})) {
    if (key2 === "editor.foreground" || key2 === "editor.background" || key2.startsWith("terminal.ansi")) {
      if (!((_e = theme.colors[key2]) == null ? void 0 : _e.startsWith("#"))) {
        const replacement = getReplacementColor(theme.colors[key2]);
        theme.colorReplacements[replacement] = theme.colors[key2];
        theme.colors[key2] = replacement;
      }
    }
  }
  Object.defineProperty(theme, RESOLVED_KEY, {
    enumerable: false,
    writable: false,
    value: true
  });
  return theme;
}
var Registry2 = class extends Registry$1 {
  constructor(_resolver, _themes, _langs) {
    super(_resolver);
    __publicField(this, "_resolver");
    __publicField(this, "_themes");
    __publicField(this, "_langs");
    __publicField(this, "_resolvedThemes", {});
    __publicField(this, "_resolvedGrammars", {});
    __publicField(this, "_langMap", {});
    __publicField(this, "_langGraph", /* @__PURE__ */ new Map());
    __publicField(this, "alias", {});
    this._resolver = _resolver;
    this._themes = _themes;
    this._langs = _langs;
    _themes.forEach((t) => this.loadTheme(t));
    _langs.forEach((l) => this.loadLanguage(l));
  }
  getTheme(theme) {
    if (typeof theme === "string")
      return this._resolvedThemes[theme];
    else
      return this.loadTheme(theme);
  }
  loadTheme(theme) {
    const _theme = normalizeTheme(theme);
    if (_theme.name)
      this._resolvedThemes[_theme.name] = _theme;
    return _theme;
  }
  getLoadedThemes() {
    return Object.keys(this._resolvedThemes);
  }
  getGrammar(name) {
    if (this.alias[name]) {
      const resolved = /* @__PURE__ */ new Set([name]);
      while (this.alias[name]) {
        name = this.alias[name];
        if (resolved.has(name))
          throw new Error(`[shikiji] Circular alias \`${Array.from(resolved).join(" -> ")} -> ${name}\``);
        resolved.add(name);
      }
    }
    return this._resolvedGrammars[name];
  }
  async loadLanguage(lang2) {
    var _a, _b, _c, _d;
    if (this.getGrammar(lang2.name))
      return;
    const embeddedLazilyBy = new Set(Object.values(this._langMap).filter((i) => {
      var _a2;
      return (_a2 = i.embeddedLangsLazy) == null ? void 0 : _a2.includes(lang2.name);
    }));
    this._resolver.addLanguage(lang2);
    const grammarConfig = {
      balancedBracketSelectors: lang2.balancedBracketSelectors || ["*"],
      unbalancedBracketSelectors: lang2.unbalancedBracketSelectors || []
    };
    this._syncRegistry._rawGrammars.set(lang2.scopeName, lang2);
    const g = await this.loadGrammarWithConfiguration(lang2.scopeName, 1, grammarConfig);
    this._resolvedGrammars[lang2.name] = g;
    if (lang2.aliases) {
      lang2.aliases.forEach((alias) => {
        this.alias[alias] = lang2.name;
      });
    }
    if (embeddedLazilyBy.size) {
      for (const e of embeddedLazilyBy) {
        delete this._resolvedGrammars[e.name];
        (_b = (_a = this._syncRegistry) == null ? void 0 : _a._injectionGrammars) == null ? void 0 : _b.delete(e.scopeName);
        (_d = (_c = this._syncRegistry) == null ? void 0 : _c._grammars) == null ? void 0 : _d.delete(e.scopeName);
        await this.loadLanguage(this._langMap[e.name]);
      }
    }
  }
  async init() {
    this._themes.map((t) => this.loadTheme(t));
    await this.loadLanguages(this._langs);
  }
  async loadLanguages(langs) {
    for (const lang2 of langs)
      this.resolveEmbeddedLanguages(lang2);
    const langsGraphArray = Array.from(this._langGraph.entries());
    const missingLangs = langsGraphArray.filter(([_, lang2]) => !lang2);
    if (missingLangs.length) {
      const dependents = langsGraphArray.filter(([_, lang2]) => {
        var _a;
        return lang2 && ((_a = lang2.embeddedLangs) == null ? void 0 : _a.some((l) => missingLangs.map(([name]) => name).includes(l)));
      }).filter((lang2) => !missingLangs.includes(lang2));
      throw new Error(`[shikiji] Missing languages ${missingLangs.map(([name]) => `\`${name}\``).join(", ")}, required by ${dependents.map(([name]) => `\`${name}\``).join(", ")}`);
    }
    for (const [_, lang2] of langsGraphArray)
      this._resolver.addLanguage(lang2);
    for (const [_, lang2] of langsGraphArray)
      await this.loadLanguage(lang2);
  }
  getLoadedLanguages() {
    return Object.keys({ ...this._resolvedGrammars, ...this.alias });
  }
  resolveEmbeddedLanguages(lang2) {
    this._langMap[lang2.name] = lang2;
    this._langGraph.set(lang2.name, lang2);
    if (lang2.embeddedLangs) {
      for (const embeddedLang of lang2.embeddedLangs)
        this._langGraph.set(embeddedLang, this._langMap[embeddedLang]);
    }
  }
};
var Resolver = class {
  constructor(onigLibPromise, langs) {
    __publicField(this, "_langs", /* @__PURE__ */ new Map());
    __publicField(this, "_scopeToLang", /* @__PURE__ */ new Map());
    __publicField(this, "_injections", /* @__PURE__ */ new Map());
    __publicField(this, "_onigLibPromise");
    this._onigLibPromise = onigLibPromise;
    langs.forEach((i) => this.addLanguage(i));
  }
  get onigLib() {
    return this._onigLibPromise;
  }
  getLangRegistration(langIdOrAlias) {
    return this._langs.get(langIdOrAlias);
  }
  async loadGrammar(scopeName) {
    return this._scopeToLang.get(scopeName);
  }
  addLanguage(l) {
    this._langs.set(l.name, l);
    if (l.aliases) {
      l.aliases.forEach((a) => {
        this._langs.set(a, l);
      });
    }
    this._scopeToLang.set(l.scopeName, l);
    if (l.injectTo) {
      l.injectTo.forEach((i) => {
        if (!this._injections.get(i))
          this._injections.set(i, []);
        this._injections.get(i).push(l.scopeName);
      });
    }
  }
  getInjections(scopeName) {
    const scopeParts = scopeName.split(".");
    let injections = [];
    for (let i = 1; i <= scopeParts.length; i++) {
      const subScopeName = scopeParts.slice(0, i).join(".");
      injections = [...injections, ...this._injections.get(subScopeName) || []];
    }
    return injections;
  }
};
async function getShikiInternal(options = {}) {
  async function normalizeGetter(p2) {
    return Promise.resolve(typeof p2 === "function" ? p2() : p2).then((r) => r.default || r);
  }
  async function resolveLangs(langs2) {
    return Array.from(new Set((await Promise.all(langs2.map(async (lang2) => await normalizeGetter(lang2).then((r) => Array.isArray(r) ? r : [r])))).flat()));
  }
  const [themes, langs] = await Promise.all([
    Promise.all((options.themes || []).map(normalizeGetter)).then((r) => r.map(normalizeTheme)),
    resolveLangs(options.langs || []),
    options.loadWasm ? loadWasm(options.loadWasm) : void 0
  ]);
  const resolver = new Resolver(Promise.resolve({
    createOnigScanner(patterns) {
      return createOnigScanner(patterns);
    },
    createOnigString(s) {
      return createOnigString(s);
    }
  }), langs);
  const _registry = new Registry2(resolver, themes, langs);
  Object.assign(_registry.alias, options.langAlias);
  await _registry.init();
  let _lastTheme;
  function getLangGrammar(name) {
    const _lang = _registry.getGrammar(name);
    if (!_lang)
      throw new Error(`[shikiji] Language \`${name}\` not found, you may need to load it first`);
    return _lang;
  }
  function getTheme(name) {
    const _theme = _registry.getTheme(name);
    if (!_theme)
      throw new Error(`[shikiji] Theme \`${name}\` not found, you may need to load it first`);
    return _theme;
  }
  function setTheme(name) {
    const theme = getTheme(name);
    if (_lastTheme !== name) {
      _registry.setTheme(theme);
      _lastTheme = name;
    }
    const colorMap = _registry.getColorMap();
    return {
      theme,
      colorMap
    };
  }
  function getLoadedThemes() {
    return _registry.getLoadedThemes();
  }
  function getLoadedLanguages() {
    return _registry.getLoadedLanguages();
  }
  async function loadLanguage(...langs2) {
    await _registry.loadLanguages(await resolveLangs(langs2));
  }
  async function loadTheme(...themes2) {
    await Promise.all(themes2.map(async (theme) => _registry.loadTheme(await normalizeGetter(theme))));
  }
  function updateAlias(alias) {
    Object.assign(_registry.alias, alias);
  }
  function getAlias() {
    return _registry.alias;
  }
  return {
    setTheme,
    getTheme,
    getLangGrammar,
    getLoadedThemes,
    getLoadedLanguages,
    getAlias,
    updateAlias,
    loadLanguage,
    loadTheme
  };
}
async function getHighlighterCore(options = {}) {
  const internal = await getShikiInternal(options);
  return {
    codeToThemedTokens: (code, options2) => codeToThemedTokens(internal, code, options2),
    codeToTokensWithThemes: (code, options2) => codeToTokensWithThemes(internal, code, options2),
    codeToHast: (code, options2) => codeToHast(internal, code, options2),
    codeToHtml: (code, options2) => codeToHtml(internal, code, options2),
    loadLanguage: internal.loadLanguage,
    loadTheme: internal.loadTheme,
    getTheme: internal.getTheme,
    getLangGrammar: internal.getLangGrammar,
    setTheme: internal.setTheme,
    getLoadedThemes: internal.getLoadedThemes,
    getLoadedLanguages: internal.getLoadedLanguages,
    getInternalContext: () => internal
  };
}
var _onigurumaPromise = null;
async function getWasmInlined() {
  if (!_onigurumaPromise) {
    _onigurumaPromise = import("./onig-4quf_T-L-7ODC2EJJ.js").then((r) => ({ data: r.default }));
  }
  return _onigurumaPromise;
}
function textmateThemeToMonacoTheme(theme) {
  let rules = "rules" in theme ? theme.rules : void 0;
  if (!rules) {
    rules = [];
    const themeSettings = theme.settings || theme.tokenColors;
    for (const { scope, settings } of themeSettings) {
      const scopes = Array.isArray(scope) ? scope : [scope];
      for (const s of scopes) {
        if (settings.foreground && s) {
          rules.push({
            token: s,
            foreground: settings.foreground.replace("#", "")
          });
        }
      }
    }
  }
  return {
    base: theme.type === "light" ? "vs" : "vs-dark",
    inherit: false,
    colors: theme.colors || {},
    rules
  };
}
function shikijiToMonaco(highlighter, monaco2) {
  const themeMap = /* @__PURE__ */ new Map();
  const themeIds = highlighter.getLoadedThemes();
  for (const themeId of themeIds) {
    const tmTheme = highlighter.getTheme(themeId);
    const monacoTheme = textmateThemeToMonacoTheme(tmTheme);
    themeMap.set(themeId, monacoTheme);
    monaco2.editor.defineTheme(themeId, monacoTheme);
  }
  let currentTheme = themeIds[0];
  const _setTheme = monaco2.editor.setTheme.bind(monaco2.editor);
  monaco2.editor.setTheme = (theme) => {
    _setTheme(theme);
    currentTheme = theme;
  };
  for (const lang2 of highlighter.getLoadedLanguages()) {
    if (monaco2.languages.getLanguages().some((l) => l.id === lang2)) {
      monaco2.languages.setTokensProvider(lang2, {
        getInitialState() {
          return new TokenizerState(INITIAL, highlighter);
        },
        tokenize(line, state) {
          const grammar = state.highlighter.getLangGrammar(lang2);
          const { colorMap } = state.highlighter.setTheme(currentTheme);
          const theme = themeMap.get(currentTheme);
          const result = grammar.tokenizeLine2(line, state.ruleStack);
          const colorToScopeMap = /* @__PURE__ */ new Map();
          theme.rules.forEach((rule) => {
            var _a;
            const c = (_a = rule.foreground) == null ? void 0 : _a.replace("#", "").toLowerCase();
            if (c && !colorToScopeMap.has(c))
              colorToScopeMap.set(c, rule.token);
          });
          function findScopeByColor(color) {
            return colorToScopeMap.get(color);
          }
          const tokensLength = result.tokens.length / 2;
          const tokens = [];
          for (let j = 0; j < tokensLength; j++) {
            const startIndex = result.tokens[2 * j];
            const metadata = result.tokens[2 * j + 1];
            const color = (colorMap[StackElementMetadata.getForeground(metadata)] || "").replace("#", "").toLowerCase();
            const scope = findScopeByColor(color) || "";
            tokens.push({
              startIndex,
              scopes: scope
            });
          }
          return {
            endState: new TokenizerState(result.ruleStack, state.highlighter),
            tokens
          };
        }
      });
    }
  }
}
var TokenizerState = class _TokenizerState {
  constructor(_ruleStack, highlighter) {
    this._ruleStack = _ruleStack;
    this.highlighter = highlighter;
  }
  get ruleStack() {
    return this._ruleStack;
  }
  clone() {
    return new _TokenizerState(this._ruleStack, this.highlighter);
  }
  equals(other) {
    if (!other || !(other instanceof _TokenizerState) || other !== this || other._ruleStack !== this._ruleStack)
      return false;
    return true;
  }
};
var lang$n = Object.freeze({ "displayName": "JavaScript", "name": "javascript", "patterns": [{ "include": "#directives" }, { "include": "#statements" }, { "include": "#shebang" }], "repository": { "access-modifier": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(abstract|declare|override|public|protected|private|readonly|static)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "storage.modifier.js" }, "after-operator-block-as-object-literal": { "begin": "(?<!\\+\\+|--)(?<=[:=(,\\[?+!>]|^await|[^\\._$[:alnum:]]await|^return|[^\\._$[:alnum:]]return|^yield|[^\\._$[:alnum:]]yield|^throw|[^\\._$[:alnum:]]throw|^in|[^\\._$[:alnum:]]in|^of|[^\\._$[:alnum:]]of|^typeof|[^\\._$[:alnum:]]typeof|&&|\\|\\||\\*)\\s*(\\{)", "beginCaptures": { "1": { "name": "punctuation.definition.block.js" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.js" } }, "name": "meta.objectliteral.js", "patterns": [{ "include": "#object-member" }] }, "array-binding-pattern": { "begin": "(?:(\\.\\.\\.)\\s*)?(\\[)", "beginCaptures": { "1": { "name": "keyword.operator.rest.js" }, "2": { "name": "punctuation.definition.binding-pattern.array.js" } }, "end": "\\]", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.array.js" } }, "patterns": [{ "include": "#binding-element" }, { "include": "#punctuation-comma" }] }, "array-binding-pattern-const": { "begin": "(?:(\\.\\.\\.)\\s*)?(\\[)", "beginCaptures": { "1": { "name": "keyword.operator.rest.js" }, "2": { "name": "punctuation.definition.binding-pattern.array.js" } }, "end": "\\]", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.array.js" } }, "patterns": [{ "include": "#binding-element-const" }, { "include": "#punctuation-comma" }] }, "array-literal": { "begin": "\\s*(\\[)", "beginCaptures": { "1": { "name": "meta.brace.square.js" } }, "end": "\\]", "endCaptures": { "0": { "name": "meta.brace.square.js" } }, "name": "meta.array.literal.js", "patterns": [{ "include": "#expression" }, { "include": "#punctuation-comma" }] }, "arrow-function": { "patterns": [{ "captures": { "1": { "name": "storage.modifier.async.js" }, "2": { "name": "variable.parameter.js" } }, "match": "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(\\basync)\\s+)?([_$[:alpha:]][_$[:alnum:]]*)\\s*(?==>)", "name": "meta.arrow.js" }, { "begin": "(?x) (?:\n  (?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(\\basync)\n)? ((?<![})!\\]])\\s*\n  (?=\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  )\n)", "beginCaptures": { "1": { "name": "storage.modifier.async.js" } }, "end": "(?==>|\\{|(^\\s*(export|function|class|interface|let|var|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|const|import|enum|namespace|module|type|abstract|declare)\\s+))", "name": "meta.arrow.js", "patterns": [{ "include": "#comment" }, { "include": "#type-parameters" }, { "include": "#function-parameters" }, { "include": "#arrow-return-type" }, { "include": "#possibly-arrow-return-type" }] }, { "begin": "=>", "beginCaptures": { "0": { "name": "storage.type.function.arrow.js" } }, "end": "((?<=\\}|\\S)(?<!=>)|((?!\\{)(?=\\S)))(?!\\/[\\/\\*])", "name": "meta.arrow.js", "patterns": [{ "include": "#single-line-comment-consuming-line-ending" }, { "include": "#decl-block" }, { "include": "#expression" }] }] }, "arrow-return-type": { "begin": "(?<=\\))\\s*(:)", "beginCaptures": { "1": { "name": "keyword.operator.type.annotation.js" } }, "end": "(?==>|\\{|(^\\s*(export|function|class|interface|let|var|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|const|import|enum|namespace|module|type|abstract|declare)\\s+))", "name": "meta.return.type.arrow.js", "patterns": [{ "include": "#arrow-return-type-body" }] }, "arrow-return-type-body": { "patterns": [{ "begin": "(?<=[:])(?=\\s*\\{)", "end": "(?<=\\})", "patterns": [{ "include": "#type-object" }] }, { "include": "#type-predicate-operator" }, { "include": "#type" }] }, "async-modifier": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(async)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "storage.modifier.async.js" }, "binding-element": { "patterns": [{ "include": "#comment" }, { "include": "#string" }, { "include": "#numeric-literal" }, { "include": "#regex" }, { "include": "#object-binding-pattern" }, { "include": "#array-binding-pattern" }, { "include": "#destructuring-variable-rest" }, { "include": "#variable-initializer" }] }, "binding-element-const": { "patterns": [{ "include": "#comment" }, { "include": "#string" }, { "include": "#numeric-literal" }, { "include": "#regex" }, { "include": "#object-binding-pattern-const" }, { "include": "#array-binding-pattern-const" }, { "include": "#destructuring-variable-rest-const" }, { "include": "#variable-initializer" }] }, "boolean-literal": { "patterns": [{ "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))true(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "constant.language.boolean.true.js" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))false(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "constant.language.boolean.false.js" }] }, "brackets": { "patterns": [{ "begin": "{", "end": "}|(?=\\*/)", "patterns": [{ "include": "#brackets" }] }, { "begin": "\\[", "end": "\\]|(?=\\*/)", "patterns": [{ "include": "#brackets" }] }] }, "cast": { "patterns": [{ "include": "#jsx" }] }, "class-declaration": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(?:(abstract)\\s+)?\\b(class)\\b(?=\\s+|/[/*])", "beginCaptures": { "1": { "name": "keyword.control.export.js" }, "2": { "name": "storage.modifier.js" }, "3": { "name": "storage.modifier.js" }, "4": { "name": "storage.type.class.js" } }, "end": "(?<=\\})", "name": "meta.class.js", "patterns": [{ "include": "#class-declaration-or-expression-patterns" }] }, "class-declaration-or-expression-patterns": { "patterns": [{ "include": "#comment" }, { "include": "#class-or-interface-heritage" }, { "captures": { "0": { "name": "entity.name.type.class.js" } }, "match": "[_$[:alpha:]][_$[:alnum:]]*" }, { "include": "#type-parameters" }, { "include": "#class-or-interface-body" }] }, "class-expression": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(abstract)\\s+)?(class)\\b(?=\\s+|[<{]|\\/[\\/*])", "beginCaptures": { "1": { "name": "storage.modifier.js" }, "2": { "name": "storage.type.class.js" } }, "end": "(?<=\\})", "name": "meta.class.js", "patterns": [{ "include": "#class-declaration-or-expression-patterns" }] }, "class-or-interface-body": { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.block.js" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.js" } }, "patterns": [{ "include": "#comment" }, { "include": "#decorator" }, { "begin": "(?<=:)\\s*", "end": "(?=\\s|[;),}\\]:\\-\\+]|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "patterns": [{ "include": "#expression" }] }, { "include": "#method-declaration" }, { "include": "#indexer-declaration" }, { "include": "#field-declaration" }, { "include": "#string" }, { "include": "#type-annotation" }, { "include": "#variable-initializer" }, { "include": "#access-modifier" }, { "include": "#property-accessor" }, { "include": "#async-modifier" }, { "include": "#after-operator-block-as-object-literal" }, { "include": "#decl-block" }, { "include": "#expression" }, { "include": "#punctuation-comma" }, { "include": "#punctuation-semicolon" }] }, "class-or-interface-heritage": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(extends|implements)\\b)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "1": { "name": "storage.modifier.js" } }, "end": "(?=\\{)", "patterns": [{ "include": "#comment" }, { "include": "#class-or-interface-heritage" }, { "include": "#type-parameters" }, { "include": "#expressionWithoutIdentifiers" }, { "captures": { "1": { "name": "entity.name.type.module.js" }, "2": { "name": "punctuation.accessor.js" }, "3": { "name": "punctuation.accessor.optional.js" } }, "match": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))(?=\\s*[_$[:alpha:]][_$[:alnum:]]*(\\s*\\??\\.\\s*[_$[:alpha:]][_$[:alnum:]]*)*\\s*)" }, { "captures": { "1": { "name": "entity.other.inherited-class.js" } }, "match": "([_$[:alpha:]][_$[:alnum:]]*)" }, { "include": "#expressionPunctuations" }] }, "comment": { "patterns": [{ "begin": "/\\*\\*(?!/)", "beginCaptures": { "0": { "name": "punctuation.definition.comment.js" } }, "end": "\\*/", "endCaptures": { "0": { "name": "punctuation.definition.comment.js" } }, "name": "comment.block.documentation.js", "patterns": [{ "include": "#docblock" }] }, { "begin": "(/\\*)(?:\\s*((@)internal)(?=\\s|(\\*/)))?", "beginCaptures": { "1": { "name": "punctuation.definition.comment.js" }, "2": { "name": "storage.type.internaldeclaration.js" }, "3": { "name": "punctuation.decorator.internaldeclaration.js" } }, "end": "\\*/", "endCaptures": { "0": { "name": "punctuation.definition.comment.js" } }, "name": "comment.block.js" }, { "begin": "(^[ \\t]+)?((//)(?:\\s*((@)internal)(?=\\s|$))?)", "beginCaptures": { "1": { "name": "punctuation.whitespace.comment.leading.js" }, "2": { "name": "comment.line.double-slash.js" }, "3": { "name": "punctuation.definition.comment.js" }, "4": { "name": "storage.type.internaldeclaration.js" }, "5": { "name": "punctuation.decorator.internaldeclaration.js" } }, "contentName": "comment.line.double-slash.js", "end": "(?=$)" }] }, "control-statement": { "patterns": [{ "include": "#switch-statement" }, { "include": "#for-loop" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(catch|finally|throw|try)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.control.trycatch.js" }, { "captures": { "1": { "name": "keyword.control.loop.js" }, "2": { "name": "entity.name.label.js" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(break|continue|goto)\\s+([_$[:alpha:]][_$[:alnum:]]*)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(break|continue|do|goto|while)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.control.loop.js" }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(return)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "0": { "name": "keyword.control.flow.js" } }, "end": "(?=[;}]|$|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "patterns": [{ "include": "#expression" }] }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(case|default|switch)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.control.switch.js" }, { "include": "#if-statement" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(else|if)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.control.conditional.js" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(with)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.control.with.js" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(package)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.control.js" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(debugger)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.other.debugger.js" }] }, "decl-block": { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.block.js" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.js" } }, "name": "meta.block.js", "patterns": [{ "include": "#statements" }] }, "declaration": { "patterns": [{ "include": "#decorator" }, { "include": "#var-expr" }, { "include": "#function-declaration" }, { "include": "#class-declaration" }, { "include": "#interface-declaration" }, { "include": "#enum-declaration" }, { "include": "#namespace-declaration" }, { "include": "#type-alias-declaration" }, { "include": "#import-equals-declaration" }, { "include": "#import-declaration" }, { "include": "#export-declaration" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(declare|export)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "storage.modifier.js" }] }, "decorator": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))\\@", "beginCaptures": { "0": { "name": "punctuation.decorator.js" } }, "end": "(?=\\s)", "name": "meta.decorator.js", "patterns": [{ "include": "#expression" }] }, "destructuring-const": { "patterns": [{ "begin": "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\{)", "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))", "name": "meta.object-binding-pattern-variable.js", "patterns": [{ "include": "#object-binding-pattern-const" }, { "include": "#type-annotation" }, { "include": "#comment" }] }, { "begin": "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\[)", "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))", "name": "meta.array-binding-pattern-variable.js", "patterns": [{ "include": "#array-binding-pattern-const" }, { "include": "#type-annotation" }, { "include": "#comment" }] }] }, "destructuring-parameter": { "patterns": [{ "begin": "(?<!=|:)\\s*(?:(\\.\\.\\.)\\s*)?(\\{)", "beginCaptures": { "1": { "name": "keyword.operator.rest.js" }, "2": { "name": "punctuation.definition.binding-pattern.object.js" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.object.js" } }, "name": "meta.parameter.object-binding-pattern.js", "patterns": [{ "include": "#parameter-object-binding-element" }] }, { "begin": "(?<!=|:)\\s*(?:(\\.\\.\\.)\\s*)?(\\[)", "beginCaptures": { "1": { "name": "keyword.operator.rest.js" }, "2": { "name": "punctuation.definition.binding-pattern.array.js" } }, "end": "\\]", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.array.js" } }, "name": "meta.paramter.array-binding-pattern.js", "patterns": [{ "include": "#parameter-binding-element" }, { "include": "#punctuation-comma" }] }] }, "destructuring-parameter-rest": { "captures": { "1": { "name": "keyword.operator.rest.js" }, "2": { "name": "variable.parameter.js" } }, "match": "(?:(\\.\\.\\.)\\s*)?([_$[:alpha:]][_$[:alnum:]]*)" }, "destructuring-variable": { "patterns": [{ "begin": "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\{)", "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))", "name": "meta.object-binding-pattern-variable.js", "patterns": [{ "include": "#object-binding-pattern" }, { "include": "#type-annotation" }, { "include": "#comment" }] }, { "begin": "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\[)", "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))", "name": "meta.array-binding-pattern-variable.js", "patterns": [{ "include": "#array-binding-pattern" }, { "include": "#type-annotation" }, { "include": "#comment" }] }] }, "destructuring-variable-rest": { "captures": { "1": { "name": "keyword.operator.rest.js" }, "2": { "name": "meta.definition.variable.js variable.other.readwrite.js" } }, "match": "(?:(\\.\\.\\.)\\s*)?([_$[:alpha:]][_$[:alnum:]]*)" }, "destructuring-variable-rest-const": { "captures": { "1": { "name": "keyword.operator.rest.js" }, "2": { "name": "meta.definition.variable.js variable.other.constant.js" } }, "match": "(?:(\\.\\.\\.)\\s*)?([_$[:alpha:]][_$[:alnum:]]*)" }, "directives": { "begin": "^(///)\\s*(?=<(reference|amd-dependency|amd-module)(\\s+(path|types|no-default-lib|lib|name|resolution-mode)\\s*=\\s*((\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)))+\\s*/>\\s*$)", "beginCaptures": { "1": { "name": "punctuation.definition.comment.js" } }, "end": "(?=$)", "name": "comment.line.triple-slash.directive.js", "patterns": [{ "begin": "(<)(reference|amd-dependency|amd-module)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.directive.js" }, "2": { "name": "entity.name.tag.directive.js" } }, "end": "/>", "endCaptures": { "0": { "name": "punctuation.definition.tag.directive.js" } }, "name": "meta.tag.js", "patterns": [{ "match": "path|types|no-default-lib|lib|name|resolution-mode", "name": "entity.other.attribute-name.directive.js" }, { "match": "=", "name": "keyword.operator.assignment.js" }, { "include": "#string" }] }] }, "docblock": { "patterns": [{ "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "constant.language.access-type.jsdoc" } }, "match": "(?x)\n((@)(?:access|api))\n\\s+\n(private|protected|public)\n\\b" }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "entity.name.type.instance.jsdoc" }, "4": { "name": "punctuation.definition.bracket.angle.begin.jsdoc" }, "5": { "name": "constant.other.email.link.underline.jsdoc" }, "6": { "name": "punctuation.definition.bracket.angle.end.jsdoc" } }, "match": "(?x)\n((@)author)\n\\s+\n(\n  [^@\\s<>*/]\n  (?:[^@<>*/]|\\*[^/])*\n)\n(?:\n  \\s*\n  (<)\n  ([^>\\s]+)\n  (>)\n)?" }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "entity.name.type.instance.jsdoc" }, "4": { "name": "keyword.operator.control.jsdoc" }, "5": { "name": "entity.name.type.instance.jsdoc" } }, "match": "(?x)\n((@)borrows) \\s+\n((?:[^@\\s*/]|\\*[^/])+)    # <that namepath>\n\\s+ (as) \\s+              # as\n((?:[^@\\s*/]|\\*[^/])+)    # <this namepath>" }, { "begin": "((@)example)\\s+", "beginCaptures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" } }, "end": "(?=@|\\*/)", "name": "meta.example.jsdoc", "patterns": [{ "match": "^\\s\\*\\s+" }, { "begin": "\\G(<)caption(>)", "beginCaptures": { "0": { "name": "entity.name.tag.inline.jsdoc" }, "1": { "name": "punctuation.definition.bracket.angle.begin.jsdoc" }, "2": { "name": "punctuation.definition.bracket.angle.end.jsdoc" } }, "contentName": "constant.other.description.jsdoc", "end": "(</)caption(>)|(?=\\*/)", "endCaptures": { "0": { "name": "entity.name.tag.inline.jsdoc" }, "1": { "name": "punctuation.definition.bracket.angle.begin.jsdoc" }, "2": { "name": "punctuation.definition.bracket.angle.end.jsdoc" } } }, { "captures": { "0": { "name": "source.embedded.js" } }, "match": "[^\\s@*](?:[^*]|\\*[^/])*" }] }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "constant.language.symbol-type.jsdoc" } }, "match": "(?x) ((@)kind) \\s+ (class|constant|event|external|file|function|member|mixin|module|namespace|typedef) \\b" }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "variable.other.link.underline.jsdoc" }, "4": { "name": "entity.name.type.instance.jsdoc" } }, "match": "(?x)\n((@)see)\n\\s+\n(?:\n  # URL\n  (\n    (?=https?://)\n    (?:[^\\s*]|\\*[^/])+\n  )\n  |\n  # JSDoc namepath\n  (\n    (?!\n      # Avoid matching bare URIs (also acceptable as links)\n      https?://\n      |\n      # Avoid matching {@inline tags}; we match those below\n      (?:\\[[^\\[\\]]*\\])? # Possible description [preceding]{@tag}\n      {@(?:link|linkcode|linkplain|tutorial)\\b\n    )\n    # Matched namepath\n    (?:[^@\\s*/]|\\*[^/])+\n  )\n)" }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "variable.other.jsdoc" } }, "match": "(?x)\n((@)template)\n\\s+\n# One or more valid identifiers\n(\n  [A-Za-z_$]         # First character: non-numeric word character\n  [\\w$.\\[\\]]*        # Rest of identifier\n  (?:                # Possible list of additional identifiers\n    \\s* , \\s*\n    [A-Za-z_$]\n    [\\w$.\\[\\]]*\n  )*\n)" }, { "begin": "(?x)((@)template)\\s+(?={)", "beginCaptures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" } }, "end": "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])", "patterns": [{ "include": "#jsdoctype" }, { "match": "([A-Za-z_$][\\w$.\\[\\]]*)", "name": "variable.other.jsdoc" }] }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "variable.other.jsdoc" } }, "match": "(?x)\n(\n  (@)\n  (?:arg|argument|const|constant|member|namespace|param|var)\n)\n\\s+\n(\n  [A-Za-z_$]\n  [\\w$.\\[\\]]*\n)" }, { "begin": "((@)typedef)\\s+(?={)", "beginCaptures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" } }, "end": "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])", "patterns": [{ "include": "#jsdoctype" }, { "match": "(?:[^@\\s*/]|\\*[^/])+", "name": "entity.name.type.instance.jsdoc" }] }, { "begin": "((@)(?:arg|argument|const|constant|member|namespace|param|prop|property|var))\\s+(?={)", "beginCaptures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" } }, "end": "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])", "patterns": [{ "include": "#jsdoctype" }, { "match": "([A-Za-z_$][\\w$.\\[\\]]*)", "name": "variable.other.jsdoc" }, { "captures": { "1": { "name": "punctuation.definition.optional-value.begin.bracket.square.jsdoc" }, "2": { "name": "keyword.operator.assignment.jsdoc" }, "3": { "name": "source.embedded.js" }, "4": { "name": "punctuation.definition.optional-value.end.bracket.square.jsdoc" }, "5": { "name": "invalid.illegal.syntax.jsdoc" } }, "match": `(?x)
(\\[)\\s*
[\\w$]+
(?:
  (?:\\[\\])?                                        # Foo[ ].bar properties within an array
  \\.                                                # Foo.Bar namespaced parameter
  [\\w$]+
)*
(?:
  \\s*
  (=)                                                # [foo=bar] Default parameter value
  \\s*
  (
    # The inner regexes are to stop the match early at */ and to not stop at escaped quotes
    (?>
      "(?:(?:\\*(?!/))|(?:\\\\(?!"))|[^*\\\\])*?" |                      # [foo="bar"] Double-quoted
      '(?:(?:\\*(?!/))|(?:\\\\(?!'))|[^*\\\\])*?' |                      # [foo='bar'] Single-quoted
      \\[ (?:(?:\\*(?!/))|[^*])*? \\] |                                # [foo=[1,2]] Array literal
      (?:(?:\\*(?!/))|\\s(?!\\s*\\])|\\[.*?(?:\\]|(?=\\*/))|[^*\\s\\[\\]])*   # Everything else
    )*
  )
)?
\\s*(?:(\\])((?:[^*\\s]|\\*[^\\s/])+)?|(?=\\*/))`, "name": "variable.other.jsdoc" }] }, { "begin": "(?x)\n(\n  (@)\n  (?:define|enum|exception|export|extends|lends|implements|modifies\n  |namespace|private|protected|returns?|satisfies|suppress|this|throws|type\n  |yields?)\n)\n\\s+(?={)", "beginCaptures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" } }, "end": "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])", "patterns": [{ "include": "#jsdoctype" }] }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "entity.name.type.instance.jsdoc" } }, "match": "(?x)\n(\n  (@)\n  (?:alias|augments|callback|constructs|emits|event|fires|exports?\n  |extends|external|function|func|host|lends|listens|interface|memberof!?\n  |method|module|mixes|mixin|name|requires|see|this|typedef|uses)\n)\n\\s+\n(\n  (?:\n    [^{}@\\s*] | \\*[^/]\n  )+\n)" }, { "begin": `((@)(?:default(?:value)?|license|version))\\s+(([''"]))`, "beginCaptures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "variable.other.jsdoc" }, "4": { "name": "punctuation.definition.string.begin.jsdoc" } }, "contentName": "variable.other.jsdoc", "end": "(\\3)|(?=$|\\*/)", "endCaptures": { "0": { "name": "variable.other.jsdoc" }, "1": { "name": "punctuation.definition.string.end.jsdoc" } } }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "variable.other.jsdoc" } }, "match": "((@)(?:default(?:value)?|license|tutorial|variation|version))\\s+([^\\s*]+)" }, { "captures": { "1": { "name": "punctuation.definition.block.tag.jsdoc" } }, "match": "(?x) (@) (?:abstract|access|alias|api|arg|argument|async|attribute|augments|author|beta|borrows|bubbles |callback|chainable|class|classdesc|code|config|const|constant|constructor|constructs|copyright |default|defaultvalue|define|deprecated|desc|description|dict|emits|enum|event|example|exception |exports?|extends|extension(?:_?for)?|external|externs|file|fileoverview|final|fires|for|func |function|generator|global|hideconstructor|host|ignore|implements|implicitCast|inherit[Dd]oc |inner|instance|interface|internal|kind|lends|license|listens|main|member|memberof!?|method |mixes|mixins?|modifies|module|name|namespace|noalias|nocollapse|nocompile|nosideeffects |override|overview|package|param|polymer(?:Behavior)?|preserve|private|prop|property|protected |public|read[Oo]nly|record|require[ds]|returns?|see|since|static|struct|submodule|summary |suppress|template|this|throws|todo|tutorial|type|typedef|unrestricted|uses|var|variation |version|virtual|writeOnce|yields?) \\b", "name": "storage.type.class.jsdoc" }, { "include": "#inline-tags" }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" } }, "match": "((@)(?:[_$[:alpha:]][_$[:alnum:]]*))(?=\\s+)" }] }, "enum-declaration": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?(?:\\b(const)\\s+)?\\b(enum)\\s+([_$[:alpha:]][_$[:alnum:]]*)", "beginCaptures": { "1": { "name": "keyword.control.export.js" }, "2": { "name": "storage.modifier.js" }, "3": { "name": "storage.modifier.js" }, "4": { "name": "storage.type.enum.js" }, "5": { "name": "entity.name.type.enum.js" } }, "end": "(?<=\\})", "name": "meta.enum.declaration.js", "patterns": [{ "include": "#comment" }, { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.block.js" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.js" } }, "patterns": [{ "include": "#comment" }, { "begin": "([_$[:alpha:]][_$[:alnum:]]*)", "beginCaptures": { "0": { "name": "variable.other.enummember.js" } }, "end": "(?=,|\\}|$)", "patterns": [{ "include": "#comment" }, { "include": "#variable-initializer" }] }, { "begin": "(?=((\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\])))", "end": "(?=,|\\}|$)", "patterns": [{ "include": "#string" }, { "include": "#array-literal" }, { "include": "#comment" }, { "include": "#variable-initializer" }] }, { "include": "#punctuation-comma" }] }] }, "export-declaration": { "patterns": [{ "captures": { "1": { "name": "keyword.control.export.js" }, "2": { "name": "keyword.control.as.js" }, "3": { "name": "storage.type.namespace.js" }, "4": { "name": "entity.name.type.module.js" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(export)\\s+(as)\\s+(namespace)\\s+([_$[:alpha:]][_$[:alnum:]]*)" }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(export)(?:\\s+(type))?(?:(?:\\s*(=))|(?:\\s+(default)(?=\\s+)))", "beginCaptures": { "1": { "name": "keyword.control.export.js" }, "2": { "name": "keyword.control.type.js" }, "3": { "name": "keyword.operator.assignment.js" }, "4": { "name": "keyword.control.default.js" } }, "end": "(?=$|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "name": "meta.export.default.js", "patterns": [{ "include": "#interface-declaration" }, { "include": "#expression" }] }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(export)(?:\\s+(type))?\\b(?!(\\$)|(\\s*:))((?=\\s*[\\{*])|((?=\\s*[_$[:alpha:]][_$[:alnum:]]*(\\s|,))(?!\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b)))", "beginCaptures": { "1": { "name": "keyword.control.export.js" }, "2": { "name": "keyword.control.type.js" } }, "end": "(?=$|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "name": "meta.export.js", "patterns": [{ "include": "#import-export-declaration" }] }] }, "expression": { "patterns": [{ "include": "#expressionWithoutIdentifiers" }, { "include": "#identifiers" }, { "include": "#expressionPunctuations" }] }, "expression-inside-possibly-arrow-parens": { "patterns": [{ "include": "#expressionWithoutIdentifiers" }, { "include": "#comment" }, { "include": "#string" }, { "include": "#decorator" }, { "include": "#destructuring-parameter" }, { "captures": { "1": { "name": "storage.modifier.js" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|protected|private|readonly)\\s+(?=(override|public|protected|private|readonly)\\s+)" }, { "captures": { "1": { "name": "storage.modifier.js" }, "2": { "name": "keyword.operator.rest.js" }, "3": { "name": "entity.name.function.js variable.language.this.js" }, "4": { "name": "entity.name.function.js" }, "5": { "name": "keyword.operator.optional.js" } }, "match": "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))" }, { "captures": { "1": { "name": "storage.modifier.js" }, "2": { "name": "keyword.operator.rest.js" }, "3": { "name": "variable.parameter.js variable.language.this.js" }, "4": { "name": "variable.parameter.js" }, "5": { "name": "keyword.operator.optional.js" } }, "match": "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)(?=\\s*[:,]|$)" }, { "include": "#type-annotation" }, { "include": "#variable-initializer" }, { "match": ",", "name": "punctuation.separator.parameter.js" }, { "include": "#identifiers" }, { "include": "#expressionPunctuations" }] }, "expression-operators": { "patterns": [{ "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(await)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.control.flow.js" }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(yield)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?=\\s*\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*\\*)", "beginCaptures": { "1": { "name": "keyword.control.flow.js" } }, "end": "\\*", "endCaptures": { "0": { "name": "keyword.generator.asterisk.js" } }, "patterns": [{ "include": "#comment" }] }, { "captures": { "1": { "name": "keyword.control.flow.js" }, "2": { "name": "keyword.generator.asterisk.js" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(yield)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?:\\s*(\\*))?" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))delete(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.operator.expression.delete.js" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))in(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?!\\()", "name": "keyword.operator.expression.in.js" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))of(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?!\\()", "name": "keyword.operator.expression.of.js" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))instanceof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.operator.expression.instanceof.js" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))new(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.operator.new.js" }, { "include": "#typeof-operator" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))void(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.operator.expression.void.js" }, { "captures": { "1": { "name": "keyword.control.as.js" }, "2": { "name": "storage.modifier.js" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+(const)(?=\\s*($|[;,:})\\]]))" }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(as)|(satisfies))\\s+", "beginCaptures": { "1": { "name": "keyword.control.as.js" }, "2": { "name": "keyword.control.satisfies.js" } }, "end": "(?=^|[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as|satisfies)\\s+)|(\\s+\\<))", "patterns": [{ "include": "#type" }] }, { "match": "\\.\\.\\.", "name": "keyword.operator.spread.js" }, { "match": "\\*=|(?<!\\()/=|%=|\\+=|\\-=", "name": "keyword.operator.assignment.compound.js" }, { "match": "\\&=|\\^=|<<=|>>=|>>>=|\\|=", "name": "keyword.operator.assignment.compound.bitwise.js" }, { "match": "<<|>>>|>>", "name": "keyword.operator.bitwise.shift.js" }, { "match": "===|!==|==|!=", "name": "keyword.operator.comparison.js" }, { "match": "<=|>=|<>|<|>", "name": "keyword.operator.relational.js" }, { "captures": { "1": { "name": "keyword.operator.logical.js" }, "2": { "name": "keyword.operator.assignment.compound.js" }, "3": { "name": "keyword.operator.arithmetic.js" } }, "match": "(?<=[_$[:alnum:]])(\\!)\\s*(?:(/=)|(?:(/)(?![/*])))" }, { "match": "\\!|&&|\\|\\||\\?\\?", "name": "keyword.operator.logical.js" }, { "match": "\\&|~|\\^|\\|", "name": "keyword.operator.bitwise.js" }, { "match": "\\=", "name": "keyword.operator.assignment.js" }, { "match": "--", "name": "keyword.operator.decrement.js" }, { "match": "\\+\\+", "name": "keyword.operator.increment.js" }, { "match": "%|\\*|/|-|\\+", "name": "keyword.operator.arithmetic.js" }, { "begin": "(?<=[_$[:alnum:])\\]])\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)+(?:(/=)|(?:(/)(?![/*]))))", "end": "(?:(/=)|(?:(/)(?!\\*([^\\*]|(\\*[^\\/]))*\\*\\/)))", "endCaptures": { "1": { "name": "keyword.operator.assignment.compound.js" }, "2": { "name": "keyword.operator.arithmetic.js" } }, "patterns": [{ "include": "#comment" }] }, { "captures": { "1": { "name": "keyword.operator.assignment.compound.js" }, "2": { "name": "keyword.operator.arithmetic.js" } }, "match": "(?<=[_$[:alnum:])\\]])\\s*(?:(/=)|(?:(/)(?![/*])))" }] }, "expressionPunctuations": { "patterns": [{ "include": "#punctuation-comma" }, { "include": "#punctuation-accessor" }] }, "expressionWithoutIdentifiers": { "patterns": [{ "include": "#jsx" }, { "include": "#string" }, { "include": "#regex" }, { "include": "#comment" }, { "include": "#function-expression" }, { "include": "#class-expression" }, { "include": "#arrow-function" }, { "include": "#paren-expression-possibly-arrow" }, { "include": "#cast" }, { "include": "#ternary-expression" }, { "include": "#new-expr" }, { "include": "#instanceof-expr" }, { "include": "#object-literal" }, { "include": "#expression-operators" }, { "include": "#function-call" }, { "include": "#literal" }, { "include": "#support-objects" }, { "include": "#paren-expression" }] }, "field-declaration": { "begin": "(?x)(?<!\\()(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(readonly)\\s+)?(?=\\s*((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|(\\#?[_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(?:(?:(\\?)|(\\!))\\s*)?(=|:|;|,|\\}|$))", "beginCaptures": { "1": { "name": "storage.modifier.js" } }, "end": "(?x)(?=\\}|;|,|$|(^(?!\\s*((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|(\\#?[_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(?:(?:(\\?)|(\\!))\\s*)?(=|:|;|,|$))))|(?<=\\})", "name": "meta.field.declaration.js", "patterns": [{ "include": "#variable-initializer" }, { "include": "#type-annotation" }, { "include": "#string" }, { "include": "#array-literal" }, { "include": "#numeric-literal" }, { "include": "#comment" }, { "captures": { "1": { "name": "meta.definition.property.js entity.name.function.js" }, "2": { "name": "keyword.operator.optional.js" }, "3": { "name": "keyword.operator.definiteassignment.js" } }, "match": "(?x)(\\#?[_$[:alpha:]][_$[:alnum:]]*)(?:(\\?)|(\\!))?(?=\\s*\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))" }, { "match": "\\#?[_$[:alpha:]][_$[:alnum:]]*", "name": "meta.definition.property.js variable.object.property.js" }, { "match": "\\?", "name": "keyword.operator.optional.js" }, { "match": "\\!", "name": "keyword.operator.definiteassignment.js" }] }, "for-loop": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))for(?=((\\s+|(\\s*\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*))await)?\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)?(\\())", "beginCaptures": { "0": { "name": "keyword.control.loop.js" } }, "end": "(?<=\\))", "patterns": [{ "include": "#comment" }, { "match": "await", "name": "keyword.control.loop.js" }, { "begin": "\\(", "beginCaptures": { "0": { "name": "meta.brace.round.js" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.js" } }, "patterns": [{ "include": "#var-expr" }, { "include": "#expression" }, { "include": "#punctuation-semicolon" }] }] }, "function-body": { "patterns": [{ "include": "#comment" }, { "include": "#type-parameters" }, { "include": "#function-parameters" }, { "include": "#return-type" }, { "include": "#type-function-return-type" }, { "include": "#decl-block" }, { "match": "\\*", "name": "keyword.generator.asterisk.js" }] }, "function-call": { "patterns": [{ "begin": "(?=(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))\\s*(?:(\\?\\.\\s*)|(\\!))?((<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?\\())", "end": "(?<=\\))(?!(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))\\s*(?:(\\?\\.\\s*)|(\\!))?((<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?\\())", "patterns": [{ "begin": "(?=(([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))", "end": "(?=\\s*(?:(\\?\\.\\s*)|(\\!))?((<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?\\())", "name": "meta.function-call.js", "patterns": [{ "include": "#function-call-target" }] }, { "include": "#comment" }, { "include": "#function-call-optionals" }, { "include": "#type-arguments" }, { "include": "#paren-expression" }] }, { "begin": "(?=(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))(<\\s*[\\{\\[\\(]\\s*$))", "end": "(?<=\\>)(?!(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))(<\\s*[\\{\\[\\(]\\s*$))", "patterns": [{ "begin": "(?=(([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))", "end": "(?=(<\\s*[\\{\\[\\(]\\s*$))", "name": "meta.function-call.js", "patterns": [{ "include": "#function-call-target" }] }, { "include": "#comment" }, { "include": "#function-call-optionals" }, { "include": "#type-arguments" }] }] }, "function-call-optionals": { "patterns": [{ "match": "\\?\\.", "name": "meta.function-call.js punctuation.accessor.optional.js" }, { "match": "\\!", "name": "meta.function-call.js keyword.operator.definiteassignment.js" }] }, "function-call-target": { "patterns": [{ "include": "#support-function-call-identifiers" }, { "match": "(\\#?[_$[:alpha:]][_$[:alnum:]]*)", "name": "entity.name.function.js" }] }, "function-declaration": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?(?:(async)\\s+)?(function\\b)(?:\\s*(\\*))?(?:(?:\\s+|(?<=\\*))([_$[:alpha:]][_$[:alnum:]]*))?\\s*", "beginCaptures": { "1": { "name": "keyword.control.export.js" }, "2": { "name": "storage.modifier.js" }, "3": { "name": "storage.modifier.async.js" }, "4": { "name": "storage.type.function.js" }, "5": { "name": "keyword.generator.asterisk.js" }, "6": { "name": "meta.definition.function.js entity.name.function.js" } }, "end": "(?=;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))|(?<=\\})", "name": "meta.function.js", "patterns": [{ "include": "#function-name" }, { "include": "#function-body" }] }, "function-expression": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(async)\\s+)?(function\\b)(?:\\s*(\\*))?(?:(?:\\s+|(?<=\\*))([_$[:alpha:]][_$[:alnum:]]*))?\\s*", "beginCaptures": { "1": { "name": "storage.modifier.async.js" }, "2": { "name": "storage.type.function.js" }, "3": { "name": "keyword.generator.asterisk.js" }, "4": { "name": "meta.definition.function.js entity.name.function.js" } }, "end": "(?=;)|(?<=\\})", "name": "meta.function.expression.js", "patterns": [{ "include": "#function-name" }, { "include": "#single-line-comment-consuming-line-ending" }, { "include": "#function-body" }] }, "function-name": { "match": "[_$[:alpha:]][_$[:alnum:]]*", "name": "meta.definition.function.js entity.name.function.js" }, "function-parameters": { "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.parameters.begin.js" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.parameters.end.js" } }, "name": "meta.parameters.js", "patterns": [{ "include": "#function-parameters-body" }] }, "function-parameters-body": { "patterns": [{ "include": "#comment" }, { "include": "#string" }, { "include": "#decorator" }, { "include": "#destructuring-parameter" }, { "include": "#parameter-name" }, { "include": "#parameter-type-annotation" }, { "include": "#variable-initializer" }, { "match": ",", "name": "punctuation.separator.parameter.js" }] }, "identifiers": { "patterns": [{ "include": "#object-identifiers" }, { "captures": { "1": { "name": "punctuation.accessor.js" }, "2": { "name": "punctuation.accessor.optional.js" }, "3": { "name": "entity.name.function.js" } }, "match": "(?x)(?:(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*)?([_$[:alpha:]][_$[:alnum:]]*)(?=\\s*=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n))" }, { "captures": { "1": { "name": "punctuation.accessor.js" }, "2": { "name": "punctuation.accessor.optional.js" }, "3": { "name": "variable.other.constant.property.js" } }, "match": "(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(\\#?[[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])" }, { "captures": { "1": { "name": "punctuation.accessor.js" }, "2": { "name": "punctuation.accessor.optional.js" }, "3": { "name": "variable.other.property.js" } }, "match": "(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*)" }, { "match": "([[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])", "name": "variable.other.constant.js" }, { "match": "[_$[:alpha:]][_$[:alnum:]]*", "name": "variable.other.readwrite.js" }] }, "if-statement": { "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?=\\bif\\s*(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))\\s*(?!\\{))", "end": "(?=;|$|\\})", "patterns": [{ "include": "#comment" }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(if)\\s*(\\()", "beginCaptures": { "1": { "name": "keyword.control.conditional.js" }, "2": { "name": "meta.brace.round.js" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.js" } }, "patterns": [{ "include": "#expression" }] }, { "begin": "(?<=\\))\\s*\\/(?![\\/*])(?=(?:[^\\/\\\\\\[]|\\\\.|\\[([^\\]\\\\]|\\\\.)*\\])+\\/([dgimsuy]+|(?![\\/\\*])|(?=\\/\\*))(?!\\s*[a-zA-Z0-9_$]))", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.js" } }, "end": "(/)([dgimsuy]*)", "endCaptures": { "1": { "name": "punctuation.definition.string.end.js" }, "2": { "name": "keyword.other.js" } }, "name": "string.regexp.js", "patterns": [{ "include": "#regexp" }] }, { "include": "#statements" }] }] }, "import-declaration": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(import)(?:\\s+(type)(?!\\s+from))?(?!\\s*[:\\(])(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "1": { "name": "keyword.control.export.js" }, "2": { "name": "storage.modifier.js" }, "3": { "name": "keyword.control.import.js" }, "4": { "name": "keyword.control.type.js" } }, "end": "(?<!^import|[^\\._$[:alnum:]]import)(?=;|$|^)", "name": "meta.import.js", "patterns": [{ "include": "#single-line-comment-consuming-line-ending" }, { "include": "#comment" }, { "include": "#string" }, { "begin": `(?<=^import|[^\\._$[:alnum:]]import)(?!\\s*["'])`, "end": "\\bfrom\\b", "endCaptures": { "0": { "name": "keyword.control.from.js" } }, "patterns": [{ "include": "#import-export-declaration" }] }, { "include": "#import-export-declaration" }] }, "import-equals-declaration": { "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(import)(?:\\s+(type))?\\s+([_$[:alpha:]][_$[:alnum:]]*)\\s*(=)\\s*(require)\\s*(\\()", "beginCaptures": { "1": { "name": "keyword.control.export.js" }, "2": { "name": "storage.modifier.js" }, "3": { "name": "keyword.control.import.js" }, "4": { "name": "keyword.control.type.js" }, "5": { "name": "variable.other.readwrite.alias.js" }, "6": { "name": "keyword.operator.assignment.js" }, "7": { "name": "keyword.control.require.js" }, "8": { "name": "meta.brace.round.js" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.js" } }, "name": "meta.import-equals.external.js", "patterns": [{ "include": "#comment" }, { "include": "#string" }] }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(import)(?:\\s+(type))?\\s+([_$[:alpha:]][_$[:alnum:]]*)\\s*(=)\\s*(?!require\\b)", "beginCaptures": { "1": { "name": "keyword.control.export.js" }, "2": { "name": "storage.modifier.js" }, "3": { "name": "keyword.control.import.js" }, "4": { "name": "keyword.control.type.js" }, "5": { "name": "variable.other.readwrite.alias.js" }, "6": { "name": "keyword.operator.assignment.js" } }, "end": "(?=;|$|^)", "name": "meta.import-equals.internal.js", "patterns": [{ "include": "#single-line-comment-consuming-line-ending" }, { "include": "#comment" }, { "captures": { "1": { "name": "entity.name.type.module.js" }, "2": { "name": "punctuation.accessor.js" }, "3": { "name": "punctuation.accessor.optional.js" } }, "match": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))" }, { "match": "([_$[:alpha:]][_$[:alnum:]]*)", "name": "variable.other.readwrite.js" }] }] }, "import-export-assert-clause": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(assert)\\s*(\\{)", "beginCaptures": { "1": { "name": "keyword.control.assert.js" }, "2": { "name": "punctuation.definition.block.js" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.js" } }, "patterns": [{ "include": "#comment" }, { "include": "#string" }, { "match": "(?:[_$[:alpha:]][_$[:alnum:]]*)\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*:)", "name": "meta.object-literal.key.js" }, { "match": ":", "name": "punctuation.separator.key-value.js" }] }, "import-export-block": { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.block.js" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.js" } }, "name": "meta.block.js", "patterns": [{ "include": "#import-export-clause" }] }, "import-export-clause": { "patterns": [{ "include": "#comment" }, { "captures": { "1": { "name": "keyword.control.type.js" }, "2": { "name": "keyword.control.default.js" }, "3": { "name": "constant.language.import-export-all.js" }, "4": { "name": "variable.other.readwrite.js" }, "5": { "name": "keyword.control.as.js" }, "6": { "name": "keyword.control.default.js" }, "7": { "name": "variable.other.readwrite.alias.js" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(?:(\\btype)\\s+)?(?:(\\bdefault)|(\\*)|(\\b[_$[:alpha:]][_$[:alnum:]]*)))\\s+(as)\\s+(?:(default(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|([_$[:alpha:]][_$[:alnum:]]*))" }, { "include": "#punctuation-comma" }, { "match": "\\*", "name": "constant.language.import-export-all.js" }, { "match": "\\b(default)\\b", "name": "keyword.control.default.js" }, { "captures": { "1": { "name": "keyword.control.type.js" }, "2": { "name": "variable.other.readwrite.alias.js" } }, "match": "(?:(\\btype)\\s+)?([_$[:alpha:]][_$[:alnum:]]*)" }] }, "import-export-declaration": { "patterns": [{ "include": "#comment" }, { "include": "#string" }, { "include": "#import-export-block" }, { "match": "\\bfrom\\b", "name": "keyword.control.from.js" }, { "include": "#import-export-assert-clause" }, { "include": "#import-export-clause" }] }, "indexer-declaration": { "begin": "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(readonly)\\s*)?\\s*(\\[)\\s*([_$[:alpha:]][_$[:alnum:]]*)\\s*(?=:)", "beginCaptures": { "1": { "name": "storage.modifier.js" }, "2": { "name": "meta.brace.square.js" }, "3": { "name": "variable.parameter.js" } }, "end": "(\\])\\s*(\\?\\s*)?|$", "endCaptures": { "1": { "name": "meta.brace.square.js" }, "2": { "name": "keyword.operator.optional.js" } }, "name": "meta.indexer.declaration.js", "patterns": [{ "include": "#type-annotation" }] }, "indexer-mapped-type-declaration": { "begin": "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))([+-])?(readonly)\\s*)?\\s*(\\[)\\s*([_$[:alpha:]][_$[:alnum:]]*)\\s+(in)\\s+", "beginCaptures": { "1": { "name": "keyword.operator.type.modifier.js" }, "2": { "name": "storage.modifier.js" }, "3": { "name": "meta.brace.square.js" }, "4": { "name": "entity.name.type.js" }, "5": { "name": "keyword.operator.expression.in.js" } }, "end": "(\\])([+-])?\\s*(\\?\\s*)?|$", "endCaptures": { "1": { "name": "meta.brace.square.js" }, "2": { "name": "keyword.operator.type.modifier.js" }, "3": { "name": "keyword.operator.optional.js" } }, "name": "meta.indexer.mappedtype.declaration.js", "patterns": [{ "captures": { "1": { "name": "keyword.control.as.js" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+" }, { "include": "#type" }] }, "inline-tags": { "patterns": [{ "captures": { "1": { "name": "punctuation.definition.bracket.square.begin.jsdoc" }, "2": { "name": "punctuation.definition.bracket.square.end.jsdoc" } }, "match": "(\\[)[^\\]]+(\\])(?={@(?:link|linkcode|linkplain|tutorial))", "name": "constant.other.description.jsdoc" }, { "begin": "({)((@)(?:link(?:code|plain)?|tutorial))\\s*", "beginCaptures": { "1": { "name": "punctuation.definition.bracket.curly.begin.jsdoc" }, "2": { "name": "storage.type.class.jsdoc" }, "3": { "name": "punctuation.definition.inline.tag.jsdoc" } }, "end": "}|(?=\\*/)", "endCaptures": { "0": { "name": "punctuation.definition.bracket.curly.end.jsdoc" } }, "name": "entity.name.type.instance.jsdoc", "patterns": [{ "captures": { "1": { "name": "variable.other.link.underline.jsdoc" }, "2": { "name": "punctuation.separator.pipe.jsdoc" } }, "match": "\\G((?=https?://)(?:[^|}\\s*]|\\*[/])+)(\\|)?" }, { "captures": { "1": { "name": "variable.other.description.jsdoc" }, "2": { "name": "punctuation.separator.pipe.jsdoc" } }, "match": "\\G((?:[^{}@\\s|*]|\\*[^/])+)(\\|)?" }] }] }, "instanceof-expr": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(instanceof)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "1": { "name": "keyword.operator.expression.instanceof.js" } }, "end": "(?<=\\))|(?=[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|(===|!==|==|!=)|(([\\&\\~\\^\\|]\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s+instanceof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))function((\\s+[_$[:alpha:]][_$[:alnum:]]*)|(\\s*[\\(]))))", "patterns": [{ "include": "#type" }] }, "interface-declaration": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(?:(abstract)\\s+)?\\b(interface)\\b(?=\\s+|/[/*])", "beginCaptures": { "1": { "name": "keyword.control.export.js" }, "2": { "name": "storage.modifier.js" }, "3": { "name": "storage.modifier.js" }, "4": { "name": "storage.type.interface.js" } }, "end": "(?<=\\})", "name": "meta.interface.js", "patterns": [{ "include": "#comment" }, { "include": "#class-or-interface-heritage" }, { "captures": { "0": { "name": "entity.name.type.interface.js" } }, "match": "[_$[:alpha:]][_$[:alnum:]]*" }, { "include": "#type-parameters" }, { "include": "#class-or-interface-body" }] }, "jsdoctype": { "patterns": [{ "begin": "\\G({)", "beginCaptures": { "0": { "name": "entity.name.type.instance.jsdoc" }, "1": { "name": "punctuation.definition.bracket.curly.begin.jsdoc" } }, "contentName": "entity.name.type.instance.jsdoc", "end": "((}))\\s*|(?=\\*/)", "endCaptures": { "1": { "name": "entity.name.type.instance.jsdoc" }, "2": { "name": "punctuation.definition.bracket.curly.end.jsdoc" } }, "patterns": [{ "include": "#brackets" }] }] }, "jsx": { "patterns": [{ "include": "#jsx-tag-without-attributes-in-expression" }, { "include": "#jsx-tag-in-expression" }] }, "jsx-children": { "patterns": [{ "include": "#jsx-tag-without-attributes" }, { "include": "#jsx-tag" }, { "include": "#jsx-evaluated-code" }, { "include": "#jsx-entities" }] }, "jsx-entities": { "patterns": [{ "captures": { "1": { "name": "punctuation.definition.entity.js" }, "3": { "name": "punctuation.definition.entity.js" } }, "match": "(&)([a-zA-Z0-9]+|#[0-9]+|#x[0-9a-fA-F]+)(;)", "name": "constant.character.entity.js" }] }, "jsx-evaluated-code": { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.section.embedded.begin.js" } }, "contentName": "meta.embedded.expression.js", "end": "\\}", "endCaptures": { "0": { "name": "punctuation.section.embedded.end.js" } }, "patterns": [{ "include": "#expression" }] }, "jsx-string-double-quoted": { "begin": '"', "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.js" } }, "end": '"', "endCaptures": { "0": { "name": "punctuation.definition.string.end.js" } }, "name": "string.quoted.double.js", "patterns": [{ "include": "#jsx-entities" }] }, "jsx-string-single-quoted": { "begin": "'", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.js" } }, "end": "'", "endCaptures": { "0": { "name": "punctuation.definition.string.end.js" } }, "name": "string.quoted.single.js", "patterns": [{ "include": "#jsx-entities" }] }, "jsx-tag": { "begin": "(?=(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))(?=((<\\s*)|(\\s+))(?!\\?)|\\/?>))", "end": "(/>)|(?:(</)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>))", "endCaptures": { "1": { "name": "punctuation.definition.tag.end.js" }, "2": { "name": "punctuation.definition.tag.begin.js" }, "3": { "name": "entity.name.tag.namespace.js" }, "4": { "name": "punctuation.separator.namespace.js" }, "5": { "name": "entity.name.tag.js" }, "6": { "name": "support.class.component.js" }, "7": { "name": "punctuation.definition.tag.end.js" } }, "name": "meta.tag.js", "patterns": [{ "begin": "(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))(?=((<\\s*)|(\\s+))(?!\\?)|\\/?>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.js" }, "2": { "name": "entity.name.tag.namespace.js" }, "3": { "name": "punctuation.separator.namespace.js" }, "4": { "name": "entity.name.tag.js" }, "5": { "name": "support.class.component.js" } }, "end": "(?=[/]?>)", "patterns": [{ "include": "#comment" }, { "include": "#type-arguments" }, { "include": "#jsx-tag-attributes" }] }, { "begin": "(>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.end.js" } }, "contentName": "meta.jsx.children.js", "end": "(?=</)", "patterns": [{ "include": "#jsx-children" }] }] }, "jsx-tag-attribute-assignment": { "match": `=(?=\\s*(?:'|"|{|/\\*|//|\\n))`, "name": "keyword.operator.assignment.js" }, "jsx-tag-attribute-name": { "captures": { "1": { "name": "entity.other.attribute-name.namespace.js" }, "2": { "name": "punctuation.separator.namespace.js" }, "3": { "name": "entity.other.attribute-name.js" } }, "match": "(?x)\n  \\s*\n  (?:([_$[:alpha:]][-_$[:alnum:].]*)(:))?\n  ([_$[:alpha:]][-_$[:alnum:]]*)\n  (?=\\s|=|/?>|/\\*|//)" }, "jsx-tag-attributes": { "begin": "\\s+", "end": "(?=[/]?>)", "name": "meta.tag.attributes.js", "patterns": [{ "include": "#comment" }, { "include": "#jsx-tag-attribute-name" }, { "include": "#jsx-tag-attribute-assignment" }, { "include": "#jsx-string-double-quoted" }, { "include": "#jsx-string-single-quoted" }, { "include": "#jsx-evaluated-code" }, { "include": "#jsx-tag-attributes-illegal" }] }, "jsx-tag-attributes-illegal": { "match": "\\S+", "name": "invalid.illegal.attribute.js" }, "jsx-tag-in-expression": { "begin": "(?x)\n  (?<!\\+\\+|--)(?<=[({\\[,?=>:*]|&&|\\|\\||\\?|\\*\\/|^await|[^\\._$[:alnum:]]await|^return|[^\\._$[:alnum:]]return|^default|[^\\._$[:alnum:]]default|^yield|[^\\._$[:alnum:]]yield|^)\\s*\n  (?!<\\s*[_$[:alpha:]][_$[:alnum:]]*((\\s+extends\\s+[^=>])|,)) # look ahead is not type parameter of arrow\n  (?=(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))(?=((<\\s*)|(\\s+))(?!\\?)|\\/?>))", "end": "(?!(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))(?=((<\\s*)|(\\s+))(?!\\?)|\\/?>))", "patterns": [{ "include": "#jsx-tag" }] }, "jsx-tag-without-attributes": { "begin": "(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.js" }, "2": { "name": "entity.name.tag.namespace.js" }, "3": { "name": "punctuation.separator.namespace.js" }, "4": { "name": "entity.name.tag.js" }, "5": { "name": "support.class.component.js" }, "6": { "name": "punctuation.definition.tag.end.js" } }, "contentName": "meta.jsx.children.js", "end": "(</)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.begin.js" }, "2": { "name": "entity.name.tag.namespace.js" }, "3": { "name": "punctuation.separator.namespace.js" }, "4": { "name": "entity.name.tag.js" }, "5": { "name": "support.class.component.js" }, "6": { "name": "punctuation.definition.tag.end.js" } }, "name": "meta.tag.without-attributes.js", "patterns": [{ "include": "#jsx-children" }] }, "jsx-tag-without-attributes-in-expression": { "begin": "(?<!\\+\\+|--)(?<=[({\\[,?=>:*]|&&|\\|\\||\\?|\\*\\/|^await|[^\\._$[:alnum:]]await|^return|[^\\._$[:alnum:]]return|^default|[^\\._$[:alnum:]]default|^yield|[^\\._$[:alnum:]]yield|^)\\s*(?=(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>))", "end": "(?!(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>))", "patterns": [{ "include": "#jsx-tag-without-attributes" }] }, "label": { "patterns": [{ "begin": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(:)(?=\\s*\\{)", "beginCaptures": { "1": { "name": "entity.name.label.js" }, "2": { "name": "punctuation.separator.label.js" } }, "end": "(?<=\\})", "patterns": [{ "include": "#decl-block" }] }, { "captures": { "1": { "name": "entity.name.label.js" }, "2": { "name": "punctuation.separator.label.js" } }, "match": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(:)" }] }, "literal": { "patterns": [{ "include": "#numeric-literal" }, { "include": "#boolean-literal" }, { "include": "#null-literal" }, { "include": "#undefined-literal" }, { "include": "#numericConstant-literal" }, { "include": "#array-literal" }, { "include": "#this-literal" }, { "include": "#super-literal" }] }, "method-declaration": { "patterns": [{ "begin": "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(override)\\s+)?(?:\\b(public|private|protected)\\s+)?(?:\\b(abstract)\\s+)?(?:\\b(async)\\s+)?\\s*\\b(constructor)\\b(?!:)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "1": { "name": "storage.modifier.js" }, "2": { "name": "storage.modifier.js" }, "3": { "name": "storage.modifier.js" }, "4": { "name": "storage.modifier.async.js" }, "5": { "name": "storage.type.js" } }, "end": "(?=\\}|;|,|$)|(?<=\\})", "name": "meta.method.declaration.js", "patterns": [{ "include": "#method-declaration-name" }, { "include": "#function-body" }] }, { "begin": "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(override)\\s+)?(?:\\b(public|private|protected)\\s+)?(?:\\b(abstract)\\s+)?(?:\\b(async)\\s+)?(?:(?:\\s*\\b(new)\\b(?!:)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|(?:(\\*)\\s*)?)(?=\\s*((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])", "beginCaptures": { "1": { "name": "storage.modifier.js" }, "2": { "name": "storage.modifier.js" }, "3": { "name": "storage.modifier.js" }, "4": { "name": "storage.modifier.async.js" }, "5": { "name": "keyword.operator.new.js" }, "6": { "name": "keyword.generator.asterisk.js" } }, "end": "(?=\\}|;|,|$)|(?<=\\})", "name": "meta.method.declaration.js", "patterns": [{ "include": "#method-declaration-name" }, { "include": "#function-body" }] }, { "begin": "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(override)\\s+)?(?:\\b(public|private|protected)\\s+)?(?:\\b(abstract)\\s+)?(?:\\b(async)\\s+)?(?:\\b(get|set)\\s+)?(?:(\\*)\\s*)?(?=\\s*(((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??))\\s*((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])", "beginCaptures": { "1": { "name": "storage.modifier.js" }, "2": { "name": "storage.modifier.js" }, "3": { "name": "storage.modifier.js" }, "4": { "name": "storage.modifier.async.js" }, "5": { "name": "storage.type.property.js" }, "6": { "name": "keyword.generator.asterisk.js" } }, "end": "(?=\\}|;|,|$)|(?<=\\})", "name": "meta.method.declaration.js", "patterns": [{ "include": "#method-declaration-name" }, { "include": "#function-body" }] }] }, "method-declaration-name": { "begin": "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??)\\s*[\\(\\<])", "end": "(?=\\(|\\<)", "patterns": [{ "include": "#string" }, { "include": "#array-literal" }, { "include": "#numeric-literal" }, { "match": "[_$[:alpha:]][_$[:alnum:]]*", "name": "meta.definition.method.js entity.name.function.js" }, { "match": "\\?", "name": "keyword.operator.optional.js" }] }, "namespace-declaration": { "begin": "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(namespace|module)\\s+(?=[_$[:alpha:]\"'`]))", "beginCaptures": { "1": { "name": "keyword.control.export.js" }, "2": { "name": "storage.modifier.js" }, "3": { "name": "storage.type.namespace.js" } }, "end": "(?<=\\})|(?=;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "name": "meta.namespace.declaration.js", "patterns": [{ "include": "#comment" }, { "include": "#string" }, { "match": "([_$[:alpha:]][_$[:alnum:]]*)", "name": "entity.name.type.module.js" }, { "include": "#punctuation-accessor" }, { "include": "#decl-block" }] }, "new-expr": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(new)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "1": { "name": "keyword.operator.new.js" } }, "end": "(?<=\\))|(?=[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))new(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))function((\\s+[_$[:alpha:]][_$[:alnum:]]*)|(\\s*[\\(]))))", "name": "new.expr.js", "patterns": [{ "include": "#expression" }] }, "null-literal": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))null(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "constant.language.null.js" }, "numeric-literal": { "patterns": [{ "captures": { "1": { "name": "storage.type.numeric.bigint.js" } }, "match": "\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$)", "name": "constant.numeric.hex.js" }, { "captures": { "1": { "name": "storage.type.numeric.bigint.js" } }, "match": "\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$)", "name": "constant.numeric.binary.js" }, { "captures": { "1": { "name": "storage.type.numeric.bigint.js" } }, "match": "\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$)", "name": "constant.numeric.octal.js" }, { "captures": { "0": { "name": "constant.numeric.decimal.js" }, "1": { "name": "meta.delimiter.decimal.period.js" }, "2": { "name": "storage.type.numeric.bigint.js" }, "3": { "name": "meta.delimiter.decimal.period.js" }, "4": { "name": "storage.type.numeric.bigint.js" }, "5": { "name": "meta.delimiter.decimal.period.js" }, "6": { "name": "storage.type.numeric.bigint.js" }, "7": { "name": "storage.type.numeric.bigint.js" }, "8": { "name": "meta.delimiter.decimal.period.js" }, "9": { "name": "storage.type.numeric.bigint.js" }, "10": { "name": "meta.delimiter.decimal.period.js" }, "11": { "name": "storage.type.numeric.bigint.js" }, "12": { "name": "meta.delimiter.decimal.period.js" }, "13": { "name": "storage.type.numeric.bigint.js" }, "14": { "name": "storage.type.numeric.bigint.js" } }, "match": "(?x)\n(?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$)" }] }, "numericConstant-literal": { "patterns": [{ "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))NaN(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "constant.language.nan.js" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Infinity(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "constant.language.infinity.js" }] }, "object-binding-element": { "patterns": [{ "include": "#comment" }, { "begin": "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))", "end": "(?=,|\\})", "patterns": [{ "include": "#object-binding-element-propertyName" }, { "include": "#binding-element" }] }, { "include": "#object-binding-pattern" }, { "include": "#destructuring-variable-rest" }, { "include": "#variable-initializer" }, { "include": "#punctuation-comma" }] }, "object-binding-element-const": { "patterns": [{ "include": "#comment" }, { "begin": "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))", "end": "(?=,|\\})", "patterns": [{ "include": "#object-binding-element-propertyName" }, { "include": "#binding-element-const" }] }, { "include": "#object-binding-pattern-const" }, { "include": "#destructuring-variable-rest-const" }, { "include": "#variable-initializer" }, { "include": "#punctuation-comma" }] }, "object-binding-element-propertyName": { "begin": "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))", "end": "(:)", "endCaptures": { "0": { "name": "punctuation.destructuring.js" } }, "patterns": [{ "include": "#string" }, { "include": "#array-literal" }, { "include": "#numeric-literal" }, { "match": "([_$[:alpha:]][_$[:alnum:]]*)", "name": "variable.object.property.js" }] }, "object-binding-pattern": { "begin": "(?:(\\.\\.\\.)\\s*)?(\\{)", "beginCaptures": { "1": { "name": "keyword.operator.rest.js" }, "2": { "name": "punctuation.definition.binding-pattern.object.js" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.object.js" } }, "patterns": [{ "include": "#object-binding-element" }] }, "object-binding-pattern-const": { "begin": "(?:(\\.\\.\\.)\\s*)?(\\{)", "beginCaptures": { "1": { "name": "keyword.operator.rest.js" }, "2": { "name": "punctuation.definition.binding-pattern.object.js" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.object.js" } }, "patterns": [{ "include": "#object-binding-element-const" }] }, "object-identifiers": { "patterns": [{ "match": "([_$[:alpha:]][_$[:alnum:]]*)(?=\\s*\\??\\.\\s*prototype\\b(?!\\$))", "name": "support.class.js" }, { "captures": { "1": { "name": "punctuation.accessor.js" }, "2": { "name": "punctuation.accessor.optional.js" }, "3": { "name": "variable.other.constant.object.property.js" }, "4": { "name": "variable.other.object.property.js" } }, "match": "(?x)(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(?:\n  (\\#?[[:upper:]][_$[:digit:][:upper:]]*) |\n  (\\#?[_$[:alpha:]][_$[:alnum:]]*)\n)(?=\\s*\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*)" }, { "captures": { "1": { "name": "variable.other.constant.object.js" }, "2": { "name": "variable.other.object.js" } }, "match": "(?x)(?:\n  ([[:upper:]][_$[:digit:][:upper:]]*) |\n  ([_$[:alpha:]][_$[:alnum:]]*)\n)(?=\\s*\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*)" }] }, "object-literal": { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.block.js" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.js" } }, "name": "meta.objectliteral.js", "patterns": [{ "include": "#object-member" }] }, "object-literal-method-declaration": { "begin": "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(async)\\s+)?(?:\\b(get|set)\\s+)?(?:(\\*)\\s*)?(?=\\s*(((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??))\\s*((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])", "beginCaptures": { "1": { "name": "storage.modifier.async.js" }, "2": { "name": "storage.type.property.js" }, "3": { "name": "keyword.generator.asterisk.js" } }, "end": "(?=\\}|;|,)|(?<=\\})", "name": "meta.method.declaration.js", "patterns": [{ "include": "#method-declaration-name" }, { "include": "#function-body" }, { "begin": "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(async)\\s+)?(?:\\b(get|set)\\s+)?(?:(\\*)\\s*)?(?=\\s*(((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??))\\s*((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])", "beginCaptures": { "1": { "name": "storage.modifier.async.js" }, "2": { "name": "storage.type.property.js" }, "3": { "name": "keyword.generator.asterisk.js" } }, "end": "(?=\\(|\\<)", "patterns": [{ "include": "#method-declaration-name" }] }] }, "object-member": { "patterns": [{ "include": "#comment" }, { "include": "#object-literal-method-declaration" }, { "begin": "(?=\\[)", "end": "(?=:)|((?<=[\\]])(?=\\s*[\\(\\<]))", "name": "meta.object.member.js meta.object-literal.key.js", "patterns": [{ "include": "#comment" }, { "include": "#array-literal" }] }, { "begin": "(?=[\\'\\\"\\`])", "end": "(?=:)|((?<=[\\'\\\"\\`])(?=((\\s*[\\(\\<,}])|(\\s+(as|satisifies)\\s+))))", "name": "meta.object.member.js meta.object-literal.key.js", "patterns": [{ "include": "#comment" }, { "include": "#string" }] }, { "begin": "(?x)(?=(\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$)))", "end": "(?=:)|(?=\\s*([\\(\\<,}])|(\\s+as|satisifies\\s+))", "name": "meta.object.member.js meta.object-literal.key.js", "patterns": [{ "include": "#comment" }, { "include": "#numeric-literal" }] }, { "begin": "(?<=[\\]\\'\\\"\\`])(?=\\s*[\\(\\<])", "end": "(?=\\}|;|,)|(?<=\\})", "name": "meta.method.declaration.js", "patterns": [{ "include": "#function-body" }] }, { "captures": { "0": { "name": "meta.object-literal.key.js" }, "1": { "name": "constant.numeric.decimal.js" } }, "match": "(?![_$[:alpha:]])([[:digit:]]+)\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*:)", "name": "meta.object.member.js" }, { "captures": { "0": { "name": "meta.object-literal.key.js" }, "1": { "name": "entity.name.function.js" } }, "match": "(?x)(?:([_$[:alpha:]][_$[:alnum:]]*)\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*:(\\s*\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/)*\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))", "name": "meta.object.member.js" }, { "captures": { "0": { "name": "meta.object-literal.key.js" } }, "match": "(?:[_$[:alpha:]][_$[:alnum:]]*)\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*:)", "name": "meta.object.member.js" }, { "begin": "\\.\\.\\.", "beginCaptures": { "0": { "name": "keyword.operator.spread.js" } }, "end": "(?=,|\\})", "name": "meta.object.member.js", "patterns": [{ "include": "#expression" }] }, { "captures": { "1": { "name": "variable.other.readwrite.js" } }, "match": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?=,|\\}|$|\\/\\/|\\/\\*)", "name": "meta.object.member.js" }, { "captures": { "1": { "name": "keyword.control.as.js" }, "2": { "name": "storage.modifier.js" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+(const)(?=\\s*([,}]|$))", "name": "meta.object.member.js" }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(as)|(satisfies))\\s+", "beginCaptures": { "1": { "name": "keyword.control.as.js" }, "2": { "name": "keyword.control.satisfies.js" } }, "end": "(?=[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|^|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as|satisifies)\\s+))", "name": "meta.object.member.js", "patterns": [{ "include": "#type" }] }, { "begin": "(?=[_$[:alpha:]][_$[:alnum:]]*\\s*=)", "end": "(?=,|\\}|$|\\/\\/|\\/\\*)", "name": "meta.object.member.js", "patterns": [{ "include": "#expression" }] }, { "begin": ":", "beginCaptures": { "0": { "name": "meta.object-literal.key.js punctuation.separator.key-value.js" } }, "end": "(?=,|\\})", "name": "meta.object.member.js", "patterns": [{ "begin": "(?<=:)\\s*(async)?(?=\\s*(<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)\\(\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))", "beginCaptures": { "1": { "name": "storage.modifier.async.js" } }, "end": "(?<=\\))", "patterns": [{ "include": "#type-parameters" }, { "begin": "\\(", "beginCaptures": { "0": { "name": "meta.brace.round.js" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.js" } }, "patterns": [{ "include": "#expression-inside-possibly-arrow-parens" }] }] }, { "begin": "(?<=:)\\s*(async)?\\s*(\\()(?=\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))", "beginCaptures": { "1": { "name": "storage.modifier.async.js" }, "2": { "name": "meta.brace.round.js" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.js" } }, "patterns": [{ "include": "#expression-inside-possibly-arrow-parens" }] }, { "begin": "(?<=:)\\s*(async)?\\s*(?=\\<\\s*$)", "beginCaptures": { "1": { "name": "storage.modifier.async.js" } }, "end": "(?<=\\>)", "patterns": [{ "include": "#type-parameters" }] }, { "begin": "(?<=\\>)\\s*(\\()(?=\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))", "beginCaptures": { "1": { "name": "meta.brace.round.js" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.js" } }, "patterns": [{ "include": "#expression-inside-possibly-arrow-parens" }] }, { "include": "#possibly-arrow-return-type" }, { "include": "#expression" }] }, { "include": "#punctuation-comma" }, { "include": "#decl-block" }] }, "parameter-array-binding-pattern": { "begin": "(?:(\\.\\.\\.)\\s*)?(\\[)", "beginCaptures": { "1": { "name": "keyword.operator.rest.js" }, "2": { "name": "punctuation.definition.binding-pattern.array.js" } }, "end": "\\]", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.array.js" } }, "patterns": [{ "include": "#parameter-binding-element" }, { "include": "#punctuation-comma" }] }, "parameter-binding-element": { "patterns": [{ "include": "#comment" }, { "include": "#string" }, { "include": "#numeric-literal" }, { "include": "#regex" }, { "include": "#parameter-object-binding-pattern" }, { "include": "#parameter-array-binding-pattern" }, { "include": "#destructuring-parameter-rest" }, { "include": "#variable-initializer" }] }, "parameter-name": { "patterns": [{ "captures": { "1": { "name": "storage.modifier.js" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|protected|private|readonly)\\s+(?=(override|public|protected|private|readonly)\\s+)" }, { "captures": { "1": { "name": "storage.modifier.js" }, "2": { "name": "keyword.operator.rest.js" }, "3": { "name": "entity.name.function.js variable.language.this.js" }, "4": { "name": "entity.name.function.js" }, "5": { "name": "keyword.operator.optional.js" } }, "match": "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))" }, { "captures": { "1": { "name": "storage.modifier.js" }, "2": { "name": "keyword.operator.rest.js" }, "3": { "name": "variable.parameter.js variable.language.this.js" }, "4": { "name": "variable.parameter.js" }, "5": { "name": "keyword.operator.optional.js" } }, "match": "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)" }] }, "parameter-object-binding-element": { "patterns": [{ "include": "#comment" }, { "begin": "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))", "end": "(?=,|\\})", "patterns": [{ "include": "#object-binding-element-propertyName" }, { "include": "#parameter-binding-element" }, { "include": "#paren-expression" }] }, { "include": "#parameter-object-binding-pattern" }, { "include": "#destructuring-parameter-rest" }, { "include": "#variable-initializer" }, { "include": "#punctuation-comma" }] }, "parameter-object-binding-pattern": { "begin": "(?:(\\.\\.\\.)\\s*)?(\\{)", "beginCaptures": { "1": { "name": "keyword.operator.rest.js" }, "2": { "name": "punctuation.definition.binding-pattern.object.js" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.object.js" } }, "patterns": [{ "include": "#parameter-object-binding-element" }] }, "parameter-type-annotation": { "patterns": [{ "begin": "(:)", "beginCaptures": { "1": { "name": "keyword.operator.type.annotation.js" } }, "end": "(?=[,)])|(?==[^>])", "name": "meta.type.annotation.js", "patterns": [{ "include": "#type" }] }] }, "paren-expression": { "begin": "\\(", "beginCaptures": { "0": { "name": "meta.brace.round.js" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.js" } }, "patterns": [{ "include": "#expression" }] }, "paren-expression-possibly-arrow": { "patterns": [{ "begin": "(?<=[(=,])\\s*(async)?(?=\\s*((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?\\(\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))", "beginCaptures": { "1": { "name": "storage.modifier.async.js" } }, "end": "(?<=\\))", "patterns": [{ "include": "#paren-expression-possibly-arrow-with-typeparameters" }] }, { "begin": "(?<=[(=,]|=>|^return|[^\\._$[:alnum:]]return)\\s*(async)?(?=\\s*((((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?\\()|(<)|((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)))\\s*$)", "beginCaptures": { "1": { "name": "storage.modifier.async.js" } }, "end": "(?<=\\))", "patterns": [{ "include": "#paren-expression-possibly-arrow-with-typeparameters" }] }, { "include": "#possibly-arrow-return-type" }] }, "paren-expression-possibly-arrow-with-typeparameters": { "patterns": [{ "include": "#type-parameters" }, { "begin": "\\(", "beginCaptures": { "0": { "name": "meta.brace.round.js" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.js" } }, "patterns": [{ "include": "#expression-inside-possibly-arrow-parens" }] }] }, "possibly-arrow-return-type": { "begin": "(?<=\\)|^)\\s*(:)(?=\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*=>)", "beginCaptures": { "1": { "name": "meta.arrow.js meta.return.type.arrow.js keyword.operator.type.annotation.js" } }, "contentName": "meta.arrow.js meta.return.type.arrow.js", "end": "(?==>|\\{|(^\\s*(export|function|class|interface|let|var|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|const|import|enum|namespace|module|type|abstract|declare)\\s+))", "patterns": [{ "include": "#arrow-return-type-body" }] }, "property-accessor": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(accessor|get|set)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "storage.type.property.js" }, "punctuation-accessor": { "captures": { "1": { "name": "punctuation.accessor.js" }, "2": { "name": "punctuation.accessor.optional.js" } }, "match": "(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))" }, "punctuation-comma": { "match": ",", "name": "punctuation.separator.comma.js" }, "punctuation-semicolon": { "match": ";", "name": "punctuation.terminator.statement.js" }, "qstring-double": { "begin": '"', "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.js" } }, "end": '(")|((?:[^\\\\\\n])$)', "endCaptures": { "1": { "name": "punctuation.definition.string.end.js" }, "2": { "name": "invalid.illegal.newline.js" } }, "name": "string.quoted.double.js", "patterns": [{ "include": "#string-character-escape" }] }, "qstring-single": { "begin": "'", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.js" } }, "end": "(\\')|((?:[^\\\\\\n])$)", "endCaptures": { "1": { "name": "punctuation.definition.string.end.js" }, "2": { "name": "invalid.illegal.newline.js" } }, "name": "string.quoted.single.js", "patterns": [{ "include": "#string-character-escape" }] }, "regex": { "patterns": [{ "begin": "(?<!\\+\\+|--|})(?<=[=(:,\\[?+!]|^return|[^\\._$[:alnum:]]return|^case|[^\\._$[:alnum:]]case|=>|&&|\\|\\||\\*\\/)\\s*(\\/)(?![\\/*])(?=(?:[^\\/\\\\\\[\\()]|\\\\.|\\[([^\\]\\\\]|\\\\.)+\\]|\\(([^\\)\\\\]|\\\\.)+\\))+\\/([dgimsuy]+|(?![\\/\\*])|(?=\\/\\*))(?!\\s*[a-zA-Z0-9_$]))", "beginCaptures": { "1": { "name": "punctuation.definition.string.begin.js" } }, "end": "(/)([dgimsuy]*)", "endCaptures": { "1": { "name": "punctuation.definition.string.end.js" }, "2": { "name": "keyword.other.js" } }, "name": "string.regexp.js", "patterns": [{ "include": "#regexp" }] }, { "begin": "((?<![_$[:alnum:])\\]]|\\+\\+|--|}|\\*\\/)|((?<=^return|[^\\._$[:alnum:]]return|^case|[^\\._$[:alnum:]]case))\\s*)\\/(?![\\/*])(?=(?:[^\\/\\\\\\[]|\\\\.|\\[([^\\]\\\\]|\\\\.)*\\])+\\/([dgimsuy]+|(?![\\/\\*])|(?=\\/\\*))(?!\\s*[a-zA-Z0-9_$]))", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.js" } }, "end": "(/)([dgimsuy]*)", "endCaptures": { "1": { "name": "punctuation.definition.string.end.js" }, "2": { "name": "keyword.other.js" } }, "name": "string.regexp.js", "patterns": [{ "include": "#regexp" }] }] }, "regex-character-class": { "patterns": [{ "match": "\\\\[wWsSdDtrnvf]|\\.", "name": "constant.other.character-class.regexp" }, { "match": "\\\\([0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4})", "name": "constant.character.numeric.regexp" }, { "match": "\\\\c[A-Z]", "name": "constant.character.control.regexp" }, { "match": "\\\\.", "name": "constant.character.escape.backslash.regexp" }] }, "regexp": { "patterns": [{ "match": "\\\\[bB]|\\^|\\$", "name": "keyword.control.anchor.regexp" }, { "captures": { "0": { "name": "keyword.other.back-reference.regexp" }, "1": { "name": "variable.other.regexp" } }, "match": "\\\\[1-9]\\d*|\\\\k<([a-zA-Z_$][\\w$]*)>" }, { "match": "[?+*]|\\{(\\d+,\\d+|\\d+,|,\\d+|\\d+)\\}\\??", "name": "keyword.operator.quantifier.regexp" }, { "match": "\\|", "name": "keyword.operator.or.regexp" }, { "begin": "(\\()((\\?=)|(\\?!)|(\\?<=)|(\\?<!))", "beginCaptures": { "1": { "name": "punctuation.definition.group.regexp" }, "2": { "name": "punctuation.definition.group.assertion.regexp" }, "3": { "name": "meta.assertion.look-ahead.regexp" }, "4": { "name": "meta.assertion.negative-look-ahead.regexp" }, "5": { "name": "meta.assertion.look-behind.regexp" }, "6": { "name": "meta.assertion.negative-look-behind.regexp" } }, "end": "(\\))", "endCaptures": { "1": { "name": "punctuation.definition.group.regexp" } }, "name": "meta.group.assertion.regexp", "patterns": [{ "include": "#regexp" }] }, { "begin": "\\((?:(\\?:)|(?:\\?<([a-zA-Z_$][\\w$]*)>))?", "beginCaptures": { "0": { "name": "punctuation.definition.group.regexp" }, "1": { "name": "punctuation.definition.group.no-capture.regexp" }, "2": { "name": "variable.other.regexp" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.regexp" } }, "name": "meta.group.regexp", "patterns": [{ "include": "#regexp" }] }, { "begin": "(\\[)(\\^)?", "beginCaptures": { "1": { "name": "punctuation.definition.character-class.regexp" }, "2": { "name": "keyword.operator.negation.regexp" } }, "end": "(\\])", "endCaptures": { "1": { "name": "punctuation.definition.character-class.regexp" } }, "name": "constant.other.character-class.set.regexp", "patterns": [{ "captures": { "1": { "name": "constant.character.numeric.regexp" }, "2": { "name": "constant.character.control.regexp" }, "3": { "name": "constant.character.escape.backslash.regexp" }, "4": { "name": "constant.character.numeric.regexp" }, "5": { "name": "constant.character.control.regexp" }, "6": { "name": "constant.character.escape.backslash.regexp" } }, "match": "(?:.|(\\\\(?:[0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}))|(\\\\c[A-Z])|(\\\\.))\\-(?:[^\\]\\\\]|(\\\\(?:[0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}))|(\\\\c[A-Z])|(\\\\.))", "name": "constant.other.character-class.range.regexp" }, { "include": "#regex-character-class" }] }, { "include": "#regex-character-class" }] }, "return-type": { "patterns": [{ "begin": "(?<=\\))\\s*(:)(?=\\s*\\S)", "beginCaptures": { "1": { "name": "keyword.operator.type.annotation.js" } }, "end": "(?<![:|&])(?=$|^|[{};,]|//)", "name": "meta.return.type.js", "patterns": [{ "include": "#return-type-core" }] }, { "begin": "(?<=\\))\\s*(:)", "beginCaptures": { "1": { "name": "keyword.operator.type.annotation.js" } }, "end": "(?<![:|&])((?=[{};,]|//|^\\s*$)|((?<=\\S)(?=\\s*$)))", "name": "meta.return.type.js", "patterns": [{ "include": "#return-type-core" }] }] }, "return-type-core": { "patterns": [{ "include": "#comment" }, { "begin": "(?<=[:|&])(?=\\s*\\{)", "end": "(?<=\\})", "patterns": [{ "include": "#type-object" }] }, { "include": "#type-predicate-operator" }, { "include": "#type" }] }, "shebang": { "captures": { "1": { "name": "punctuation.definition.comment.js" } }, "match": "\\A(#!).*(?=$)", "name": "comment.line.shebang.js" }, "single-line-comment-consuming-line-ending": { "begin": "(^[ \\t]+)?((//)(?:\\s*((@)internal)(?=\\s|$))?)", "beginCaptures": { "1": { "name": "punctuation.whitespace.comment.leading.js" }, "2": { "name": "comment.line.double-slash.js" }, "3": { "name": "punctuation.definition.comment.js" }, "4": { "name": "storage.type.internaldeclaration.js" }, "5": { "name": "punctuation.decorator.internaldeclaration.js" } }, "contentName": "comment.line.double-slash.js", "end": "(?=^)" }, "statements": { "patterns": [{ "include": "#declaration" }, { "include": "#control-statement" }, { "include": "#after-operator-block-as-object-literal" }, { "include": "#decl-block" }, { "include": "#label" }, { "include": "#expression" }, { "include": "#punctuation-semicolon" }, { "include": "#string" }, { "include": "#comment" }] }, "string": { "patterns": [{ "include": "#qstring-single" }, { "include": "#qstring-double" }, { "include": "#template" }] }, "string-character-escape": { "match": "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|u\\{[0-9A-Fa-f]+\\}|[0-2][0-7]{0,2}|3[0-6][0-7]?|37[0-7]?|[4-7][0-7]?|.|$)", "name": "constant.character.escape.js" }, "super-literal": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))super\\b(?!\\$)", "name": "variable.language.super.js" }, "support-function-call-identifiers": { "patterns": [{ "include": "#literal" }, { "include": "#support-objects" }, { "include": "#object-identifiers" }, { "include": "#punctuation-accessor" }, { "match": "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))import(?=\\s*[\\(]\\s*[\\\"\\'\\`]))", "name": "keyword.operator.expression.import.js" }] }, "support-objects": { "patterns": [{ "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(arguments)\\b(?!\\$)", "name": "variable.language.arguments.js" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(Promise)\\b(?!\\$)", "name": "support.class.promise.js" }, { "captures": { "1": { "name": "keyword.control.import.js" }, "2": { "name": "punctuation.accessor.js" }, "3": { "name": "punctuation.accessor.optional.js" }, "4": { "name": "support.variable.property.importmeta.js" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(import)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(meta)\\b(?!\\$)" }, { "captures": { "1": { "name": "keyword.operator.new.js" }, "2": { "name": "punctuation.accessor.js" }, "3": { "name": "punctuation.accessor.optional.js" }, "4": { "name": "support.variable.property.target.js" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(new)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(target)\\b(?!\\$)" }, { "captures": { "1": { "name": "punctuation.accessor.js" }, "2": { "name": "punctuation.accessor.optional.js" }, "3": { "name": "support.variable.property.js" }, "4": { "name": "support.constant.js" } }, "match": "(?x) (?:(\\.)|(\\?\\.(?!\\s*[[:digit:]]))) \\s* (?:\n  (?:(constructor|length|prototype|__proto__)\\b(?!\\$|\\s*(<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\\())\n  |\n  (?:(EPSILON|MAX_SAFE_INTEGER|MAX_VALUE|MIN_SAFE_INTEGER|MIN_VALUE|NEGATIVE_INFINITY|POSITIVE_INFINITY)\\b(?!\\$)))" }, { "captures": { "1": { "name": "support.type.object.module.js" }, "2": { "name": "support.type.object.module.js" }, "3": { "name": "punctuation.accessor.js" }, "4": { "name": "punctuation.accessor.optional.js" }, "5": { "name": "support.type.object.module.js" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(exports)|(module)(?:(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))(exports|id|filename|loaded|parent|children))?)\\b(?!\\$)" }] }, "switch-statement": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?=\\bswitch\\s*\\()", "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.js" } }, "name": "switch-statement.expr.js", "patterns": [{ "include": "#comment" }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(switch)\\s*(\\()", "beginCaptures": { "1": { "name": "keyword.control.switch.js" }, "2": { "name": "meta.brace.round.js" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.js" } }, "name": "switch-expression.expr.js", "patterns": [{ "include": "#expression" }] }, { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.block.js" } }, "end": "(?=\\})", "name": "switch-block.expr.js", "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(case|default(?=:))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "1": { "name": "keyword.control.switch.js" } }, "end": "(?=:)", "name": "case-clause.expr.js", "patterns": [{ "include": "#expression" }] }, { "begin": "(:)\\s*(\\{)", "beginCaptures": { "1": { "name": "case-clause.expr.js punctuation.definition.section.case-statement.js" }, "2": { "name": "meta.block.js punctuation.definition.block.js" } }, "contentName": "meta.block.js", "end": "\\}", "endCaptures": { "0": { "name": "meta.block.js punctuation.definition.block.js" } }, "patterns": [{ "include": "#statements" }] }, { "captures": { "0": { "name": "case-clause.expr.js punctuation.definition.section.case-statement.js" } }, "match": "(:)" }, { "include": "#statements" }] }] }, "template": { "patterns": [{ "include": "#template-call" }, { "begin": "([_$[:alpha:]][_$[:alnum:]]*)?(`)", "beginCaptures": { "1": { "name": "entity.name.function.tagged-template.js" }, "2": { "name": "string.template.js punctuation.definition.string.template.begin.js" } }, "contentName": "string.template.js", "end": "`", "endCaptures": { "0": { "name": "string.template.js punctuation.definition.string.template.end.js" } }, "patterns": [{ "include": "#template-substitution-element" }, { "include": "#string-character-escape" }] }] }, "template-call": { "patterns": [{ "begin": "(?=(([_$[:alpha:]][_$[:alnum:]]*\\s*\\??\\.\\s*)*|(\\??\\.\\s*)?)([_$[:alpha:]][_$[:alnum:]]*)(<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?`)", "end": "(?=`)", "patterns": [{ "begin": "(?=(([_$[:alpha:]][_$[:alnum:]]*\\s*\\??\\.\\s*)*|(\\??\\.\\s*)?)([_$[:alpha:]][_$[:alnum:]]*))", "end": "(?=(<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?`)", "patterns": [{ "include": "#support-function-call-identifiers" }, { "match": "([_$[:alpha:]][_$[:alnum:]]*)", "name": "entity.name.function.tagged-template.js" }] }, { "include": "#type-arguments" }] }, { "begin": "([_$[:alpha:]][_$[:alnum:]]*)?\\s*(?=(<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)`)", "beginCaptures": { "1": { "name": "entity.name.function.tagged-template.js" } }, "end": "(?=`)", "patterns": [{ "include": "#type-arguments" }] }] }, "template-substitution-element": { "begin": "\\$\\{", "beginCaptures": { "0": { "name": "punctuation.definition.template-expression.begin.js" } }, "contentName": "meta.embedded.line.js", "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.template-expression.end.js" } }, "name": "meta.template.expression.js", "patterns": [{ "include": "#expression" }] }, "template-type": { "patterns": [{ "include": "#template-call" }, { "begin": "([_$[:alpha:]][_$[:alnum:]]*)?(`)", "beginCaptures": { "1": { "name": "entity.name.function.tagged-template.js" }, "2": { "name": "string.template.js punctuation.definition.string.template.begin.js" } }, "contentName": "string.template.js", "end": "`", "endCaptures": { "0": { "name": "string.template.js punctuation.definition.string.template.end.js" } }, "patterns": [{ "include": "#template-type-substitution-element" }, { "include": "#string-character-escape" }] }] }, "template-type-substitution-element": { "begin": "\\$\\{", "beginCaptures": { "0": { "name": "punctuation.definition.template-expression.begin.js" } }, "contentName": "meta.embedded.line.js", "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.template-expression.end.js" } }, "name": "meta.template.expression.js", "patterns": [{ "include": "#type" }] }, "ternary-expression": { "begin": "(?!\\?\\.\\s*[^[:digit:]])(\\?)(?!\\?)", "beginCaptures": { "1": { "name": "keyword.operator.ternary.js" } }, "end": "\\s*(:)", "endCaptures": { "1": { "name": "keyword.operator.ternary.js" } }, "patterns": [{ "include": "#expression" }] }, "this-literal": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))this\\b(?!\\$)", "name": "variable.language.this.js" }, "type": { "patterns": [{ "include": "#comment" }, { "include": "#type-string" }, { "include": "#numeric-literal" }, { "include": "#type-primitive" }, { "include": "#type-builtin-literals" }, { "include": "#type-parameters" }, { "include": "#type-tuple" }, { "include": "#type-object" }, { "include": "#type-operators" }, { "include": "#type-conditional" }, { "include": "#type-fn-type-parameters" }, { "include": "#type-paren-or-function-parameters" }, { "include": "#type-function-return-type" }, { "captures": { "1": { "name": "storage.modifier.js" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(readonly)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*" }, { "include": "#type-name" }] }, "type-alias-declaration": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(type)\\b\\s+([_$[:alpha:]][_$[:alnum:]]*)\\s*", "beginCaptures": { "1": { "name": "keyword.control.export.js" }, "2": { "name": "storage.modifier.js" }, "3": { "name": "storage.type.type.js" }, "4": { "name": "entity.name.type.alias.js" } }, "end": "(?=\\}|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "name": "meta.type.declaration.js", "patterns": [{ "include": "#comment" }, { "include": "#type-parameters" }, { "begin": "(=)\\s*(intrinsic)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "1": { "name": "keyword.operator.assignment.js" }, "2": { "name": "keyword.control.intrinsic.js" } }, "end": "(?=\\}|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "patterns": [{ "include": "#type" }] }, { "begin": "(=)\\s*", "beginCaptures": { "1": { "name": "keyword.operator.assignment.js" } }, "end": "(?=\\}|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "patterns": [{ "include": "#type" }] }] }, "type-annotation": { "patterns": [{ "begin": "(:)(?=\\s*\\S)", "beginCaptures": { "1": { "name": "keyword.operator.type.annotation.js" } }, "end": "(?<![:|&])(?!\\s*[|&]\\s+)((?=^|[,);\\}\\]]|//)|(?==[^>])|((?<=[\\}>\\]\\)]|[_$[:alpha:]])\\s*(?=\\{)))", "name": "meta.type.annotation.js", "patterns": [{ "include": "#type" }] }, { "begin": "(:)", "beginCaptures": { "1": { "name": "keyword.operator.type.annotation.js" } }, "end": "(?<![:|&])((?=[,);\\}\\]]|\\/\\/)|(?==[^>])|(?=^\\s*$)|((?<=[\\}>\\]\\)]|[_$[:alpha:]])\\s*(?=\\{)))", "name": "meta.type.annotation.js", "patterns": [{ "include": "#type" }] }] }, "type-arguments": { "begin": "\\<", "beginCaptures": { "0": { "name": "punctuation.definition.typeparameters.begin.js" } }, "end": "\\>", "endCaptures": { "0": { "name": "punctuation.definition.typeparameters.end.js" } }, "name": "meta.type.parameters.js", "patterns": [{ "include": "#type-arguments-body" }] }, "type-arguments-body": { "patterns": [{ "captures": { "0": { "name": "keyword.operator.type.js" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(_)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))" }, { "include": "#type" }, { "include": "#punctuation-comma" }] }, "type-builtin-literals": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(this|true|false|undefined|null|object)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "support.type.builtin.js" }, "type-conditional": { "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(extends)\\s+", "beginCaptures": { "1": { "name": "storage.modifier.js" } }, "end": "(?<=:)", "patterns": [{ "begin": "\\?", "beginCaptures": { "0": { "name": "keyword.operator.ternary.js" } }, "end": ":", "endCaptures": { "0": { "name": "keyword.operator.ternary.js" } }, "patterns": [{ "include": "#type" }] }, { "include": "#type" }] }] }, "type-fn-type-parameters": { "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(abstract)\\s+)?(new)\\b(?=\\s*\\<)", "beginCaptures": { "1": { "name": "meta.type.constructor.js storage.modifier.js" }, "2": { "name": "meta.type.constructor.js keyword.control.new.js" } }, "end": "(?<=>)", "patterns": [{ "include": "#comment" }, { "include": "#type-parameters" }] }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(abstract)\\s+)?(new)\\b\\s*(?=\\()", "beginCaptures": { "1": { "name": "storage.modifier.js" }, "2": { "name": "keyword.control.new.js" } }, "end": "(?<=\\))", "name": "meta.type.constructor.js", "patterns": [{ "include": "#function-parameters" }] }, { "begin": "(?x)(\n  (?=\n    [(]\\s*(\n      ([)]) |\n      (\\.\\.\\.) |\n      ([_$[:alnum:]]+\\s*(\n        ([:,?=])|\n        ([)]\\s*=>)\n      ))\n    )\n  )\n)", "end": "(?<=\\))", "name": "meta.type.function.js", "patterns": [{ "include": "#function-parameters" }] }] }, "type-function-return-type": { "patterns": [{ "begin": "(=>)(?=\\s*\\S)", "beginCaptures": { "1": { "name": "storage.type.function.arrow.js" } }, "end": "(?<!=>)(?<![|&])(?=[,\\]\\)\\{\\}=;>:\\?]|//|$)", "name": "meta.type.function.return.js", "patterns": [{ "include": "#type-function-return-type-core" }] }, { "begin": "=>", "beginCaptures": { "0": { "name": "storage.type.function.arrow.js" } }, "end": "(?<!=>)(?<![|&])((?=[,\\]\\)\\{\\}=;:\\?>]|//|^\\s*$)|((?<=\\S)(?=\\s*$)))", "name": "meta.type.function.return.js", "patterns": [{ "include": "#type-function-return-type-core" }] }] }, "type-function-return-type-core": { "patterns": [{ "include": "#comment" }, { "begin": "(?<==>)(?=\\s*\\{)", "end": "(?<=\\})", "patterns": [{ "include": "#type-object" }] }, { "include": "#type-predicate-operator" }, { "include": "#type" }] }, "type-infer": { "patterns": [{ "captures": { "1": { "name": "keyword.operator.expression.infer.js" }, "2": { "name": "entity.name.type.js" }, "3": { "name": "keyword.operator.expression.extends.js" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(infer)\\s+([_$[:alpha:]][_$[:alnum:]]*)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?:\\s+(extends)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))?", "name": "meta.type.infer.js" }] }, "type-name": { "patterns": [{ "begin": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(<)", "captures": { "1": { "name": "entity.name.type.module.js" }, "2": { "name": "punctuation.accessor.js" }, "3": { "name": "punctuation.accessor.optional.js" }, "4": { "name": "meta.type.parameters.js punctuation.definition.typeparameters.begin.js" } }, "contentName": "meta.type.parameters.js", "end": "(>)", "endCaptures": { "1": { "name": "meta.type.parameters.js punctuation.definition.typeparameters.end.js" } }, "patterns": [{ "include": "#type-arguments-body" }] }, { "begin": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(<)", "beginCaptures": { "1": { "name": "entity.name.type.js" }, "2": { "name": "meta.type.parameters.js punctuation.definition.typeparameters.begin.js" } }, "contentName": "meta.type.parameters.js", "end": "(>)", "endCaptures": { "1": { "name": "meta.type.parameters.js punctuation.definition.typeparameters.end.js" } }, "patterns": [{ "include": "#type-arguments-body" }] }, { "captures": { "1": { "name": "entity.name.type.module.js" }, "2": { "name": "punctuation.accessor.js" }, "3": { "name": "punctuation.accessor.optional.js" } }, "match": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))" }, { "match": "[_$[:alpha:]][_$[:alnum:]]*", "name": "entity.name.type.js" }] }, "type-object": { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.block.js" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.js" } }, "name": "meta.object.type.js", "patterns": [{ "include": "#comment" }, { "include": "#method-declaration" }, { "include": "#indexer-declaration" }, { "include": "#indexer-mapped-type-declaration" }, { "include": "#field-declaration" }, { "include": "#type-annotation" }, { "begin": "\\.\\.\\.", "beginCaptures": { "0": { "name": "keyword.operator.spread.js" } }, "end": "(?=\\}|;|,|$)|(?<=\\})", "patterns": [{ "include": "#type" }] }, { "include": "#punctuation-comma" }, { "include": "#punctuation-semicolon" }, { "include": "#type" }] }, "type-operators": { "patterns": [{ "include": "#typeof-operator" }, { "include": "#type-infer" }, { "begin": "([&|])(?=\\s*\\{)", "beginCaptures": { "0": { "name": "keyword.operator.type.js" } }, "end": "(?<=\\})", "patterns": [{ "include": "#type-object" }] }, { "begin": "[&|]", "beginCaptures": { "0": { "name": "keyword.operator.type.js" } }, "end": "(?=\\S)" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))keyof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.operator.expression.keyof.js" }, { "match": "(\\?|\\:)", "name": "keyword.operator.ternary.js" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))import(?=\\s*\\()", "name": "keyword.operator.expression.import.js" }] }, "type-parameters": { "begin": "(<)", "beginCaptures": { "1": { "name": "punctuation.definition.typeparameters.begin.js" } }, "end": "(>)", "endCaptures": { "1": { "name": "punctuation.definition.typeparameters.end.js" } }, "name": "meta.type.parameters.js", "patterns": [{ "include": "#comment" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(extends|in|out|const)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "storage.modifier.js" }, { "include": "#type" }, { "include": "#punctuation-comma" }, { "match": "(=)(?!>)", "name": "keyword.operator.assignment.js" }] }, "type-paren-or-function-parameters": { "begin": "\\(", "beginCaptures": { "0": { "name": "meta.brace.round.js" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.js" } }, "name": "meta.type.paren.cover.js", "patterns": [{ "captures": { "1": { "name": "storage.modifier.js" }, "2": { "name": "keyword.operator.rest.js" }, "3": { "name": "entity.name.function.js variable.language.this.js" }, "4": { "name": "entity.name.function.js" }, "5": { "name": "keyword.operator.optional.js" } }, "match": "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))\\s*(\\??)(?=\\s*(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))))" }, { "captures": { "1": { "name": "storage.modifier.js" }, "2": { "name": "keyword.operator.rest.js" }, "3": { "name": "variable.parameter.js variable.language.this.js" }, "4": { "name": "variable.parameter.js" }, "5": { "name": "keyword.operator.optional.js" } }, "match": "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))\\s*(\\??)(?=:)" }, { "include": "#type-annotation" }, { "match": ",", "name": "punctuation.separator.parameter.js" }, { "include": "#type" }] }, "type-predicate-operator": { "patterns": [{ "captures": { "1": { "name": "keyword.operator.type.asserts.js" }, "2": { "name": "variable.parameter.js variable.language.this.js" }, "3": { "name": "variable.parameter.js" }, "4": { "name": "keyword.operator.expression.is.js" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(asserts)\\s+)?(?!asserts)(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))\\s(is)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))" }, { "captures": { "1": { "name": "keyword.operator.type.asserts.js" }, "2": { "name": "variable.parameter.js variable.language.this.js" }, "3": { "name": "variable.parameter.js" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(asserts)\\s+(?!is)(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))asserts(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.operator.type.asserts.js" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))is(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.operator.expression.is.js" }] }, "type-primitive": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(string|number|bigint|boolean|symbol|any|void|never|unknown)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "support.type.primitive.js" }, "type-string": { "patterns": [{ "include": "#qstring-single" }, { "include": "#qstring-double" }, { "include": "#template-type" }] }, "type-tuple": { "begin": "\\[", "beginCaptures": { "0": { "name": "meta.brace.square.js" } }, "end": "\\]", "endCaptures": { "0": { "name": "meta.brace.square.js" } }, "name": "meta.type.tuple.js", "patterns": [{ "match": "\\.\\.\\.", "name": "keyword.operator.rest.js" }, { "captures": { "1": { "name": "entity.name.label.js" }, "2": { "name": "keyword.operator.optional.js" }, "3": { "name": "punctuation.separator.label.js" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))([_$[:alpha:]][_$[:alnum:]]*)\\s*(\\?)?\\s*(:)" }, { "include": "#type" }, { "include": "#punctuation-comma" }] }, "typeof-operator": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))typeof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "0": { "name": "keyword.operator.expression.typeof.js" } }, "end": "(?=[,);}\\]=>:&|{\\?]|(extends\\s+)|$|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "patterns": [{ "include": "#type-arguments" }, { "include": "#expression" }] }, "undefined-literal": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))undefined(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "constant.language.undefined.js" }, "var-expr": { "patterns": [{ "begin": "(?=(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(var|let)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))", "end": "(?!(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(var|let)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))((?=^|;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))|((?<!^let|[^\\._$[:alnum:]]let|^var|[^\\._$[:alnum:]]var)(?=\\s*$)))", "name": "meta.var.expr.js", "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(var|let)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*", "beginCaptures": { "1": { "name": "keyword.control.export.js" }, "2": { "name": "storage.modifier.js" }, "3": { "name": "storage.type.js" } }, "end": "(?=\\S)" }, { "include": "#destructuring-variable" }, { "include": "#var-single-variable" }, { "include": "#variable-initializer" }, { "include": "#comment" }, { "begin": "(,)\\s*(?=$|\\/\\/)", "beginCaptures": { "1": { "name": "punctuation.separator.comma.js" } }, "end": "(?<!,)(((?==|;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|^\\s*$))|((?<=\\S)(?=\\s*$)))", "patterns": [{ "include": "#single-line-comment-consuming-line-ending" }, { "include": "#comment" }, { "include": "#destructuring-variable" }, { "include": "#var-single-variable" }, { "include": "#punctuation-comma" }] }, { "include": "#punctuation-comma" }] }, { "begin": "(?=(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(const(?!\\s+enum\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))", "beginCaptures": { "1": { "name": "keyword.control.export.js" }, "2": { "name": "storage.modifier.js" }, "3": { "name": "storage.type.js" } }, "end": "(?!(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(const(?!\\s+enum\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))((?=^|;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))|((?<!^const|[^\\._$[:alnum:]]const)(?=\\s*$)))", "name": "meta.var.expr.js", "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(const(?!\\s+enum\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*", "beginCaptures": { "1": { "name": "keyword.control.export.js" }, "2": { "name": "storage.modifier.js" }, "3": { "name": "storage.type.js" } }, "end": "(?=\\S)" }, { "include": "#destructuring-const" }, { "include": "#var-single-const" }, { "include": "#variable-initializer" }, { "include": "#comment" }, { "begin": "(,)\\s*(?=$|\\/\\/)", "beginCaptures": { "1": { "name": "punctuation.separator.comma.js" } }, "end": "(?<!,)(((?==|;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|^\\s*$))|((?<=\\S)(?=\\s*$)))", "patterns": [{ "include": "#single-line-comment-consuming-line-ending" }, { "include": "#comment" }, { "include": "#destructuring-const" }, { "include": "#var-single-const" }, { "include": "#punctuation-comma" }] }, { "include": "#punctuation-comma" }] }, { "begin": "(?=(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b((?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))", "beginCaptures": { "1": { "name": "keyword.control.export.js" }, "2": { "name": "storage.modifier.js" }, "3": { "name": "storage.type.js" } }, "end": "(?!(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b((?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))((?=;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))|((?<!^using|[^\\._$[:alnum:]]using|^await\\s+using|[^\\._$[:alnum:]]await\\s+using)(?=\\s*$)))", "name": "meta.var.expr.js", "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b((?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*", "beginCaptures": { "1": { "name": "keyword.control.export.js" }, "2": { "name": "storage.modifier.js" }, "3": { "name": "storage.type.js" } }, "end": "(?=\\S)" }, { "include": "#var-single-const" }, { "include": "#variable-initializer" }, { "include": "#comment" }, { "begin": "(,)\\s*((?!\\S)|(?=\\/\\/))", "beginCaptures": { "1": { "name": "punctuation.separator.comma.js" } }, "end": "(?<!,)(((?==|;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|^\\s*$))|((?<=\\S)(?=\\s*$)))", "patterns": [{ "include": "#single-line-comment-consuming-line-ending" }, { "include": "#comment" }, { "include": "#var-single-const" }, { "include": "#punctuation-comma" }] }, { "include": "#punctuation-comma" }] }] }, "var-single-const": { "patterns": [{ "begin": "(?x)([_$[:alpha:]][_$[:alnum:]]*)(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))", "beginCaptures": { "1": { "name": "meta.definition.variable.js variable.other.constant.js entity.name.function.js" } }, "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|(;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b)))", "name": "meta.var-single-variable.expr.js", "patterns": [{ "include": "#var-single-variable-type-annotation" }] }, { "begin": "([_$[:alpha:]][_$[:alnum:]]*)", "beginCaptures": { "1": { "name": "meta.definition.variable.js variable.other.constant.js" } }, "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|(;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b)))", "name": "meta.var-single-variable.expr.js", "patterns": [{ "include": "#var-single-variable-type-annotation" }] }] }, "var-single-variable": { "patterns": [{ "begin": "(?x)([_$[:alpha:]][_$[:alnum:]]*)(\\!)?(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))", "beginCaptures": { "1": { "name": "meta.definition.variable.js entity.name.function.js" }, "2": { "name": "keyword.operator.definiteassignment.js" } }, "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|(;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b)))", "name": "meta.var-single-variable.expr.js", "patterns": [{ "include": "#var-single-variable-type-annotation" }] }, { "begin": "([[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])(\\!)?", "beginCaptures": { "1": { "name": "meta.definition.variable.js variable.other.constant.js" }, "2": { "name": "keyword.operator.definiteassignment.js" } }, "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|(;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b)))", "name": "meta.var-single-variable.expr.js", "patterns": [{ "include": "#var-single-variable-type-annotation" }] }, { "begin": "([_$[:alpha:]][_$[:alnum:]]*)(\\!)?", "beginCaptures": { "1": { "name": "meta.definition.variable.js variable.other.readwrite.js" }, "2": { "name": "keyword.operator.definiteassignment.js" } }, "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|(;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b)))", "name": "meta.var-single-variable.expr.js", "patterns": [{ "include": "#var-single-variable-type-annotation" }] }] }, "var-single-variable-type-annotation": { "patterns": [{ "include": "#type-annotation" }, { "include": "#string" }, { "include": "#comment" }] }, "variable-initializer": { "patterns": [{ "begin": "(?<!=|!)(=)(?!=)(?=\\s*\\S)(?!\\s*.*=>\\s*$)", "beginCaptures": { "1": { "name": "keyword.operator.assignment.js" } }, "end": "(?=$|^|[,);}\\]]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))", "patterns": [{ "include": "#expression" }] }, { "begin": "(?<!=|!)(=)(?!=)", "beginCaptures": { "1": { "name": "keyword.operator.assignment.js" } }, "end": "(?=[,);}\\]]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))|(?=^\\s*$)|(?<![\\|\\&\\+\\-\\*\\/])(?<=\\S)(?<!=)(?=\\s*$)", "patterns": [{ "include": "#expression" }] }] } }, "scopeName": "source.js", "aliases": ["js"] });
var javascript = [
  lang$n
];
var lang$m = Object.freeze({ "displayName": "CSS", "name": "css", "patterns": [{ "include": "#comment-block" }, { "include": "#escapes" }, { "include": "#combinators" }, { "include": "#selector" }, { "include": "#at-rules" }, { "include": "#rule-list" }], "repository": { "at-rules": { "patterns": [{ "begin": "\\A(?:\\xEF\\xBB\\xBF)?(?i:(?=\\s*@charset\\b))", "end": ";|(?=$)", "endCaptures": { "0": { "name": "punctuation.terminator.rule.css" } }, "name": "meta.at-rule.charset.css", "patterns": [{ "captures": { "1": { "name": "invalid.illegal.not-lowercase.charset.css" }, "2": { "name": "invalid.illegal.leading-whitespace.charset.css" }, "3": { "name": "invalid.illegal.no-whitespace.charset.css" }, "4": { "name": "invalid.illegal.whitespace.charset.css" }, "5": { "name": "invalid.illegal.not-double-quoted.charset.css" }, "6": { "name": "invalid.illegal.unclosed-string.charset.css" }, "7": { "name": "invalid.illegal.unexpected-characters.charset.css" } }, "match": '(?x)        # Possible errors:\n\\G\n((?!@charset)@\\w+)   # Not lowercase (@charset is case-sensitive)\n|\n\\G(\\s+)             # Preceding whitespace\n|\n(@charset\\S[^;]*)    # No whitespace after @charset\n|\n(?<=@charset)         # Before quoted charset name\n(\\x20{2,}|\\t+)      # More than one space used, or a tab\n|\n(?<=@charset\\x20)    # Beginning of charset name\n([^";]+)              # Not double-quoted\n|\n("[^"]+$)             # Unclosed quote\n|\n(?<=")                # After charset name\n([^;]+)               # Unexpected junk instead of semicolon' }, { "captures": { "1": { "name": "keyword.control.at-rule.charset.css" }, "2": { "name": "punctuation.definition.keyword.css" } }, "match": "((@)charset)(?=\\s)" }, { "begin": '"', "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.css" } }, "end": '"|$', "endCaptures": { "0": { "name": "punctuation.definition.string.end.css" } }, "name": "string.quoted.double.css", "patterns": [{ "begin": '(?:\\G|^)(?=(?:[^"])+$)', "end": "$", "name": "invalid.illegal.unclosed.string.css" }] }] }, { "begin": `(?i)((@)import)(?:\\s+|$|(?=['"]|/\\*))`, "beginCaptures": { "1": { "name": "keyword.control.at-rule.import.css" }, "2": { "name": "punctuation.definition.keyword.css" } }, "end": ";", "endCaptures": { "0": { "name": "punctuation.terminator.rule.css" } }, "name": "meta.at-rule.import.css", "patterns": [{ "begin": "\\G\\s*(?=/\\*)", "end": "(?<=\\*/)\\s*", "patterns": [{ "include": "#comment-block" }] }, { "include": "#string" }, { "include": "#url" }, { "include": "#media-query-list" }] }, { "begin": "(?i)((@)font-face)(?=\\s*|{|/\\*|$)", "beginCaptures": { "1": { "name": "keyword.control.at-rule.font-face.css" }, "2": { "name": "punctuation.definition.keyword.css" } }, "end": "(?!\\G)", "name": "meta.at-rule.font-face.css", "patterns": [{ "include": "#comment-block" }, { "include": "#escapes" }, { "include": "#rule-list" }] }, { "begin": "(?i)(@)page(?=[\\s:{]|/\\*|$)", "captures": { "0": { "name": "keyword.control.at-rule.page.css" }, "1": { "name": "punctuation.definition.keyword.css" } }, "end": "(?=\\s*($|[:{;]))", "name": "meta.at-rule.page.css", "patterns": [{ "include": "#rule-list" }] }, { "begin": "(?i)(?=@media(\\s|\\(|/\\*|$))", "end": "(?<=})(?!\\G)", "patterns": [{ "begin": "(?i)\\G(@)media", "beginCaptures": { "0": { "name": "keyword.control.at-rule.media.css" }, "1": { "name": "punctuation.definition.keyword.css" } }, "end": "(?=\\s*[{;])", "name": "meta.at-rule.media.header.css", "patterns": [{ "include": "#media-query-list" }] }, { "begin": "{", "beginCaptures": { "0": { "name": "punctuation.section.media.begin.bracket.curly.css" } }, "end": "}", "endCaptures": { "0": { "name": "punctuation.section.media.end.bracket.curly.css" } }, "name": "meta.at-rule.media.body.css", "patterns": [{ "include": "$self" }] }] }, { "begin": `(?i)(?=@counter-style([\\s'"{;]|/\\*|$))`, "end": "(?<=})(?!\\G)", "patterns": [{ "begin": "(?i)\\G(@)counter-style", "beginCaptures": { "0": { "name": "keyword.control.at-rule.counter-style.css" }, "1": { "name": "punctuation.definition.keyword.css" } }, "end": "(?=\\s*{)", "name": "meta.at-rule.counter-style.header.css", "patterns": [{ "include": "#comment-block" }, { "include": "#escapes" }, { "captures": { "0": { "patterns": [{ "include": "#escapes" }] } }, "match": "(?x)\n(?:[-a-zA-Z_]    | [^\\x00-\\x7F])     # First letter\n(?:[-a-zA-Z0-9_] | [^\\x00-\\x7F]      # Remainder of identifier\n  |\\\\(?:[0-9a-fA-F]{1,6}|.)\n)*", "name": "variable.parameter.style-name.css" }] }, { "begin": "{", "beginCaptures": { "0": { "name": "punctuation.section.property-list.begin.bracket.curly.css" } }, "end": "}", "endCaptures": { "0": { "name": "punctuation.section.property-list.end.bracket.curly.css" } }, "name": "meta.at-rule.counter-style.body.css", "patterns": [{ "include": "#comment-block" }, { "include": "#escapes" }, { "include": "#rule-list-innards" }] }] }, { "begin": `(?i)(?=@document([\\s'"{;]|/\\*|$))`, "end": "(?<=})(?!\\G)", "patterns": [{ "begin": "(?i)\\G(@)document", "beginCaptures": { "0": { "name": "keyword.control.at-rule.document.css" }, "1": { "name": "punctuation.definition.keyword.css" } }, "end": "(?=\\s*[{;])", "name": "meta.at-rule.document.header.css", "patterns": [{ "begin": "(?i)(?<![\\w-])(url-prefix|domain|regexp)(\\()", "beginCaptures": { "1": { "name": "support.function.document-rule.css" }, "2": { "name": "punctuation.section.function.begin.bracket.round.css" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.section.function.end.bracket.round.css" } }, "name": "meta.function.document-rule.css", "patterns": [{ "include": "#string" }, { "include": "#comment-block" }, { "include": "#escapes" }, { "match": `[^'")\\s]+`, "name": "variable.parameter.document-rule.css" }] }, { "include": "#url" }, { "include": "#commas" }, { "include": "#comment-block" }, { "include": "#escapes" }] }, { "begin": "{", "beginCaptures": { "0": { "name": "punctuation.section.document.begin.bracket.curly.css" } }, "end": "}", "endCaptures": { "0": { "name": "punctuation.section.document.end.bracket.curly.css" } }, "name": "meta.at-rule.document.body.css", "patterns": [{ "include": "$self" }] }] }, { "begin": `(?i)(?=@(?:-(?:webkit|moz|o|ms)-)?keyframes([\\s'"{;]|/\\*|$))`, "end": "(?<=})(?!\\G)", "patterns": [{ "begin": "(?i)\\G(@)(?:-(?:webkit|moz|o|ms)-)?keyframes", "beginCaptures": { "0": { "name": "keyword.control.at-rule.keyframes.css" }, "1": { "name": "punctuation.definition.keyword.css" } }, "end": "(?=\\s*{)", "name": "meta.at-rule.keyframes.header.css", "patterns": [{ "include": "#comment-block" }, { "include": "#escapes" }, { "captures": { "0": { "patterns": [{ "include": "#escapes" }] } }, "match": "(?x)\n(?:[-a-zA-Z_]    | [^\\x00-\\x7F])     # First letter\n(?:[-a-zA-Z0-9_] | [^\\x00-\\x7F]      # Remainder of identifier\n  |\\\\(?:[0-9a-fA-F]{1,6}|.)\n)*", "name": "variable.parameter.keyframe-list.css" }] }, { "begin": "{", "beginCaptures": { "0": { "name": "punctuation.section.keyframes.begin.bracket.curly.css" } }, "end": "}", "endCaptures": { "0": { "name": "punctuation.section.keyframes.end.bracket.curly.css" } }, "name": "meta.at-rule.keyframes.body.css", "patterns": [{ "include": "#comment-block" }, { "include": "#escapes" }, { "captures": { "1": { "name": "entity.other.keyframe-offset.css" }, "2": { "name": "entity.other.keyframe-offset.percentage.css" } }, "match": "(?xi)\n(?<![\\w-]) (from|to) (?![\\w-])         # Keywords for 0% | 100%\n|\n([-+]?(?:\\d+(?:\\.\\d+)?|\\.\\d+)%)     # Percentile value" }, { "include": "#rule-list" }] }] }, { "begin": "(?i)(?=@supports(\\s|\\(|/\\*|$))", "end": "(?<=})(?!\\G)|(?=;)", "patterns": [{ "begin": "(?i)\\G(@)supports", "beginCaptures": { "0": { "name": "keyword.control.at-rule.supports.css" }, "1": { "name": "punctuation.definition.keyword.css" } }, "end": "(?=\\s*[{;])", "name": "meta.at-rule.supports.header.css", "patterns": [{ "include": "#feature-query-operators" }, { "include": "#feature-query" }, { "include": "#comment-block" }, { "include": "#escapes" }] }, { "begin": "{", "beginCaptures": { "0": { "name": "punctuation.section.supports.begin.bracket.curly.css" } }, "end": "}", "endCaptures": { "0": { "name": "punctuation.section.supports.end.bracket.curly.css" } }, "name": "meta.at-rule.supports.body.css", "patterns": [{ "include": "$self" }] }] }, { "begin": `(?i)((@)(-(ms|o)-)?viewport)(?=[\\s'"{;]|/\\*|$)`, "beginCaptures": { "1": { "name": "keyword.control.at-rule.viewport.css" }, "2": { "name": "punctuation.definition.keyword.css" } }, "end": "(?=\\s*[@{;])", "name": "meta.at-rule.viewport.css", "patterns": [{ "include": "#comment-block" }, { "include": "#escapes" }] }, { "begin": `(?i)((@)font-feature-values)(?=[\\s'"{;]|/\\*|$)\\s*`, "beginCaptures": { "1": { "name": "keyword.control.at-rule.font-feature-values.css" }, "2": { "name": "punctuation.definition.keyword.css" } }, "contentName": "variable.parameter.font-name.css", "end": "(?=\\s*[@{;])", "name": "meta.at-rule.font-features.css", "patterns": [{ "include": "#comment-block" }, { "include": "#escapes" }] }, { "include": "#font-features" }, { "begin": `(?i)((@)namespace)(?=[\\s'";]|/\\*|$)`, "beginCaptures": { "1": { "name": "keyword.control.at-rule.namespace.css" }, "2": { "name": "punctuation.definition.keyword.css" } }, "end": ";|(?=[@{])", "endCaptures": { "0": { "name": "punctuation.terminator.rule.css" } }, "name": "meta.at-rule.namespace.css", "patterns": [{ "include": "#url" }, { "captures": { "1": { "patterns": [{ "include": "#comment-block" }] }, "2": { "name": "entity.name.function.namespace-prefix.css", "patterns": [{ "include": "#escapes" }] } }, "match": "(?xi)\n(?:\\G|^|(?<=\\s))\n(?=\n  (?<=\\s|^)                             # Starts with whitespace\n  (?:[-a-zA-Z_]|[^\\x00-\\x7F])          # Then a valid identifier character\n  |\n  \\s*                                   # Possible adjoining whitespace\n  /\\*(?:[^*]|\\*[^/])*\\*/              # Injected comment\n)\n(.*?)                                    # Grouped to embed #comment-block\n(\n  (?:[-a-zA-Z_]    | [^\\x00-\\x7F])     # First letter\n  (?:[-a-zA-Z0-9_] | [^\\x00-\\x7F]      # Remainder of identifier\n    |\\\\(?:[0-9a-fA-F]{1,6}|.)\n  )*\n)" }, { "include": "#comment-block" }, { "include": "#escapes" }, { "include": "#string" }] }, { "begin": "(?i)(?=@[\\w-]+[^;]+;s*$)", "end": "(?<=;)(?!\\G)", "patterns": [{ "begin": "(?i)\\G(@)[\\w-]+", "beginCaptures": { "0": { "name": "keyword.control.at-rule.css" }, "1": { "name": "punctuation.definition.keyword.css" } }, "end": ";", "endCaptures": { "0": { "name": "punctuation.terminator.rule.css" } }, "name": "meta.at-rule.header.css" }] }, { "begin": "(?i)(?=@[\\w-]+(\\s|\\(|{|/\\*|$))", "end": "(?<=})(?!\\G)", "patterns": [{ "begin": "(?i)\\G(@)[\\w-]+", "beginCaptures": { "0": { "name": "keyword.control.at-rule.css" }, "1": { "name": "punctuation.definition.keyword.css" } }, "end": "(?=\\s*[{;])", "name": "meta.at-rule.header.css" }, { "begin": "{", "beginCaptures": { "0": { "name": "punctuation.section.begin.bracket.curly.css" } }, "end": "}", "endCaptures": { "0": { "name": "punctuation.section.end.bracket.curly.css" } }, "name": "meta.at-rule.body.css", "patterns": [{ "include": "$self" }] }] }] }, "color-keywords": { "patterns": [{ "match": "(?i)(?<![\\w-])(aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow)(?![\\w-])", "name": "support.constant.color.w3c-standard-color-name.css" }, { "match": "(?xi) (?<![\\w-])\n(aliceblue|antiquewhite|aquamarine|azure|beige|bisque|blanchedalmond|blueviolet|brown|burlywood\n|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan\n|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange\n|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise\n|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen\n|gainsboro|ghostwhite|gold|goldenrod|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki\n|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow\n|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray\n|lightslategrey|lightsteelblue|lightyellow|limegreen|linen|magenta|mediumaquamarine|mediumblue\n|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise\n|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|oldlace|olivedrab|orangered\n|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum\n|powderblue|rebeccapurple|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell\n|sienna|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|thistle|tomato\n|transparent|turquoise|violet|wheat|whitesmoke|yellowgreen)\n(?![\\w-])", "name": "support.constant.color.w3c-extended-color-name.css" }, { "match": "(?i)(?<![\\w-])currentColor(?![\\w-])", "name": "support.constant.color.current.css" }, { "match": "(?xi) (?<![\\w-])\n(ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow\n|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption\n|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow\n|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText)\n(?![\\w-])", "name": "invalid.deprecated.color.system.css" }] }, "combinators": { "patterns": [{ "match": "/deep/|>>>", "name": "invalid.deprecated.combinator.css" }, { "match": ">>|>|\\+|~", "name": "keyword.operator.combinator.css" }] }, "commas": { "match": ",", "name": "punctuation.separator.list.comma.css" }, "comment-block": { "begin": "/\\*", "beginCaptures": { "0": { "name": "punctuation.definition.comment.begin.css" } }, "end": "\\*/", "endCaptures": { "0": { "name": "punctuation.definition.comment.end.css" } }, "name": "comment.block.css" }, "escapes": { "patterns": [{ "match": "\\\\[0-9a-fA-F]{1,6}", "name": "constant.character.escape.codepoint.css" }, { "begin": "\\\\$\\s*", "end": "^(?<!\\G)", "name": "constant.character.escape.newline.css" }, { "match": "\\\\.", "name": "constant.character.escape.css" }] }, "feature-query": { "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.condition.begin.bracket.round.css" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.condition.end.bracket.round.css" } }, "name": "meta.feature-query.css", "patterns": [{ "include": "#feature-query-operators" }, { "include": "#feature-query" }] }, "feature-query-operators": { "patterns": [{ "match": "(?i)(?<=[\\s()]|^|\\*/)(and|not|or)(?=[\\s()]|/\\*|$)", "name": "keyword.operator.logical.feature.$1.css" }, { "include": "#rule-list-innards" }] }, "font-features": { "begin": `(?xi)
((@)(annotation|character-variant|ornaments|styleset|stylistic|swash))
(?=[\\s@'"{;]|/\\*|$)`, "beginCaptures": { "1": { "name": "keyword.control.at-rule.${3:/downcase}.css" }, "2": { "name": "punctuation.definition.keyword.css" } }, "end": "(?<=})", "name": "meta.at-rule.${3:/downcase}.css", "patterns": [{ "begin": "{", "beginCaptures": { "0": { "name": "punctuation.section.property-list.begin.bracket.curly.css" } }, "end": "}", "endCaptures": { "0": { "name": "punctuation.section.property-list.end.bracket.curly.css" } }, "name": "meta.property-list.font-feature.css", "patterns": [{ "captures": { "0": { "patterns": [{ "include": "#escapes" }] } }, "match": "(?x)\n(?: [-a-zA-Z_]    | [^\\x00-\\x7F] )   # First letter\n(?: [-a-zA-Z0-9_] | [^\\x00-\\x7F]     # Remainder of identifier\n  | \\\\(?:[0-9a-fA-F]{1,6}|.)\n)*", "name": "variable.font-feature.css" }, { "include": "#rule-list-innards" }] }] }, "functional-pseudo-classes": { "patterns": [{ "begin": "(?i)((:)dir)(\\()", "beginCaptures": { "1": { "name": "entity.other.attribute-name.pseudo-class.css" }, "2": { "name": "punctuation.definition.entity.css" }, "3": { "name": "punctuation.section.function.begin.bracket.round.css" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.section.function.end.bracket.round.css" } }, "patterns": [{ "include": "#comment-block" }, { "include": "#escapes" }, { "match": "(?i)(?<![\\w-])(ltr|rtl)(?![\\w-])", "name": "support.constant.text-direction.css" }, { "include": "#property-values" }] }, { "begin": "(?i)((:)lang)(\\()", "beginCaptures": { "1": { "name": "entity.other.attribute-name.pseudo-class.css" }, "2": { "name": "punctuation.definition.entity.css" }, "3": { "name": "punctuation.section.function.begin.bracket.round.css" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.section.function.end.bracket.round.css" } }, "patterns": [{ "match": "(?<=[(,\\s])[a-zA-Z]+(-[a-zA-Z0-9]*|\\\\(?:[0-9a-fA-F]{1,6}|.))*(?=[),\\s])", "name": "support.constant.language-range.css" }, { "begin": '"', "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.css" } }, "end": '"', "endCaptures": { "0": { "name": "punctuation.definition.string.end.css" } }, "name": "string.quoted.double.css", "patterns": [{ "include": "#escapes" }, { "match": '(?<=["\\s])[a-zA-Z*]+(-[a-zA-Z0-9*]*)*(?=["\\s])', "name": "support.constant.language-range.css" }] }, { "begin": "'", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.css" } }, "end": "'", "endCaptures": { "0": { "name": "punctuation.definition.string.end.css" } }, "name": "string.quoted.single.css", "patterns": [{ "include": "#escapes" }, { "match": "(?<=['\\s])[a-zA-Z*]+(-[a-zA-Z0-9*]*)*(?=['\\s])", "name": "support.constant.language-range.css" }] }, { "include": "#commas" }] }, { "begin": "(?i)((:)(?:not|has|matches|where|is))(\\()", "beginCaptures": { "1": { "name": "entity.other.attribute-name.pseudo-class.css" }, "2": { "name": "punctuation.definition.entity.css" }, "3": { "name": "punctuation.section.function.begin.bracket.round.css" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.section.function.end.bracket.round.css" } }, "patterns": [{ "include": "#selector-innards" }] }, { "begin": "(?i)((:)nth-(?:last-)?(?:child|of-type))(\\()", "beginCaptures": { "1": { "name": "entity.other.attribute-name.pseudo-class.css" }, "2": { "name": "punctuation.definition.entity.css" }, "3": { "name": "punctuation.section.function.begin.bracket.round.css" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.section.function.end.bracket.round.css" } }, "patterns": [{ "match": "(?i)[+-]?(\\d+n?|n)(\\s*[+-]\\s*\\d+)?", "name": "constant.numeric.css" }, { "match": "(?i)even|odd", "name": "support.constant.parity.css" }] }] }, "functions": { "patterns": [{ "begin": "(?i)(?<![\\w-])(calc)(\\()", "beginCaptures": { "1": { "name": "support.function.calc.css" }, "2": { "name": "punctuation.section.function.begin.bracket.round.css" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.section.function.end.bracket.round.css" } }, "name": "meta.function.calc.css", "patterns": [{ "match": "[*/]|(?<=\\s|^)[-+](?=\\s|$)", "name": "keyword.operator.arithmetic.css" }, { "include": "#property-values" }] }, { "begin": "(?i)(?<![\\w-])(rgba?|rgb|hsla?|hsl|hwb|lab|oklab|lch|oklch|color)(\\()", "beginCaptures": { "1": { "name": "support.function.misc.css" }, "2": { "name": "punctuation.section.function.begin.bracket.round.css" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.section.function.end.bracket.round.css" } }, "name": "meta.function.color.css", "patterns": [{ "include": "#property-values" }] }, { "begin": '(?xi) (?<![\\w-])\n(\n  (?:-webkit-|-moz-|-o-)?    # Accept prefixed/historical variants\n  (?:repeating-)?            # "Repeating"-type gradient\n  (?:linear|radial|conic)    # Shape\n  -gradient\n)\n(\\()', "beginCaptures": { "1": { "name": "support.function.gradient.css" }, "2": { "name": "punctuation.section.function.begin.bracket.round.css" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.section.function.end.bracket.round.css" } }, "name": "meta.function.gradient.css", "patterns": [{ "match": "(?i)(?<![\\w-])(from|to|at|in|hue)(?![\\w-])", "name": "keyword.operator.gradient.css" }, { "include": "#property-values" }] }, { "begin": "(?i)(?<![\\w-])(-webkit-gradient)(\\()", "beginCaptures": { "1": { "name": "invalid.deprecated.gradient.function.css" }, "2": { "name": "punctuation.section.function.begin.bracket.round.css" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.section.function.end.bracket.round.css" } }, "name": "meta.function.gradient.invalid.deprecated.gradient.css", "patterns": [{ "begin": "(?i)(?<![\\w-])(from|to|color-stop)(\\()", "beginCaptures": { "1": { "name": "invalid.deprecated.function.css" }, "2": { "name": "punctuation.section.function.begin.bracket.round.css" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.section.function.end.bracket.round.css" } }, "patterns": [{ "include": "#property-values" }] }, { "include": "#property-values" }] }, { "begin": "(?xi) (?<![\\w-])\n(annotation|attr|blur|brightness|character-variant|clamp|contrast|counters?\n|cross-fade|drop-shadow|element|fit-content|format|grayscale|hue-rotate|color-mix\n|image-set|invert|local|max|min|minmax|opacity|ornaments|repeat|saturate|sepia\n|styleset|stylistic|swash|symbols\n|cos|sin|tan|acos|asin|atan|atan2|hypot|sqrt|pow|log|exp|abs|sign)\n(\\()", "beginCaptures": { "1": { "name": "support.function.misc.css" }, "2": { "name": "punctuation.section.function.begin.bracket.round.css" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.section.function.end.bracket.round.css" } }, "name": "meta.function.misc.css", "patterns": [{ "match": `(?i)(?<=[,\\s"]|\\*/|^)\\d+x(?=[\\s,"')]|/\\*|$)`, "name": "constant.numeric.other.density.css" }, { "include": "#property-values" }, { "match": `[^'"),\\s]+`, "name": "variable.parameter.misc.css" }] }, { "begin": "(?i)(?<![\\w-])(circle|ellipse|inset|polygon|rect)(\\()", "beginCaptures": { "1": { "name": "support.function.shape.css" }, "2": { "name": "punctuation.section.function.begin.bracket.round.css" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.section.function.end.bracket.round.css" } }, "name": "meta.function.shape.css", "patterns": [{ "match": "(?i)(?<=\\s|^|\\*/)(at|round)(?=\\s|/\\*|$)", "name": "keyword.operator.shape.css" }, { "include": "#property-values" }] }, { "begin": "(?i)(?<![\\w-])(cubic-bezier|steps)(\\()", "beginCaptures": { "1": { "name": "support.function.timing-function.css" }, "2": { "name": "punctuation.section.function.begin.bracket.round.css" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.section.function.end.bracket.round.css" } }, "name": "meta.function.timing-function.css", "patterns": [{ "match": "(?i)(?<![\\w-])(start|end)(?=\\s*\\)|$)", "name": "support.constant.step-direction.css" }, { "include": "#property-values" }] }, { "begin": "(?xi) (?<![\\w-])\n( (?:translate|scale|rotate)(?:[XYZ]|3D)?\n| matrix(?:3D)?\n| skew[XY]?\n| perspective\n)\n(\\()", "beginCaptures": { "1": { "name": "support.function.transform.css" }, "2": { "name": "punctuation.section.function.begin.bracket.round.css" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.section.function.end.bracket.round.css" } }, "patterns": [{ "include": "#property-values" }] }, { "include": "#url" }, { "begin": "(?i)(?<![\\w-])(var)(\\()", "beginCaptures": { "1": { "name": "support.function.misc.css" }, "2": { "name": "punctuation.section.function.begin.bracket.round.css" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.section.function.end.bracket.round.css" } }, "name": "meta.function.variable.css", "patterns": [{ "match": "(?x)\n--\n(?:[-a-zA-Z_]    | [^\\x00-\\x7F])     # First letter\n(?:[-a-zA-Z0-9_] | [^\\x00-\\x7F]      # Remainder of identifier\n  |\\\\(?:[0-9a-fA-F]{1,6}|.)\n)*", "name": "variable.argument.css" }, { "include": "#property-values" }] }] }, "media-feature-keywords": { "match": "(?xi)\n(?<=^|\\s|:|\\*/)\n(?: portrait                  # Orientation\n  | landscape\n  | progressive               # Scan types\n  | interlace\n  | fullscreen                # Display modes\n  | standalone\n  | minimal-ui\n  | browser\n  | hover\n)\n(?=\\s|\\)|$)", "name": "support.constant.property-value.css" }, "media-features": { "captures": { "1": { "name": "support.type.property-name.media.css" }, "2": { "name": "support.type.property-name.media.css" }, "3": { "name": "support.type.vendored.property-name.media.css" } }, "match": "(?xi)\n(?<=^|\\s|\\(|\\*/)           # Preceded by whitespace, bracket or comment\n(?:\n  # Standardised features\n  (\n    (?:min-|max-)?            # Range features\n    (?: height\n      | width\n      | aspect-ratio\n      | color\n      | color-index\n      | monochrome\n      | resolution\n    )\n    | grid                    # Discrete features\n    | scan\n    | orientation\n    | display-mode\n    | hover\n  )\n  |\n  # Deprecated features\n  (\n    (?:min-|max-)?            # Deprecated in Media Queries 4\n    device-\n    (?: height\n      | width\n      | aspect-ratio\n    )\n  )\n  |\n  # Vendor extensions\n  (\n    (?:\n      # Spec-compliant syntax\n      [-_]\n      (?: webkit              # Webkit/Blink\n        | apple|khtml         # Webkit aliases\n        | epub                # ePub3\n        | moz                 # Gecko\n        | ms                  # Microsoft\n        | o                   # Presto (pre-Opera 15)\n        | xv|ah|rim|atsc|     # Less common vendors\n          hp|tc|wap|ro\n      )\n      |\n      # Non-standard prefixes\n      (?: mso                 # Microsoft Office\n        | prince              # YesLogic\n      )\n    )\n    -\n    [\\w-]+                   # Feature name\n    (?=                       # Terminates correctly\n      \\s*                    # Possible whitespace\n      (?:                     # Possible injected comment\n        /\\*\n        (?:[^*]|\\*[^/])*\n        \\*/\n      )?\n      \\s*\n      [:)]                    # Ends with a colon or closed bracket\n    )\n  )\n)\n(?=\\s|$|[><:=]|\\)|/\\*)     # Terminates cleanly" }, "media-query": { "begin": "\\G", "end": "(?=\\s*[{;])", "patterns": [{ "include": "#comment-block" }, { "include": "#escapes" }, { "include": "#media-types" }, { "match": "(?i)(?<=\\s|^|,|\\*/)(only|not)(?=\\s|{|/\\*|$)", "name": "keyword.operator.logical.$1.media.css" }, { "match": "(?i)(?<=\\s|^|\\*/|\\))and(?=\\s|/\\*|$)", "name": "keyword.operator.logical.and.media.css" }, { "match": ",(?:(?:\\s*,)+|(?=\\s*[;){]))", "name": "invalid.illegal.comma.css" }, { "include": "#commas" }, { "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.parameters.begin.bracket.round.css" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.parameters.end.bracket.round.css" } }, "patterns": [{ "include": "#media-features" }, { "include": "#media-feature-keywords" }, { "match": ":", "name": "punctuation.separator.key-value.css" }, { "match": ">=|<=|=|<|>", "name": "keyword.operator.comparison.css" }, { "captures": { "1": { "name": "constant.numeric.css" }, "2": { "name": "keyword.operator.arithmetic.css" }, "3": { "name": "constant.numeric.css" } }, "match": "(\\d+)\\s*(/)\\s*(\\d+)", "name": "meta.ratio.css" }, { "include": "#numeric-values" }, { "include": "#comment-block" }] }] }, "media-query-list": { "begin": "(?=\\s*[^{;])", "end": "(?=\\s*[{;])", "patterns": [{ "include": "#media-query" }] }, "media-types": { "captures": { "1": { "name": "support.constant.media.css" }, "2": { "name": "invalid.deprecated.constant.media.css" } }, "match": "(?xi)\n(?<=^|\\s|,|\\*/)\n(?:\n  # Valid media types\n  (all|print|screen|speech)\n  |\n  # Deprecated in Media Queries 4: http://dev.w3.org/csswg/mediaqueries/#media-types\n  (aural|braille|embossed|handheld|projection|tty|tv)\n)\n(?=$|[{,\\s;]|/\\*)" }, "numeric-values": { "patterns": [{ "captures": { "1": { "name": "punctuation.definition.constant.css" } }, "match": "(#)(?:[0-9a-fA-F]{3,4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})\\b", "name": "constant.other.color.rgb-value.hex.css" }, { "captures": { "1": { "name": "keyword.other.unit.percentage.css" }, "2": { "name": "keyword.other.unit.${2:/downcase}.css" } }, "match": "(?xi) (?<![\\w-])\n[-+]?                               # Sign indicator\n\n(?:                                 # Numerals\n    [0-9]+ (?:\\.[0-9]+)?           # Integer/float with leading digits\n  | \\.[0-9]+                       # Float without leading digits\n)\n\n(?:                                 # Scientific notation\n  (?<=[0-9])                        # Exponent must follow a digit\n  E                                 # Exponent indicator\n  [-+]?                             # Possible sign indicator\n  [0-9]+                            # Exponent value\n)?\n\n(?:                                 # Possible unit for data-type:\n  (%)                               # - Percentage\n  | ( deg|grad|rad|turn             # - Angle\n    | Hz|kHz                        # - Frequency\n    | ch|cm|em|ex|fr|in|mm|mozmm|   # - Length\n      pc|pt|px|q|rem|rch|rex|rlh|\n      ic|ric|rcap|vh|vw|vb|vi|svh|\n      svw|svb|svi|dvh|dvw|dvb|dvi|\n      lvh|lvw|lvb|lvi|vmax|vmin|\n      cqw|cqi|cqh|cqb|cqmin|cqmax\n    | dpi|dpcm|dppx                 # - Resolution\n    | s|ms                          # - Time\n    )\n  \\b                               # Boundary checking intentionally lax to\n)?                                  # facilitate embedding in CSS-like grammars", "name": "constant.numeric.css" }] }, "property-keywords": { "patterns": [{ "match": "(?xi) (?<![\\w-])\n(above|absolute|active|add|additive|after-edge|alias|all|all-petite-caps|all-scroll|all-small-caps|alpha|alphabetic|alternate|alternate-reverse\n|always|antialiased|auto|auto-fill|auto-fit|auto-pos|available|avoid|avoid-column|avoid-page|avoid-region|backwards|balance|baseline|before-edge|below|bevel\n|bidi-override|blink|block|block-axis|block-start|block-end|bold|bolder|border|border-box|both|bottom|bottom-outside|break-all|break-word|bullets\n|butt|capitalize|caption|cell|center|central|char|circle|clip|clone|close-quote|closest-corner|closest-side|col-resize|collapse|color|color-burn\n|color-dodge|column|column-reverse|common-ligatures|compact|condensed|contain|content|content-box|contents|context-menu|contextual|copy|cover\n|crisp-edges|crispEdges|crosshair|cyclic|dark|darken|dashed|decimal|default|dense|diagonal-fractions|difference|digits|disabled|disc|discretionary-ligatures\n|distribute|distribute-all-lines|distribute-letter|distribute-space|dot|dotted|double|double-circle|downleft|downright|e-resize|each-line|ease|ease-in\n|ease-in-out|ease-out|economy|ellipse|ellipsis|embed|end|evenodd|ew-resize|exact|exclude|exclusion|expanded|extends|extra-condensed|extra-expanded\n|fallback|farthest-corner|farthest-side|fill|fill-available|fill-box|filled|fit-content|fixed|flat|flex|flex-end|flex-start|flip|flow-root|forwards|freeze\n|from-image|full-width|geometricPrecision|georgian|grab|grabbing|grayscale|grid|groove|hand|hanging|hard-light|help|hidden|hide\n|historical-forms|historical-ligatures|horizontal|horizontal-tb|hue|icon|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space\n|ideographic|inactive|infinite|inherit|initial|inline|inline-axis|inline-block|inline-end|inline-flex|inline-grid|inline-list-item|inline-start\n|inline-table|inset|inside|inter-character|inter-ideograph|inter-word|intersect|invert|isolate|isolate-override|italic|jis04|jis78|jis83\n|jis90|justify|justify-all|kannada|keep-all|landscape|large|larger|left|light|lighten|lighter|line|line-edge|line-through|linear|linearRGB\n|lining-nums|list-item|local|loose|lowercase|lr|lr-tb|ltr|luminance|luminosity|main-size|mandatory|manipulation|manual|margin-box|match-parent\n|match-source|mathematical|max-content|medium|menu|message-box|middle|min-content|miter|mixed|move|multiply|n-resize|narrower|ne-resize\n|nearest-neighbor|nesw-resize|newspaper|no-change|no-clip|no-close-quote|no-common-ligatures|no-contextual|no-discretionary-ligatures\n|no-drop|no-historical-ligatures|no-open-quote|no-repeat|none|nonzero|normal|not-allowed|nowrap|ns-resize|numbers|numeric|nw-resize|nwse-resize\n|oblique|oldstyle-nums|open|open-quote|optimizeLegibility|optimizeQuality|optimizeSpeed|optional|ordinal|outset|outside|over|overlay|overline|padding\n|padding-box|page|painted|pan-down|pan-left|pan-right|pan-up|pan-x|pan-y|paused|petite-caps|pixelated|plaintext|pointer|portrait|pre|pre-line\n|pre-wrap|preserve-3d|progress|progressive|proportional-nums|proportional-width|proximity|radial|recto|region|relative|remove|repeat|repeat-[xy]\n|reset-size|reverse|revert|ridge|right|rl|rl-tb|round|row|row-resize|row-reverse|row-severse|rtl|ruby|ruby-base|ruby-base-container|ruby-text\n|ruby-text-container|run-in|running|s-resize|saturation|scale-down|screen|scroll|scroll-position|se-resize|semi-condensed|semi-expanded|separate\n|sesame|show|sideways|sideways-left|sideways-lr|sideways-right|sideways-rl|simplified|slashed-zero|slice|small|small-caps|small-caption|smaller\n|smooth|soft-light|solid|space|space-around|space-between|space-evenly|spell-out|square|sRGB|stacked-fractions|start|static|status-bar|swap\n|step-end|step-start|sticky|stretch|strict|stroke|stroke-box|style|sub|subgrid|subpixel-antialiased|subtract|super|sw-resize|symbolic|table\n|table-caption|table-cell|table-column|table-column-group|table-footer-group|table-header-group|table-row|table-row-group|tabular-nums|tb|tb-rl\n|text|text-after-edge|text-before-edge|text-bottom|text-top|thick|thin|titling-caps|top|top-outside|touch|traditional|transparent|triangle\n|ultra-condensed|ultra-expanded|under|underline|unicase|unset|upleft|uppercase|upright|use-glyph-orientation|use-script|verso|vertical\n|vertical-ideographic|vertical-lr|vertical-rl|vertical-text|view-box|visible|visibleFill|visiblePainted|visibleStroke|w-resize|wait|wavy\n|weight|whitespace|wider|words|wrap|wrap-reverse|x|x-large|x-small|xx-large|xx-small|y|zero|zoom-in|zoom-out)\n(?![\\w-])", "name": "support.constant.property-value.css" }, { "match": "(?xi) (?<![\\w-])\n(arabic-indic|armenian|bengali|cambodian|circle|cjk-decimal|cjk-earthly-branch|cjk-heavenly-stem|cjk-ideographic\n|decimal|decimal-leading-zero|devanagari|disc|disclosure-closed|disclosure-open|ethiopic-halehame-am\n|ethiopic-halehame-ti-e[rt]|ethiopic-numeric|georgian|gujarati|gurmukhi|hangul|hangul-consonant|hebrew\n|hiragana|hiragana-iroha|japanese-formal|japanese-informal|kannada|katakana|katakana-iroha|khmer\n|korean-hangul-formal|korean-hanja-formal|korean-hanja-informal|lao|lower-alpha|lower-armenian|lower-greek\n|lower-latin|lower-roman|malayalam|mongolian|myanmar|oriya|persian|simp-chinese-formal|simp-chinese-informal\n|square|tamil|telugu|thai|tibetan|trad-chinese-formal|trad-chinese-informal|upper-alpha|upper-armenian\n|upper-latin|upper-roman|urdu)\n(?![\\w-])", "name": "support.constant.property-value.list-style-type.css" }, { "match": "(?<![\\w-])(?i:-(?:ah|apple|atsc|epub|hp|khtml|moz|ms|o|rim|ro|tc|wap|webkit|xv)|(?:mso|prince))-[a-zA-Z-]+", "name": "support.constant.vendored.property-value.css" }, { "match": "(?<![\\w-])(?i:arial|century|comic|courier|garamond|georgia|helvetica|impact|lucida|symbol|system-ui|system|tahoma|times|trebuchet|ui-monospace|ui-rounded|ui-sans-serif|ui-serif|utopia|verdana|webdings|sans-serif|serif|monospace)(?![\\w-])", "name": "support.constant.font-name.css" }] }, "property-names": { "patterns": [{ "match": "(?xi) (?<![\\w-])\n(?:\n  # Standard CSS\n  accent-color|additive-symbols|align-content|align-items|align-self|all|animation|animation-delay|animation-direction|animation-duration\n  | animation-fill-mode|animation-iteration-count|animation-name|animation-play-state|animation-timing-function|backdrop-filter\n  | backface-visibility|background|background-attachment|background-blend-mode|background-clip|background-color|background-image\n  | background-origin|background-position|background-position-[xy]|background-repeat|background-size|bleed|block-size|border\n  | border-block-end|border-block-end-color|border-block-end-style|border-block-end-width|border-block-start|border-block-start-color\n  | border-block-start-style|border-block-start-width|border-bottom|border-bottom-color|border-bottom-left-radius|border-bottom-right-radius\n  | border-bottom-style|border-bottom-width|border-collapse|border-color|border-end-end-radius|border-end-start-radius|border-image\n  | border-image-outset|border-image-repeat|border-image-slice|border-image-source|border-image-width|border-inline-end\n  | border-inline-end-color|border-inline-end-style|border-inline-end-width|border-inline-start|border-inline-start-color\n  | border-inline-start-style|border-inline-start-width|border-left|border-left-color|border-left-style|border-left-width\n  | border-radius|border-right|border-right-color|border-right-style|border-right-width|border-spacing|border-start-end-radius\n  | border-start-start-radius|border-style|border-top|border-top-color|border-top-left-radius|border-top-right-radius|border-top-style\n  | border-top-width|border-width|bottom|box-decoration-break|box-shadow|box-sizing|break-after|break-before|break-inside|caption-side\n  | caret-color|clear|clip|clip-path|clip-rule|color|color-adjust|color-interpolation-filters|color-scheme|column-count|column-fill|column-gap\n  | column-rule|column-rule-color|column-rule-style|column-rule-width|column-span|column-width|columns|contain|container|container-name|container-type|content|counter-increment\n  | counter-reset|cursor|direction|display|empty-cells|enable-background|fallback|fill|fill-opacity|fill-rule|filter|flex|flex-basis\n  | flex-direction|flex-flow|flex-grow|flex-shrink|flex-wrap|float|flood-color|flood-opacity|font|font-display|font-family\n  | font-feature-settings|font-kerning|font-language-override|font-optical-sizing|font-size|font-size-adjust|font-stretch\n  | font-style|font-synthesis|font-variant|font-variant-alternates|font-variant-caps|font-variant-east-asian|font-variant-ligatures\n  | font-variant-numeric|font-variant-position|font-variation-settings|font-weight|gap|glyph-orientation-horizontal|glyph-orientation-vertical\n  | grid|grid-area|grid-auto-columns|grid-auto-flow|grid-auto-rows|grid-column|grid-column-end|grid-column-gap|grid-column-start\n  | grid-gap|grid-row|grid-row-end|grid-row-gap|grid-row-start|grid-template|grid-template-areas|grid-template-columns|grid-template-rows\n  | hanging-punctuation|height|hyphens|image-orientation|image-rendering|image-resolution|ime-mode|initial-letter|initial-letter-align\n  | inline-size|inset|inset-block|inset-block-end|inset-block-start|inset-inline|inset-inline-end|inset-inline-start|isolation\n  | justify-content|justify-items|justify-self|kerning|left|letter-spacing|lighting-color|line-break|line-clamp|line-height|list-style\n  | list-style-image|list-style-position|list-style-type|margin|margin-block|margin-block-end|margin-block-start|margin-bottom|margin-inline|margin-inline-end|margin-inline-start\n  | margin-left|margin-right|margin-top|marker-end|marker-mid|marker-start|marks|mask|mask-border|mask-border-mode|mask-border-outset\n  | mask-border-repeat|mask-border-slice|mask-border-source|mask-border-width|mask-clip|mask-composite|mask-image|mask-mode\n  | mask-origin|mask-position|mask-repeat|mask-size|mask-type|max-block-size|max-height|max-inline-size|max-lines|max-width\n  | max-zoom|min-block-size|min-height|min-inline-size|min-width|min-zoom|mix-blend-mode|negative|object-fit|object-position\n  | offset|offset-anchor|offset-distance|offset-path|offset-position|offset-rotation|opacity|order|orientation|orphans\n  | outline|outline-color|outline-offset|outline-style|outline-width|overflow|overflow-anchor|overflow-block|overflow-inline\n  | overflow-wrap|overflow-[xy]|overscroll-behavior|overscroll-behavior-block|overscroll-behavior-inline|overscroll-behavior-[xy]\n  | pad|padding|padding-block|padding-block-end|padding-block-start|padding-bottom|padding-inline|padding-inline-end|padding-inline-start|padding-left\n  | padding-right|padding-top|page-break-after|page-break-before|page-break-inside|paint-order|perspective|perspective-origin\n  | place-content|place-items|place-self|pointer-events|position|prefix|quotes|range|resize|right|rotate|row-gap|ruby-align\n  | ruby-merge|ruby-position|scale|scroll-behavior|scroll-margin|scroll-margin-block|scroll-margin-block-end|scroll-margin-block-start\n  | scroll-margin-bottom|scroll-margin-inline|scroll-margin-inline-end|scroll-margin-inline-start|scroll-margin-left|scroll-margin-right\n  | scroll-margin-top|scroll-padding|scroll-padding-block|scroll-padding-block-end|scroll-padding-block-start|scroll-padding-bottom\n  | scroll-padding-inline|scroll-padding-inline-end|scroll-padding-inline-start|scroll-padding-left|scroll-padding-right\n  | scroll-padding-top|scroll-snap-align|scroll-snap-coordinate|scroll-snap-destination|scroll-snap-stop|scroll-snap-type\n  | scrollbar-color|scrollbar-gutter|scrollbar-width|shape-image-threshold|shape-margin|shape-outside|shape-rendering|size\n  | speak-as|src|stop-color|stop-opacity|stroke|stroke-dasharray|stroke-dashoffset|stroke-linecap|stroke-linejoin|stroke-miterlimit\n  | stroke-opacity|stroke-width|suffix|symbols|system|tab-size|table-layout|text-align|text-align-last|text-anchor|text-combine-upright\n  | text-decoration|text-decoration-color|text-decoration-line|text-decoration-skip|text-decoration-skip-ink|text-decoration-style|text-decoration-thickness\n  | text-emphasis|text-emphasis-color|text-emphasis-position|text-emphasis-style|text-indent|text-justify|text-orientation\n  | text-overflow|text-rendering|text-shadow|text-size-adjust|text-transform|text-underline-offset|text-underline-position|top|touch-action|transform\n  | transform-box|transform-origin|transform-style|transition|transition-delay|transition-duration|transition-property|transition-timing-function\n  | translate|unicode-bidi|unicode-range|user-select|user-zoom|vertical-align|visibility|white-space|widows|width|will-change\n  | word-break|word-spacing|word-wrap|writing-mode|z-index|zoom\n\n  # SVG attributes\n  | alignment-baseline|baseline-shift|clip-rule|color-interpolation|color-interpolation-filters|color-profile\n  | color-rendering|cx|cy|dominant-baseline|enable-background|fill|fill-opacity|fill-rule|flood-color|flood-opacity\n  | glyph-orientation-horizontal|glyph-orientation-vertical|height|kerning|lighting-color|marker-end|marker-mid\n  | marker-start|r|rx|ry|shape-rendering|stop-color|stop-opacity|stroke|stroke-dasharray|stroke-dashoffset|stroke-linecap\n  | stroke-linejoin|stroke-miterlimit|stroke-opacity|stroke-width|text-anchor|width|x|y\n\n  # Not listed on MDN; presumably deprecated\n  | adjust|after|align|align-last|alignment|alignment-adjust|appearance|attachment|azimuth|background-break\n  | balance|baseline|before|bidi|binding|bookmark|bookmark-label|bookmark-level|bookmark-target|border-length\n  | bottom-color|bottom-left-radius|bottom-right-radius|bottom-style|bottom-width|box|box-align|box-direction\n  | box-flex|box-flex-group|box-lines|box-ordinal-group|box-orient|box-pack|break|character|collapse|column\n  | column-break-after|column-break-before|count|counter|crop|cue|cue-after|cue-before|decoration|decoration-break\n  | delay|display-model|display-role|down|drop|drop-initial-after-adjust|drop-initial-after-align|drop-initial-before-adjust\n  | drop-initial-before-align|drop-initial-size|drop-initial-value|duration|elevation|emphasis|family|fit|fit-position\n  | flex-group|float-offset|gap|grid-columns|grid-rows|hanging-punctuation|header|hyphenate|hyphenate-after|hyphenate-before\n  | hyphenate-character|hyphenate-lines|hyphenate-resource|icon|image|increment|indent|index|initial-after-adjust\n  | initial-after-align|initial-before-adjust|initial-before-align|initial-size|initial-value|inline-box-align|iteration-count\n  | justify|label|left-color|left-style|left-width|length|level|line|line-stacking|line-stacking-ruby|line-stacking-shift\n  | line-stacking-strategy|lines|list|mark|mark-after|mark-before|marks|marquee|marquee-direction|marquee-play-count|marquee-speed\n  | marquee-style|max|min|model|move-to|name|nav|nav-down|nav-index|nav-left|nav-right|nav-up|new|numeral|offset|ordinal-group\n  | orient|origin|overflow-style|overhang|pack|page|page-policy|pause|pause-after|pause-before|phonemes|pitch|pitch-range\n  | play-count|play-during|play-state|point|presentation|presentation-level|profile|property|punctuation|punctuation-trim\n  | radius|rate|rendering-intent|repeat|replace|reset|resolution|resource|respond-to|rest|rest-after|rest-before|richness\n  | right-color|right-style|right-width|role|rotation|rotation-point|rows|ruby|ruby-overhang|ruby-span|rule|rule-color\n  | rule-style|rule-width|shadow|size|size-adjust|sizing|space|space-collapse|spacing|span|speak|speak-header|speak-numeral\n  | speak-punctuation|speech|speech-rate|speed|stacking|stacking-ruby|stacking-shift|stacking-strategy|stress|stretch\n  | string-set|style|style-image|style-position|style-type|target|target-name|target-new|target-position|text|text-height\n  | text-justify|text-outline|text-replace|text-wrap|timing-function|top-color|top-left-radius|top-right-radius|top-style\n  | top-width|trim|unicode|up|user-select|variant|voice|voice-balance|voice-duration|voice-family|voice-pitch|voice-pitch-range\n  | voice-rate|voice-stress|voice-volume|volume|weight|white|white-space-collapse|word|wrap\n)\n(?![\\w-])", "name": "support.type.property-name.css" }, { "match": "(?<![\\w-])(?i:-(?:ah|apple|atsc|epub|hp|khtml|moz|ms|o|rim|ro|tc|wap|webkit|xv)|(?:mso|prince))-[a-zA-Z-]+", "name": "support.type.vendored.property-name.css" }] }, "property-values": { "patterns": [{ "include": "#commas" }, { "include": "#comment-block" }, { "include": "#escapes" }, { "include": "#functions" }, { "include": "#property-keywords" }, { "include": "#unicode-range" }, { "include": "#numeric-values" }, { "include": "#color-keywords" }, { "include": "#string" }, { "match": "!\\s*important(?![\\w-])", "name": "keyword.other.important.css" }] }, "pseudo-classes": { "captures": { "1": { "name": "punctuation.definition.entity.css" }, "2": { "name": "invalid.illegal.colon.css" } }, "match": "(?xi)\n(:)(:*)\n(?: active|any-link|checked|default|disabled|empty|enabled|first\n  | (?:first|last|only)-(?:child|of-type)|focus|focus-visible|focus-within|fullscreen|host|hover\n  | in-range|indeterminate|invalid|left|link|optional|out-of-range\n  | read-only|read-write|required|right|root|scope|target|unresolved\n  | valid|visited\n)(?![\\w-]|\\s*[;}])", "name": "entity.other.attribute-name.pseudo-class.css" }, "pseudo-elements": { "captures": { "1": { "name": "punctuation.definition.entity.css" }, "2": { "name": "punctuation.definition.entity.css" } }, "match": "(?xi)\n(?:\n  (::?)                       # Elements using both : and :: notation\n  (?: after\n    | before\n    | first-letter\n    | first-line\n    | (?:-(?:ah|apple|atsc|epub|hp|khtml|moz\n            |ms|o|rim|ro|tc|wap|webkit|xv)\n        | (?:mso|prince))\n      -[a-z-]+\n  )\n  |\n  (::)                        # Double-colon only\n  (?: backdrop\n    | content\n    | grammar-error\n    | marker\n    | placeholder\n    | selection\n    | shadow\n    | spelling-error\n  )\n)\n(?![\\w-]|\\s*[;}])", "name": "entity.other.attribute-name.pseudo-element.css" }, "rule-list": { "begin": "{", "beginCaptures": { "0": { "name": "punctuation.section.property-list.begin.bracket.curly.css" } }, "end": "}", "endCaptures": { "0": { "name": "punctuation.section.property-list.end.bracket.curly.css" } }, "name": "meta.property-list.css", "patterns": [{ "include": "#rule-list-innards" }] }, "rule-list-innards": { "patterns": [{ "include": "#comment-block" }, { "include": "#escapes" }, { "include": "#font-features" }, { "match": "(?x) (?<![\\w-])\n--\n(?:[-a-zA-Z_]    | [^\\x00-\\x7F])     # First letter\n(?:[-a-zA-Z0-9_] | [^\\x00-\\x7F]      # Remainder of identifier\n  |\\\\(?:[0-9a-fA-F]{1,6}|.)\n)*", "name": "variable.css" }, { "begin": "(?<![-a-zA-Z])(?=[-a-zA-Z])", "end": "$|(?![-a-zA-Z])", "name": "meta.property-name.css", "patterns": [{ "include": "#property-names" }] }, { "begin": "(:)\\s*", "beginCaptures": { "1": { "name": "punctuation.separator.key-value.css" } }, "contentName": "meta.property-value.css", "end": "\\s*(;)|\\s*(?=}|\\))", "endCaptures": { "1": { "name": "punctuation.terminator.rule.css" } }, "patterns": [{ "include": "#comment-block" }, { "include": "#property-values" }] }, { "match": ";", "name": "punctuation.terminator.rule.css" }] }, "selector": { "begin": "(?x)\n(?=\n  (?:\\|)?                    # Possible anonymous namespace prefix\n  (?:\n    [-\\[:.*\\#a-zA-Z_]       # Valid selector character\n    |\n    [^\\x00-\\x7F]            # Which can include non-ASCII symbols\n    |\n    \\\\                      # Or an escape sequence\n    (?:[0-9a-fA-F]{1,6}|.)\n  )\n)", "end": "(?=\\s*[/@{)])", "name": "meta.selector.css", "patterns": [{ "include": "#selector-innards" }] }, "selector-innards": { "patterns": [{ "include": "#comment-block" }, { "include": "#commas" }, { "include": "#escapes" }, { "include": "#combinators" }, { "captures": { "1": { "name": "entity.other.namespace-prefix.css" }, "2": { "name": "punctuation.separator.css" } }, "match": "(?x)\n(?:^|(?<=[\\s,(};]))         # Follows whitespace, comma, semicolon, or bracket\n(?!\n  [-\\w*]+\n  \\|\n  (?!\n      [-\\[:.*\\#a-zA-Z_]    # Make sure there's a selector to match\n    | [^\\x00-\\x7F]\n  )\n)\n(\n  (?: [-a-zA-Z_]    | [^\\x00-\\x7F] )   # First letter\n  (?: [-a-zA-Z0-9_] | [^\\x00-\\x7F]     # Remainder of identifier\n    | \\\\(?:[0-9a-fA-F]{1,6}|.)\n  )*\n  |\n  \\*     # Universal namespace\n)?\n(\\|)     # Namespace separator" }, { "include": "#tag-names" }, { "match": "\\*", "name": "entity.name.tag.wildcard.css" }, { "captures": { "1": { "name": "punctuation.definition.entity.css" }, "2": { "patterns": [{ "include": "#escapes" }] } }, "match": "(?x) (?<![@\\w-])\n([.\\#])\n# Invalid identifier\n(\n  (?:\n    # Starts with ASCII digits, with possible hyphen preceding it\n    -?[0-9]\n    |\n    # Consists of a hyphen only\n    -                                      # Terminated by either:\n    (?= $                                  # - End-of-line\n      | [\\s,.\\#)\\[:{>+~|]               # - Followed by another selector\n      | /\\*                               # - Followed by a block comment\n    )\n    |\n    # Name contains unescaped ASCII symbol\n    (?:                                    # Check for acceptable preceding characters\n        [-a-zA-Z_0-9]|[^\\x00-\\x7F]       # - Valid selector character\n      | \\\\(?:[0-9a-fA-F]{1,6}|.)         # - Escape sequence\n    )*\n    (?:                                    # Invalid punctuation\n      [!\"'%&(*;<?@^`|\\]}]                 # - NOTE: We exempt `)` from the list of checked\n      |                                    #   symbols to avoid matching `:not(.invalid)`\n      / (?!\\*)                            # - Avoid invalidating the start of a comment\n    )+\n  )\n  # Mark remainder of selector invalid\n  (?: [-a-zA-Z_0-9]|[^\\x00-\\x7F]         # - Otherwise valid identifier characters\n    | \\\\(?:[0-9a-fA-F]{1,6}|.)           # - Escape sequence\n  )*\n)", "name": "invalid.illegal.bad-identifier.css" }, { "captures": { "1": { "name": "punctuation.definition.entity.css" }, "2": { "patterns": [{ "include": "#escapes" }] } }, "match": "(?x)\n(\\.)                                  # Valid class-name\n(\n  (?: [-a-zA-Z_0-9]|[^\\x00-\\x7F]     # Valid identifier characters\n    | \\\\(?:[0-9a-fA-F]{1,6}|.)       # Escape sequence\n  )+\n)                                      # Followed by either:\n(?= $                                  # - End of the line\n  | [\\s,.\\#)\\[:{>+~|]               # - Another selector\n  | /\\*                               # - A block comment\n)", "name": "entity.other.attribute-name.class.css" }, { "captures": { "1": { "name": "punctuation.definition.entity.css" }, "2": { "patterns": [{ "include": "#escapes" }] } }, "match": "(?x)\n(\\#)\n(\n  -?\n  (?![0-9])\n  (?:[-a-zA-Z0-9_]|[^\\x00-\\x7F]|\\\\(?:[0-9a-fA-F]{1,6}|.))+\n)\n(?=$|[\\s,.\\#)\\[:{>+~|]|/\\*)", "name": "entity.other.attribute-name.id.css" }, { "begin": "\\[", "beginCaptures": { "0": { "name": "punctuation.definition.entity.begin.bracket.square.css" } }, "end": "\\]", "endCaptures": { "0": { "name": "punctuation.definition.entity.end.bracket.square.css" } }, "name": "meta.attribute-selector.css", "patterns": [{ "include": "#comment-block" }, { "include": "#string" }, { "captures": { "1": { "name": "storage.modifier.ignore-case.css" } }, "match": `(?<=["'\\s]|^|\\*/)\\s*([iI])\\s*(?=[\\s\\]]|/\\*|$)` }, { "captures": { "1": { "name": "string.unquoted.attribute-value.css", "patterns": [{ "include": "#escapes" }] } }, "match": `(?x)(?<==)\\s*((?!/\\*)(?:[^\\\\"'\\s\\]]|\\\\.)+)` }, { "include": "#escapes" }, { "match": "[~|^$*]?=", "name": "keyword.operator.pattern.css" }, { "match": "\\|", "name": "punctuation.separator.css" }, { "captures": { "1": { "name": "entity.other.namespace-prefix.css", "patterns": [{ "include": "#escapes" }] } }, "match": "(?x)\n# Qualified namespace prefix\n( -?(?!\\d)(?:[\\w-]|[^\\x00-\\x7F]|\\\\(?:[0-9a-fA-F]{1,6}|.))+\n| \\*\n)\n# Lookahead to ensure there's a valid identifier ahead\n(?=\n  \\| (?!\\s|=|$|\\])\n  (?: -?(?!\\d)\n   |   [\\\\\\w-]\n   |   [^\\x00-\\x7F]\n   )\n)" }, { "captures": { "1": { "name": "entity.other.attribute-name.css", "patterns": [{ "include": "#escapes" }] } }, "match": "(?x)\n(-?(?!\\d)(?>[\\w-]|[^\\x00-\\x7F]|\\\\(?:[0-9a-fA-F]{1,6}|.))+)\n\\s*\n(?=[~|^\\]$*=]|/\\*)" }] }, { "include": "#pseudo-classes" }, { "include": "#pseudo-elements" }, { "include": "#functional-pseudo-classes" }, { "match": "(?x) (?<![@\\w-])\n(?=            # Custom element names must:\n  [a-z]        # - start with a lowercase ASCII letter,\n  \\w* -       # - contain at least one dash\n)\n(?:\n  (?![A-Z])    # No uppercase ASCII letters are allowed\n  [\\w-]       # Allow any other word character or dash\n)+\n(?![(\\w-])", "name": "entity.name.tag.custom.css" }] }, "string": { "patterns": [{ "begin": '"', "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.css" } }, "end": '"|(?<!\\\\)(?=$|\\n)', "endCaptures": { "0": { "name": "punctuation.definition.string.end.css" } }, "name": "string.quoted.double.css", "patterns": [{ "begin": '(?:\\G|^)(?=(?:[^\\\\"]|\\\\.)+$)', "end": "$", "name": "invalid.illegal.unclosed.string.css", "patterns": [{ "include": "#escapes" }] }, { "include": "#escapes" }] }, { "begin": "'", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.css" } }, "end": "'|(?<!\\\\)(?=$|\\n)", "endCaptures": { "0": { "name": "punctuation.definition.string.end.css" } }, "name": "string.quoted.single.css", "patterns": [{ "begin": "(?:\\G|^)(?=(?:[^\\\\']|\\\\.)+$)", "end": "$", "name": "invalid.illegal.unclosed.string.css", "patterns": [{ "include": "#escapes" }] }, { "include": "#escapes" }] }] }, "tag-names": { "match": "(?xi) (?<![\\w:-])\n(?:\n    # HTML\n    a|abbr|acronym|address|applet|area|article|aside|audio|b|base|basefont|bdi|bdo|bgsound\n  | big|blink|blockquote|body|br|button|canvas|caption|center|cite|code|col|colgroup|command\n  | content|data|datalist|dd|del|details|dfn|dialog|dir|div|dl|dt|element|em|embed|fieldset\n  | figcaption|figure|font|footer|form|frame|frameset|h[1-6]|head|header|hgroup|hr|html|i\n  | iframe|image|img|input|ins|isindex|kbd|keygen|label|legend|li|link|listing|main|map|mark\n  | marquee|math|menu|menuitem|meta|meter|multicol|nav|nextid|nobr|noembed|noframes|noscript\n  | object|ol|optgroup|option|output|p|param|picture|plaintext|pre|progress|q|rb|rp|rt|rtc\n  | ruby|s|samp|script|section|select|shadow|slot|small|source|spacer|span|strike|strong\n  | style|sub|summary|sup|table|tbody|td|template|textarea|tfoot|th|thead|time|title|tr\n  | track|tt|u|ul|var|video|wbr|xmp\n\n  # SVG\n  | altGlyph|altGlyphDef|altGlyphItem|animate|animateColor|animateMotion|animateTransform\n  | circle|clipPath|color-profile|cursor|defs|desc|discard|ellipse|feBlend|feColorMatrix\n  | feComponentTransfer|feComposite|feConvolveMatrix|feDiffuseLighting|feDisplacementMap\n  | feDistantLight|feDropShadow|feFlood|feFuncA|feFuncB|feFuncG|feFuncR|feGaussianBlur\n  | feImage|feMerge|feMergeNode|feMorphology|feOffset|fePointLight|feSpecularLighting\n  | feSpotLight|feTile|feTurbulence|filter|font-face|font-face-format|font-face-name\n  | font-face-src|font-face-uri|foreignObject|g|glyph|glyphRef|hatch|hatchpath|hkern\n  | line|linearGradient|marker|mask|mesh|meshgradient|meshpatch|meshrow|metadata\n  | missing-glyph|mpath|path|pattern|polygon|polyline|radialGradient|rect|set|solidcolor\n  | stop|svg|switch|symbol|text|textPath|tref|tspan|use|view|vkern\n\n  # MathML\n  | annotation|annotation-xml|maction|maligngroup|malignmark|math|menclose|merror|mfenced\n  | mfrac|mglyph|mi|mlabeledtr|mlongdiv|mmultiscripts|mn|mo|mover|mpadded|mphantom|mroot\n  | mrow|ms|mscarries|mscarry|msgroup|msline|mspace|msqrt|msrow|mstack|mstyle|msub|msubsup\n  | msup|mtable|mtd|mtext|mtr|munder|munderover|semantics\n)\n(?=[+~>\\s,.\\#|){:\\[]|/\\*|$)", "name": "entity.name.tag.css" }, "unicode-range": { "captures": { "0": { "name": "constant.other.unicode-range.css" }, "1": { "name": "punctuation.separator.dash.unicode-range.css" } }, "match": "(?<![\\w-])[Uu]\\+[0-9A-Fa-f?]{1,6}(?:(-)[0-9A-Fa-f]{1,6})?(?![\\w-])" }, "url": { "begin": "(?i)(?<![\\w@-])(url)(\\()", "beginCaptures": { "1": { "name": "support.function.url.css" }, "2": { "name": "punctuation.section.function.begin.bracket.round.css" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.section.function.end.bracket.round.css" } }, "name": "meta.function.url.css", "patterns": [{ "match": `[^'")\\s]+`, "name": "variable.parameter.url.css" }, { "include": "#string" }, { "include": "#comment-block" }, { "include": "#escapes" }] } }, "scopeName": "source.css" });
var css = [
  lang$m
];
var lang$l = Object.freeze({ "displayName": "HTML", "injections": { "R:text.html - (comment.block, text.html meta.embedded, meta.tag.*.*.html, meta.tag.*.*.*.html, meta.tag.*.*.*.*.html)": { "comment": "Uses R: to ensure this matches after any other injections.", "patterns": [{ "match": "<", "name": "invalid.illegal.bad-angle-bracket.html" }] } }, "name": "html", "patterns": [{ "include": "#xml-processing" }, { "include": "#comment" }, { "include": "#doctype" }, { "include": "#cdata" }, { "include": "#tags-valid" }, { "include": "#tags-invalid" }, { "include": "#entities" }], "repository": { "attribute": { "patterns": [{ "begin": "(s(hape|cope|t(ep|art)|ize(s)?|p(ellcheck|an)|elected|lot|andbox|rc(set|doc|lang)?)|h(ttp-equiv|i(dden|gh)|e(ight|aders)|ref(lang)?)|n(o(nce|validate|module)|ame)|c(h(ecked|arset)|ite|o(nt(ent(editable)?|rols)|ords|l(s(pan)?|or))|lass|rossorigin)|t(ype(mustmatch)?|itle|a(rget|bindex)|ranslate)|i(s(map)?|n(tegrity|putmode)|tem(scope|type|id|prop|ref)|d)|op(timum|en)|d(i(sabled|r(name)?)|ownload|e(coding|f(er|ault))|at(etime|a)|raggable)|usemap|p(ing|oster|la(ysinline|ceholder)|attern|reload)|enctype|value|kind|for(m(novalidate|target|enctype|action|method)?)?|w(idth|rap)|l(ist|o(op|w)|a(ng|bel))|a(s(ync)?|c(ce(sskey|pt(-charset)?)|tion)|uto(c(omplete|apitalize)|play|focus)|l(t|low(usermedia|paymentrequest|fullscreen))|bbr)|r(ows(pan)?|e(versed|quired|ferrerpolicy|l|adonly))|m(in(length)?|u(ted|ltiple)|e(thod|dia)|a(nifest|x(length)?)))(?![\\w:-])", "beginCaptures": { "0": { "name": "entity.other.attribute-name.html" } }, "comment": "HTML5 attributes, not event handlers", "end": "(?=\\s*+[^=\\s])", "name": "meta.attribute.$1.html", "patterns": [{ "include": "#attribute-interior" }] }, { "begin": "style(?![\\w:-])", "beginCaptures": { "0": { "name": "entity.other.attribute-name.html" } }, "comment": "HTML5 style attribute", "end": "(?=\\s*+[^=\\s])", "name": "meta.attribute.style.html", "patterns": [{ "begin": "=", "beginCaptures": { "0": { "name": "punctuation.separator.key-value.html" } }, "end": "(?<=[^\\s=])(?!\\s*=)|(?=/?>)", "patterns": [{ "begin": "(?=[^\\s=<>`/]|/(?!>))", "end": "(?!\\G)", "name": "meta.embedded.line.css", "patterns": [{ "captures": { "0": { "name": "source.css" } }, "match": "([^\\s\"'=<>`/]|/(?!>))+", "name": "string.unquoted.html" }, { "begin": '"', "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.html" } }, "contentName": "source.css", "end": '(")', "endCaptures": { "0": { "name": "punctuation.definition.string.end.html" }, "1": { "name": "source.css" } }, "name": "string.quoted.double.html", "patterns": [{ "include": "#entities" }] }, { "begin": "'", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.html" } }, "contentName": "source.css", "end": "(')", "endCaptures": { "0": { "name": "punctuation.definition.string.end.html" }, "1": { "name": "source.css" } }, "name": "string.quoted.single.html", "patterns": [{ "include": "#entities" }] }] }, { "match": "=", "name": "invalid.illegal.unexpected-equals-sign.html" }] }] }, { "begin": "on(s(croll|t(orage|alled)|u(spend|bmit)|e(curitypolicyviolation|ek(ing|ed)|lect))|hashchange|c(hange|o(ntextmenu|py)|u(t|echange)|l(ick|ose)|an(cel|play(through)?))|t(imeupdate|oggle)|in(put|valid)|o(nline|ffline)|d(urationchange|r(op|ag(start|over|e(n(ter|d)|xit)|leave)?)|blclick)|un(handledrejection|load)|p(opstate|lay(ing)?|a(ste|use|ge(show|hide))|rogress)|e(nded|rror|mptied)|volumechange|key(down|up|press)|focus|w(heel|aiting)|l(oad(start|e(nd|d(data|metadata)))?|anguagechange)|a(uxclick|fterprint|bort)|r(e(s(ize|et)|jectionhandled)|atechange)|m(ouse(o(ut|ver)|down|up|enter|leave|move)|essage(error)?)|b(efore(unload|print)|lur))(?![\\w:-])", "beginCaptures": { "0": { "name": "entity.other.attribute-name.html" } }, "comment": "HTML5 attributes, event handlers", "end": "(?=\\s*+[^=\\s])", "name": "meta.attribute.event-handler.$1.html", "patterns": [{ "begin": "=", "beginCaptures": { "0": { "name": "punctuation.separator.key-value.html" } }, "end": "(?<=[^\\s=])(?!\\s*=)|(?=/?>)", "patterns": [{ "begin": "(?=[^\\s=<>`/]|/(?!>))", "end": "(?!\\G)", "name": "meta.embedded.line.js", "patterns": [{ "captures": { "0": { "name": "source.js" }, "1": { "patterns": [{ "include": "source.js" }] } }, "match": "(([^\\s\"'=<>`/]|/(?!>))+)", "name": "string.unquoted.html" }, { "begin": '"', "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.html" } }, "contentName": "source.js", "end": '(")', "endCaptures": { "0": { "name": "punctuation.definition.string.end.html" }, "1": { "name": "source.js" } }, "name": "string.quoted.double.html", "patterns": [{ "captures": { "0": { "patterns": [{ "include": "source.js" }] } }, "match": '([^\\n"/]|/(?![/*]))+' }, { "begin": "//", "beginCaptures": { "0": { "name": "punctuation.definition.comment.js" } }, "end": '(?=")|\\n', "name": "comment.line.double-slash.js" }, { "begin": "/\\*", "beginCaptures": { "0": { "name": "punctuation.definition.comment.begin.js" } }, "end": '(?=")|\\*/', "endCaptures": { "0": { "name": "punctuation.definition.comment.end.js" } }, "name": "comment.block.js" }] }, { "begin": "'", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.html" } }, "contentName": "source.js", "end": "(')", "endCaptures": { "0": { "name": "punctuation.definition.string.end.html" }, "1": { "name": "source.js" } }, "name": "string.quoted.single.html", "patterns": [{ "captures": { "0": { "patterns": [{ "include": "source.js" }] } }, "match": "([^\\n'/]|/(?![/*]))+" }, { "begin": "//", "beginCaptures": { "0": { "name": "punctuation.definition.comment.js" } }, "end": "(?=')|\\n", "name": "comment.line.double-slash.js" }, { "begin": "/\\*", "beginCaptures": { "0": { "name": "punctuation.definition.comment.begin.js" } }, "end": "(?=')|\\*/", "endCaptures": { "0": { "name": "punctuation.definition.comment.end.js" } }, "name": "comment.block.js" }] }] }, { "match": "=", "name": "invalid.illegal.unexpected-equals-sign.html" }] }] }, { "begin": "(data-[a-z\\-]+)(?![\\w:-])", "beginCaptures": { "0": { "name": "entity.other.attribute-name.html" } }, "comment": "HTML5 attributes, data-*", "end": "(?=\\s*+[^=\\s])", "name": "meta.attribute.data-x.$1.html", "patterns": [{ "include": "#attribute-interior" }] }, { "begin": "(align|bgcolor|border)(?![\\w:-])", "beginCaptures": { "0": { "name": "invalid.deprecated.entity.other.attribute-name.html" } }, "comment": "HTML attributes, deprecated", "end": "(?=\\s*+[^=\\s])", "name": "meta.attribute.$1.html", "patterns": [{ "include": "#attribute-interior" }] }, { "begin": `([^\\x{0020}"'<>/=\\x{0000}-\\x{001F}\\x{007F}-\\x{009F}\\x{FDD0}-\\x{FDEF}\\x{FFFE}\\x{FFFF}\\x{1FFFE}\\x{1FFFF}\\x{2FFFE}\\x{2FFFF}\\x{3FFFE}\\x{3FFFF}\\x{4FFFE}\\x{4FFFF}\\x{5FFFE}\\x{5FFFF}\\x{6FFFE}\\x{6FFFF}\\x{7FFFE}\\x{7FFFF}\\x{8FFFE}\\x{8FFFF}\\x{9FFFE}\\x{9FFFF}\\x{AFFFE}\\x{AFFFF}\\x{BFFFE}\\x{BFFFF}\\x{CFFFE}\\x{CFFFF}\\x{DFFFE}\\x{DFFFF}\\x{EFFFE}\\x{EFFFF}\\x{FFFFE}\\x{FFFFF}\\x{10FFFE}\\x{10FFFF}]+)`, "beginCaptures": { "0": { "name": "entity.other.attribute-name.html" } }, "comment": "Anything else that is valid", "end": "(?=\\s*+[^=\\s])", "name": "meta.attribute.unrecognized.$1.html", "patterns": [{ "include": "#attribute-interior" }] }, { "match": "[^\\s>]+", "name": "invalid.illegal.character-not-allowed-here.html" }] }, "attribute-interior": { "patterns": [{ "begin": "=", "beginCaptures": { "0": { "name": "punctuation.separator.key-value.html" } }, "end": "(?<=[^\\s=])(?!\\s*=)|(?=/?>)", "patterns": [{ "match": "([^\\s\"'=<>`/]|/(?!>))+", "name": "string.unquoted.html" }, { "begin": '"', "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.html" } }, "end": '"', "endCaptures": { "0": { "name": "punctuation.definition.string.end.html" } }, "name": "string.quoted.double.html", "patterns": [{ "include": "#entities" }] }, { "begin": "'", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.html" } }, "end": "'", "endCaptures": { "0": { "name": "punctuation.definition.string.end.html" } }, "name": "string.quoted.single.html", "patterns": [{ "include": "#entities" }] }, { "match": "=", "name": "invalid.illegal.unexpected-equals-sign.html" }] }] }, "cdata": { "begin": "<!\\[CDATA\\[", "beginCaptures": { "0": { "name": "punctuation.definition.tag.begin.html" } }, "contentName": "string.other.inline-data.html", "end": "]]>", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.metadata.cdata.html" }, "comment": { "begin": "<!--", "captures": { "0": { "name": "punctuation.definition.comment.html" } }, "end": "-->", "name": "comment.block.html", "patterns": [{ "match": "\\G-?>", "name": "invalid.illegal.characters-not-allowed-here.html" }, { "match": "<!--(?!>)|<!-(?=-->)", "name": "invalid.illegal.characters-not-allowed-here.html" }, { "match": "--!>", "name": "invalid.illegal.characters-not-allowed-here.html" }] }, "core-minus-invalid": { "comment": "This should be the root pattern array includes minus #tags-invalid", "patterns": [{ "include": "#xml-processing" }, { "include": "#comment" }, { "include": "#doctype" }, { "include": "#cdata" }, { "include": "#tags-valid" }, { "include": "#entities" }] }, "doctype": { "begin": "<!(?=(?i:DOCTYPE\\s))", "beginCaptures": { "0": { "name": "punctuation.definition.tag.begin.html" } }, "end": ">", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.metadata.doctype.html", "patterns": [{ "match": "\\G(?i:DOCTYPE)", "name": "entity.name.tag.html" }, { "begin": '"', "end": '"', "name": "string.quoted.double.html" }, { "match": "[^\\s>]+", "name": "entity.other.attribute-name.html" }] }, "entities": { "patterns": [{ "captures": { "1": { "name": "punctuation.definition.entity.html" }, "912": { "name": "punctuation.definition.entity.html" } }, "comment": "Yes this is a bit ridiculous, there are quite a lot of these", "match": "(?x)\n						(&)	(?=[a-zA-Z])\n						(\n							(a(s(ymp(eq)?|cr|t)|n(d(slope|d|v|and)?|g(s(t|ph)|zarr|e|le|rt(vb(d)?)?|msd(a(h|c|d|e|f|a|g|b))?)?)|c(y|irc|d|ute|E)?|tilde|o(pf|gon)|uml|p(id|os|prox(eq)?|e|E|acir)?|elig|f(r)?|w(conint|int)|l(pha|e(ph|fsym))|acute|ring|grave|m(p|a(cr|lg))|breve)|A(s(sign|cr)|nd|MP|c(y|irc)|tilde|o(pf|gon)|uml|pplyFunction|fr|Elig|lpha|acute|ring|grave|macr|breve))\n						  | (B(scr|cy|opf|umpeq|e(cause|ta|rnoullis)|fr|a(ckslash|r(v|wed))|reve)|b(s(cr|im(e)?|ol(hsub|b)?|emi)|n(ot|e(quiv)?)|c(y|ong)|ig(s(tar|qcup)|c(irc|up|ap)|triangle(down|up)|o(times|dot|plus)|uplus|vee|wedge)|o(t(tom)?|pf|wtie|x(h(d|u|D|U)?|times|H(d|u|D|U)?|d(R|l|r|L)|u(R|l|r|L)|plus|D(R|l|r|L)|v(R|h|H|l|r|L)?|U(R|l|r|L)|V(R|h|H|l|r|L)?|minus|box))|Not|dquo|u(ll(et)?|mp(e(q)?|E)?)|prime|e(caus(e)?|t(h|ween|a)|psi|rnou|mptyv)|karow|fr|l(ock|k(1(2|4)|34)|a(nk|ck(square|triangle(down|left|right)?|lozenge)))|a(ck(sim(eq)?|cong|prime|epsilon)|r(vee|wed(ge)?))|r(eve|vbar)|brk(tbrk)?))\n						  | (c(s(cr|u(p(e)?|b(e)?))|h(cy|i|eck(mark)?)|ylcty|c(irc|ups(sm)?|edil|a(ps|ron))|tdot|ir(scir|c(eq|le(d(R|circ|S|dash|ast)|arrow(left|right)))?|e|fnint|E|mid)?|o(n(int|g(dot)?)|p(y(sr)?|f|rod)|lon(e(q)?)?|m(p(fn|le(xes|ment))?|ma(t)?))|dot|u(darr(l|r)|p(s|c(up|ap)|or|dot|brcap)?|e(sc|pr)|vee|wed|larr(p)?|r(vearrow(left|right)|ly(eq(succ|prec)|vee|wedge)|arr(m)?|ren))|e(nt(erdot)?|dil|mptyv)|fr|w(conint|int)|lubs(uit)?|a(cute|p(s|c(up|ap)|dot|and|brcup)?|r(on|et))|r(oss|arr))|C(scr|hi|c(irc|onint|edil|aron)|ircle(Minus|Times|Dot|Plus)|Hcy|o(n(tourIntegral|int|gruent)|unterClockwiseContourIntegral|p(f|roduct)|lon(e)?)|dot|up(Cap)?|OPY|e(nterDot|dilla)|fr|lo(seCurly(DoubleQuote|Quote)|ckwiseContourIntegral)|a(yleys|cute|p(italDifferentialD)?)|ross))\n						  | (d(s(c(y|r)|trok|ol)|har(l|r)|c(y|aron)|t(dot|ri(f)?)|i(sin|e|v(ide(ontimes)?|onx)?|am(s|ond(suit)?)?|gamma)|Har|z(cy|igrarr)|o(t(square|plus|eq(dot)?|minus)?|ublebarwedge|pf|wn(harpoon(left|right)|downarrows|arrow)|llar)|d(otseq|a(rr|gger))?|u(har|arr)|jcy|e(lta|g|mptyv)|f(isht|r)|wangle|lc(orn|rop)|a(sh(v)?|leth|rr|gger)|r(c(orn|rop)|bkarow)|b(karow|lac)|Arr)|D(s(cr|trok)|c(y|aron)|Scy|i(fferentialD|a(critical(Grave|Tilde|Do(t|ubleAcute)|Acute)|mond))|o(t(Dot|Equal)?|uble(Right(Tee|Arrow)|ContourIntegral|Do(t|wnArrow)|Up(DownArrow|Arrow)|VerticalBar|L(ong(RightArrow|Left(RightArrow|Arrow))|eft(RightArrow|Tee|Arrow)))|pf|wn(Right(TeeVector|Vector(Bar)?)|Breve|Tee(Arrow)?|arrow|Left(RightVector|TeeVector|Vector(Bar)?)|Arrow(Bar|UpArrow)?))|Zcy|el(ta)?|D(otrahd)?|Jcy|fr|a(shv|rr|gger)))\n						  | (e(s(cr|im|dot)|n(sp|g)|c(y|ir(c)?|olon|aron)|t(h|a)|o(pf|gon)|dot|u(ro|ml)|p(si(v|lon)?|lus|ar(sl)?)|e|D(ot|Dot)|q(s(im|lant(less|gtr))|c(irc|olon)|u(iv(DD)?|est|als)|vparsl)|f(Dot|r)|l(s(dot)?|inters|l)?|a(ster|cute)|r(Dot|arr)|g(s(dot)?|rave)?|x(cl|ist|p(onentiale|ectation))|m(sp(1(3|4))?|pty(set|v)?|acr))|E(s(cr|im)|c(y|irc|aron)|ta|o(pf|gon)|NG|dot|uml|TH|psilon|qu(ilibrium|al(Tilde)?)|fr|lement|acute|grave|x(ists|ponentialE)|m(pty(SmallSquare|VerySmallSquare)|acr)))\n						  | (f(scr|nof|cy|ilig|o(pf|r(k(v)?|all))|jlig|partint|emale|f(ilig|l(ig|lig)|r)|l(tns|lig|at)|allingdotseq|r(own|a(sl|c(1(2|8|3|4|5|6)|78|2(3|5)|3(8|4|5)|45|5(8|6)))))|F(scr|cy|illed(SmallSquare|VerySmallSquare)|o(uriertrf|pf|rAll)|fr))\n						  | (G(scr|c(y|irc|edil)|t|opf|dot|T|Jcy|fr|amma(d)?|reater(Greater|SlantEqual|Tilde|Equal(Less)?|FullEqual|Less)|g|breve)|g(s(cr|im(e|l)?)|n(sim|e(q(q)?)?|E|ap(prox)?)|c(y|irc)|t(c(c|ir)|dot|quest|lPar|r(sim|dot|eq(qless|less)|less|a(pprox|rr)))?|imel|opf|dot|jcy|e(s(cc|dot(o(l)?)?|l(es)?)?|q(slant|q)?|l)?|v(nE|ertneqq)|fr|E(l)?|l(j|E|a)?|a(cute|p|mma(d)?)|rave|g(g)?|breve))\n						  | (h(s(cr|trok|lash)|y(phen|bull)|circ|o(ok(leftarrow|rightarrow)|pf|arr|rbar|mtht)|e(llip|arts(uit)?|rcon)|ks(earow|warow)|fr|a(irsp|lf|r(dcy|r(cir|w)?)|milt)|bar|Arr)|H(s(cr|trok)|circ|ilbertSpace|o(pf|rizontalLine)|ump(DownHump|Equal)|fr|a(cek|t)|ARDcy))\n						  | (i(s(cr|in(s(v)?|dot|v|E)?)|n(care|t(cal|prod|e(rcal|gers)|larhk)?|odot|fin(tie)?)?|c(y|irc)?|t(ilde)?|i(nfin|i(nt|int)|ota)?|o(cy|ta|pf|gon)|u(kcy|ml)|jlig|prod|e(cy|xcl)|quest|f(f|r)|acute|grave|m(of|ped|a(cr|th|g(part|e|line))))|I(scr|n(t(e(rsection|gral))?|visible(Comma|Times))|c(y|irc)|tilde|o(ta|pf|gon)|dot|u(kcy|ml)|Ocy|Jlig|fr|Ecy|acute|grave|m(plies|a(cr|ginaryI))?))\n						  | (j(s(cr|ercy)|c(y|irc)|opf|ukcy|fr|math)|J(s(cr|ercy)|c(y|irc)|opf|ukcy|fr))\n						  | (k(scr|hcy|c(y|edil)|opf|jcy|fr|appa(v)?|green)|K(scr|c(y|edil)|Hcy|opf|Jcy|fr|appa))\n						  | (l(s(h|cr|trok|im(e|g)?|q(uo(r)?|b)|aquo)|h(ar(d|u(l)?)|blk)|n(sim|e(q(q)?)?|E|ap(prox)?)|c(y|ub|e(il|dil)|aron)|Barr|t(hree|c(c|ir)|imes|dot|quest|larr|r(i(e|f)?|Par))?|Har|o(ng(left(arrow|rightarrow)|rightarrow|mapsto)|times|z(enge|f)?|oparrow(left|right)|p(f|lus|ar)|w(ast|bar)|a(ng|rr)|brk)|d(sh|ca|quo(r)?|r(dhar|ushar))|ur(dshar|uhar)|jcy|par(lt)?|e(s(s(sim|dot|eq(qgtr|gtr)|approx|gtr)|cc|dot(o(r)?)?|g(es)?)?|q(slant|q)?|ft(harpoon(down|up)|threetimes|leftarrows|arrow(tail)?|right(squigarrow|harpoons|arrow(s)?))|g)?|v(nE|ertneqq)|f(isht|loor|r)|E(g)?|l(hard|corner|tri|arr)?|a(ng(d|le)?|cute|t(e(s)?|ail)?|p|emptyv|quo|rr(sim|hk|tl|pl|fs|lp|b(fs)?)?|gran|mbda)|r(har(d)?|corner|tri|arr|m)|g(E)?|m(idot|oust(ache)?)|b(arr|r(k(sl(d|u)|e)|ac(e|k))|brk)|A(tail|arr|rr))|L(s(h|cr|trok)|c(y|edil|aron)|t|o(ng(RightArrow|left(arrow|rightarrow)|rightarrow|Left(RightArrow|Arrow))|pf|wer(RightArrow|LeftArrow))|T|e(ss(Greater|SlantEqual|Tilde|EqualGreater|FullEqual|Less)|ft(Right(Vector|Arrow)|Ceiling|T(ee(Vector|Arrow)?|riangle(Bar|Equal)?)|Do(ubleBracket|wn(TeeVector|Vector(Bar)?))|Up(TeeVector|DownVector|Vector(Bar)?)|Vector(Bar)?|arrow|rightarrow|Floor|A(ngleBracket|rrow(RightArrow|Bar)?)))|Jcy|fr|l(eftarrow)?|a(ng|cute|placetrf|rr|mbda)|midot))\n						  | (M(scr|cy|inusPlus|opf|u|e(diumSpace|llintrf)|fr|ap)|m(s(cr|tpos)|ho|nplus|c(y|omma)|i(nus(d(u)?|b)?|cro|d(cir|dot|ast)?)|o(dels|pf)|dash|u(ltimap|map)?|p|easuredangle|DDot|fr|l(cp|dr)|a(cr|p(sto(down|up|left)?)?|l(t(ese)?|e)|rker)))\n						  | (n(s(hort(parallel|mid)|c(cue|e|r)?|im(e(q)?)?|u(cc(eq)?|p(set(eq(q)?)?|e|E)?|b(set(eq(q)?)?|e|E)?)|par|qsu(pe|be)|mid)|Rightarrow|h(par|arr|Arr)|G(t(v)?|g)|c(y|ong(dot)?|up|edil|a(p|ron))|t(ilde|lg|riangle(left(eq)?|right(eq)?)|gl)|i(s(d)?|v)?|o(t(ni(v(c|a|b))?|in(dot|v(c|a|b)|E)?)?|pf)|dash|u(m(sp|ero)?)?|jcy|p(olint|ar(sl|t|allel)?|r(cue|e(c(eq)?)?)?)|e(s(im|ear)|dot|quiv|ar(hk|r(ow)?)|xist(s)?|Arr)?|v(sim|infin|Harr|dash|Dash|l(t(rie)?|e|Arr)|ap|r(trie|Arr)|g(t|e))|fr|w(near|ar(hk|r(ow)?)|Arr)|V(dash|Dash)|l(sim|t(ri(e)?)?|dr|e(s(s)?|q(slant|q)?|ft(arrow|rightarrow))?|E|arr|Arr)|a(ng|cute|tur(al(s)?)?|p(id|os|prox|E)?|bla)|r(tri(e)?|ightarrow|arr(c|w)?|Arr)|g(sim|t(r)?|e(s|q(slant|q)?)?|E)|mid|L(t(v)?|eft(arrow|rightarrow)|l)|b(sp|ump(e)?))|N(scr|c(y|edil|aron)|tilde|o(nBreakingSpace|Break|t(R(ightTriangle(Bar|Equal)?|everseElement)|Greater(Greater|SlantEqual|Tilde|Equal|FullEqual|Less)?|S(u(cceeds(SlantEqual|Tilde|Equal)?|perset(Equal)?|bset(Equal)?)|quareSu(perset(Equal)?|bset(Equal)?))|Hump(DownHump|Equal)|Nested(GreaterGreater|LessLess)|C(ongruent|upCap)|Tilde(Tilde|Equal|FullEqual)?|DoubleVerticalBar|Precedes(SlantEqual|Equal)?|E(qual(Tilde)?|lement|xists)|VerticalBar|Le(ss(Greater|SlantEqual|Tilde|Equal|Less)?|ftTriangle(Bar|Equal)?))?|pf)|u|e(sted(GreaterGreater|LessLess)|wLine|gative(MediumSpace|Thi(nSpace|ckSpace)|VeryThinSpace))|Jcy|fr|acute))\n						  | (o(s(cr|ol|lash)|h(m|bar)|c(y|ir(c)?)|ti(lde|mes(as)?)|S|int|opf|d(sold|iv|ot|ash|blac)|uml|p(erp|lus|ar)|elig|vbar|f(cir|r)|l(c(ir|ross)|t|ine|arr)|a(st|cute)|r(slope|igof|or|d(er(of)?|f|m)?|v|arr)?|g(t|on|rave)|m(i(nus|cron|d)|ega|acr))|O(s(cr|lash)|c(y|irc)|ti(lde|mes)|opf|dblac|uml|penCurly(DoubleQuote|Quote)|ver(B(ar|rac(e|ket))|Parenthesis)|fr|Elig|acute|r|grave|m(icron|ega|acr)))\n						  | (p(s(cr|i)|h(i(v)?|one|mmat)|cy|i(tchfork|v)?|o(intint|und|pf)|uncsp|er(cnt|tenk|iod|p|mil)|fr|l(us(sim|cir|two|d(o|u)|e|acir|mn|b)?|an(ck(h)?|kv))|ar(s(im|l)|t|a(llel)?)?|r(sim|n(sim|E|ap)|cue|ime(s)?|o(d|p(to)?|f(surf|line|alar))|urel|e(c(sim|n(sim|eqq|approx)|curlyeq|eq|approx)?)?|E|ap)?|m)|P(s(cr|i)|hi|cy|i|o(incareplane|pf)|fr|lusMinus|artialD|r(ime|o(duct|portion(al)?)|ecedes(SlantEqual|Tilde|Equal)?)?))\n						  | (q(scr|int|opf|u(ot|est(eq)?|at(int|ernions))|prime|fr)|Q(scr|opf|UOT|fr))\n						  | (R(s(h|cr)|ho|c(y|edil|aron)|Barr|ight(Ceiling|T(ee(Vector|Arrow)?|riangle(Bar|Equal)?)|Do(ubleBracket|wn(TeeVector|Vector(Bar)?))|Up(TeeVector|DownVector|Vector(Bar)?)|Vector(Bar)?|arrow|Floor|A(ngleBracket|rrow(Bar|LeftArrow)?))|o(undImplies|pf)|uleDelayed|e(verse(UpEquilibrium|E(quilibrium|lement)))?|fr|EG|a(ng|cute|rr(tl)?)|rightarrow)|r(s(h|cr|q(uo(r)?|b)|aquo)|h(o(v)?|ar(d|u(l)?))|nmid|c(y|ub|e(il|dil)|aron)|Barr|t(hree|imes|ri(e|f|ltri)?)|i(singdotseq|ng|ght(squigarrow|harpoon(down|up)|threetimes|left(harpoons|arrows)|arrow(tail)?|rightarrows))|Har|o(times|p(f|lus|ar)|a(ng|rr)|brk)|d(sh|ca|quo(r)?|ldhar)|uluhar|p(polint|ar(gt)?)|e(ct|al(s|ine|part)?|g)|f(isht|loor|r)|l(har|arr|m)|a(ng(d|e|le)?|c(ute|e)|t(io(nals)?|ail)|dic|emptyv|quo|rr(sim|hk|c|tl|pl|fs|w|lp|ap|b(fs)?)?)|rarr|x|moust(ache)?|b(arr|r(k(sl(d|u)|e)|ac(e|k))|brk)|A(tail|arr|rr)))\n						  | (s(s(cr|tarf|etmn|mile)|h(y|c(hcy|y)|ort(parallel|mid)|arp)|c(sim|y|n(sim|E|ap)|cue|irc|polint|e(dil)?|E|a(p|ron))?|t(ar(f)?|r(ns|aight(phi|epsilon)))|i(gma(v|f)?|m(ne|dot|plus|e(q)?|l(E)?|rarr|g(E)?)?)|zlig|o(pf|ftcy|l(b(ar)?)?)|dot(e|b)?|u(ng|cc(sim|n(sim|eqq|approx)|curlyeq|eq|approx)?|p(s(im|u(p|b)|et(neq(q)?|eq(q)?)?)|hs(ol|ub)|1|n(e|E)|2|d(sub|ot)|3|plus|e(dot)?|E|larr|mult)?|m|b(s(im|u(p|b)|et(neq(q)?|eq(q)?)?)|n(e|E)|dot|plus|e(dot)?|E|rarr|mult)?)|pa(des(uit)?|r)|e(swar|ct|tm(n|inus)|ar(hk|r(ow)?)|xt|mi|Arr)|q(su(p(set(eq)?|e)?|b(set(eq)?|e)?)|c(up(s)?|ap(s)?)|u(f|ar(e|f))?)|fr(own)?|w(nwar|ar(hk|r(ow)?)|Arr)|larr|acute|rarr|m(t(e(s)?)?|i(d|le)|eparsl|a(shp|llsetminus))|bquo)|S(scr|hort(RightArrow|DownArrow|UpArrow|LeftArrow)|c(y|irc|edil|aron)?|tar|igma|H(cy|CHcy)|opf|u(c(hThat|ceeds(SlantEqual|Tilde|Equal)?)|p(set|erset(Equal)?)?|m|b(set(Equal)?)?)|OFTcy|q(uare(Su(perset(Equal)?|bset(Equal)?)|Intersection|Union)?|rt)|fr|acute|mallCircle))\n						  | (t(s(hcy|c(y|r)|trok)|h(i(nsp|ck(sim|approx))|orn|e(ta(sym|v)?|re(4|fore))|k(sim|ap))|c(y|edil|aron)|i(nt|lde|mes(d|b(ar)?)?)|o(sa|p(cir|f(ork)?|bot)?|ea)|dot|prime|elrec|fr|w(ixt|ohead(leftarrow|rightarrow))|a(u|rget)|r(i(sb|time|dot|plus|e|angle(down|q|left(eq)?|right(eq)?)?|minus)|pezium|ade)|brk)|T(s(cr|trok)|RADE|h(i(nSpace|ckSpace)|e(ta|refore))|c(y|edil|aron)|S(cy|Hcy)|ilde(Tilde|Equal|FullEqual)?|HORN|opf|fr|a(u|b)|ripleDot))\n						  | (u(scr|h(ar(l|r)|blk)|c(y|irc)|t(ilde|dot|ri(f)?)|Har|o(pf|gon)|d(har|arr|blac)|u(arr|ml)|p(si(h|lon)?|harpoon(left|right)|downarrow|uparrows|lus|arrow)|f(isht|r)|wangle|l(c(orn(er)?|rop)|tri)|a(cute|rr)|r(c(orn(er)?|rop)|tri|ing)|grave|m(l|acr)|br(cy|eve)|Arr)|U(scr|n(ion(Plus)?|der(B(ar|rac(e|ket))|Parenthesis))|c(y|irc)|tilde|o(pf|gon)|dblac|uml|p(si(lon)?|downarrow|Tee(Arrow)?|per(RightArrow|LeftArrow)|DownArrow|Equilibrium|arrow|Arrow(Bar|DownArrow)?)|fr|a(cute|rr(ocir)?)|ring|grave|macr|br(cy|eve)))\n						  | (v(s(cr|u(pn(e|E)|bn(e|E)))|nsu(p|b)|cy|Bar(v)?|zigzag|opf|dash|prop|e(e(eq|bar)?|llip|r(t|bar))|Dash|fr|ltri|a(ngrt|r(s(igma|u(psetneq(q)?|bsetneq(q)?))|nothing|t(heta|riangle(left|right))|p(hi|i|ropto)|epsilon|kappa|r(ho)?))|rtri|Arr)|V(scr|cy|opf|dash(l)?|e(e|r(yThinSpace|t(ical(Bar|Separator|Tilde|Line))?|bar))|Dash|vdash|fr|bar))\n						  | (w(scr|circ|opf|p|e(ierp|d(ge(q)?|bar))|fr|r(eath)?)|W(scr|circ|opf|edge|fr))\n						  | (X(scr|i|opf|fr)|x(s(cr|qcup)|h(arr|Arr)|nis|c(irc|up|ap)|i|o(time|dot|p(f|lus))|dtri|u(tri|plus)|vee|fr|wedge|l(arr|Arr)|r(arr|Arr)|map))\n						  | (y(scr|c(y|irc)|icy|opf|u(cy|ml)|en|fr|ac(y|ute))|Y(scr|c(y|irc)|opf|uml|Icy|Ucy|fr|acute|Acy))\n						  | (z(scr|hcy|c(y|aron)|igrarr|opf|dot|e(ta|etrf)|fr|w(nj|j)|acute)|Z(scr|c(y|aron)|Hcy|opf|dot|e(ta|roWidthSpace)|fr|acute))\n						)\n						(;)\n					", "name": "constant.character.entity.named.$2.html" }, { "captures": { "1": { "name": "punctuation.definition.entity.html" }, "3": { "name": "punctuation.definition.entity.html" } }, "match": "(&)#[0-9]+(;)", "name": "constant.character.entity.numeric.decimal.html" }, { "captures": { "1": { "name": "punctuation.definition.entity.html" }, "3": { "name": "punctuation.definition.entity.html" } }, "match": "(&)#[xX][0-9a-fA-F]+(;)", "name": "constant.character.entity.numeric.hexadecimal.html" }, { "match": "&(?=[a-zA-Z0-9]+;)", "name": "invalid.illegal.ambiguous-ampersand.html" }] }, "math": { "patterns": [{ "begin": `(?i)(<)(math)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(>))?`, "beginCaptures": { "0": { "name": "meta.tag.structure.$2.start.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "patterns": [{ "include": "#attribute" }] }, "5": { "name": "punctuation.definition.tag.end.html" } }, "end": "(?i)(</)(\\2)\\s*(>)", "endCaptures": { "0": { "name": "meta.tag.structure.$2.end.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.element.structure.$2.html", "patterns": [{ "begin": "(?<!>)\\G", "end": ">", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.structure.start.html", "patterns": [{ "include": "#attribute" }] }, { "include": "#tags" }] }], "repository": { "attribute": { "patterns": [{ "begin": "(s(hift|ymmetric|cript(sizemultiplier|level|minsize)|t(ackalign|retchy)|ide|u(pscriptshift|bscriptshift)|e(parator(s)?|lection)|rc)|h(eight|ref)|n(otation|umalign)|c(haralign|olumn(spa(n|cing)|width|lines|align)|lose|rossout)|i(n(dent(shift(first|last)?|target|align(first|last)?)|fixlinebreakstyle)|d)|o(pen|verflow)|d(i(splay(style)?|r)|e(nomalign|cimalpoint|pth))|position|e(dge|qual(columns|rows))|voffset|f(orm|ence|rame(spacing)?)|width|l(space|ine(thickness|leading|break(style|multchar)?)|o(ngdivstyle|cation)|ength|quote|argeop)|a(c(cent(under)?|tiontype)|l(t(text|img(-(height|valign|width))?)|ign(mentscope)?))|r(space|ow(spa(n|cing)|lines|align)|quote)|groupalign|x(link:href|mlns)|m(in(size|labelspacing)|ovablelimits|a(th(size|color|variant|background)|xsize))|bevelled)(?![\\w:-])", "beginCaptures": { "0": { "name": "entity.other.attribute-name.html" } }, "end": "(?=\\s*+[^=\\s])", "name": "meta.attribute.$1.html", "patterns": [{ "include": "#attribute-interior" }] }, { "begin": `([^\\x{0020}"'<>/=\\x{0000}-\\x{001F}\\x{007F}-\\x{009F}\\x{FDD0}-\\x{FDEF}\\x{FFFE}\\x{FFFF}\\x{1FFFE}\\x{1FFFF}\\x{2FFFE}\\x{2FFFF}\\x{3FFFE}\\x{3FFFF}\\x{4FFFE}\\x{4FFFF}\\x{5FFFE}\\x{5FFFF}\\x{6FFFE}\\x{6FFFF}\\x{7FFFE}\\x{7FFFF}\\x{8FFFE}\\x{8FFFF}\\x{9FFFE}\\x{9FFFF}\\x{AFFFE}\\x{AFFFF}\\x{BFFFE}\\x{BFFFF}\\x{CFFFE}\\x{CFFFF}\\x{DFFFE}\\x{DFFFF}\\x{EFFFE}\\x{EFFFF}\\x{FFFFE}\\x{FFFFF}\\x{10FFFE}\\x{10FFFF}]+)`, "beginCaptures": { "0": { "name": "entity.other.attribute-name.html" } }, "comment": "Anything else that is valid", "end": "(?=\\s*+[^=\\s])", "name": "meta.attribute.unrecognized.$1.html", "patterns": [{ "include": "#attribute-interior" }] }, { "match": "[^\\s>]+", "name": "invalid.illegal.character-not-allowed-here.html" }] }, "tags": { "patterns": [{ "include": "#comment" }, { "include": "#cdata" }, { "captures": { "0": { "name": "meta.tag.structure.math.$2.void.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "patterns": [{ "include": "#attribute" }] }, "5": { "name": "punctuation.definition.tag.end.html" } }, "match": `(?i)(<)(annotation|annotation-xml|semantics|menclose|merror|mfenced|mfrac|mpadded|mphantom|mroot|mrow|msqrt|mstyle|mmultiscripts|mover|mprescripts|msub|msubsup|msup|munder|munderover|none|mlabeledtr|mtable|mtd|mtr|mlongdiv|mscarries|mscarry|msgroup|msline|msrow|mstack|maction)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(/>))`, "name": "meta.element.structure.math.$2.html" }, { "begin": `(?i)(<)(annotation|annotation-xml|semantics|menclose|merror|mfenced|mfrac|mpadded|mphantom|mroot|mrow|msqrt|mstyle|mmultiscripts|mover|mprescripts|msub|msubsup|msup|munder|munderover|none|mlabeledtr|mtable|mtd|mtr|mlongdiv|mscarries|mscarry|msgroup|msline|msrow|mstack|maction)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(>))?`, "beginCaptures": { "0": { "name": "meta.tag.structure.math.$2.start.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "patterns": [{ "include": "#attribute" }] }, "5": { "name": "punctuation.definition.tag.end.html" } }, "end": "(?i)(</)(\\2)\\s*(>)|(/>)|(?=</\\w+)", "endCaptures": { "0": { "name": "meta.tag.structure.math.$2.end.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "punctuation.definition.tag.end.html" }, "4": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.element.structure.math.$2.html", "patterns": [{ "begin": "(?<!>)\\G", "end": "(?=/>)|>", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.structure.start.html", "patterns": [{ "include": "#attribute" }] }, { "include": "#tags" }] }, { "captures": { "0": { "name": "meta.tag.inline.math.$2.void.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "patterns": [{ "include": "#attribute" }] }, "5": { "name": "punctuation.definition.tag.end.html" } }, "match": `(?i)(<)(mi|mn|mo|ms|mspace|mtext|maligngroup|malignmark)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(/>))`, "name": "meta.element.inline.math.$2.html" }, { "begin": `(?i)(<)(mi|mn|mo|ms|mspace|mtext|maligngroup|malignmark)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(>))?`, "beginCaptures": { "0": { "name": "meta.tag.inline.math.$2.start.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "patterns": [{ "include": "#attribute" }] }, "5": { "name": "punctuation.definition.tag.end.html" } }, "end": "(?i)(</)(\\2)\\s*(>)|(/>)|(?=</\\w+)", "endCaptures": { "0": { "name": "meta.tag.inline.math.$2.end.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "punctuation.definition.tag.end.html" }, "4": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.element.inline.math.$2.html", "patterns": [{ "begin": "(?<!>)\\G", "end": "(?=/>)|>", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.inline.start.html", "patterns": [{ "include": "#attribute" }] }, { "include": "#tags" }] }, { "captures": { "0": { "name": "meta.tag.object.math.$2.void.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "patterns": [{ "include": "#attribute" }] }, "5": { "name": "punctuation.definition.tag.end.html" } }, "match": `(?i)(<)(mglyph)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(/>))`, "name": "meta.element.object.math.$2.html" }, { "begin": `(?i)(<)(mglyph)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(>))?`, "beginCaptures": { "0": { "name": "meta.tag.object.math.$2.start.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "patterns": [{ "include": "#attribute" }] }, "5": { "name": "punctuation.definition.tag.end.html" } }, "end": "(?i)(</)(\\2)\\s*(>)|(/>)|(?=</\\w+)", "endCaptures": { "0": { "name": "meta.tag.object.math.$2.end.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "punctuation.definition.tag.end.html" }, "4": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.element.object.math.$2.html", "patterns": [{ "begin": "(?<!>)\\G", "end": "(?=/>)|>", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.object.start.html", "patterns": [{ "include": "#attribute" }] }, { "include": "#tags" }] }, { "captures": { "0": { "name": "meta.tag.other.invalid.void.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "invalid.illegal.unrecognized-tag.html" }, "4": { "patterns": [{ "include": "#attribute" }] }, "6": { "name": "punctuation.definition.tag.end.html" } }, "match": `(?i)(<)(([\\w:]+))(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(/>))`, "name": "meta.element.other.invalid.html" }, { "begin": `(?i)(<)((\\w[^\\s>]*))(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(>))?`, "beginCaptures": { "0": { "name": "meta.tag.other.invalid.start.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "invalid.illegal.unrecognized-tag.html" }, "4": { "patterns": [{ "include": "#attribute" }] }, "6": { "name": "punctuation.definition.tag.end.html" } }, "end": "(?i)(</)((\\2))\\s*(>)|(/>)|(?=</\\w+)", "endCaptures": { "0": { "name": "meta.tag.other.invalid.end.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "invalid.illegal.unrecognized-tag.html" }, "4": { "name": "punctuation.definition.tag.end.html" }, "5": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.element.other.invalid.html", "patterns": [{ "begin": "(?<!>)\\G", "end": "(?=/>)|>", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.other.invalid.start.html", "patterns": [{ "include": "#attribute" }] }, { "include": "#tags" }] }, { "include": "#tags-invalid" }] } } }, "svg": { "patterns": [{ "begin": `(?i)(<)(svg)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(>))?`, "beginCaptures": { "0": { "name": "meta.tag.structure.$2.start.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "patterns": [{ "include": "#attribute" }] }, "5": { "name": "punctuation.definition.tag.end.html" } }, "end": "(?i)(</)(\\2)\\s*(>)", "endCaptures": { "0": { "name": "meta.tag.structure.$2.end.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.element.structure.$2.html", "patterns": [{ "begin": "(?<!>)\\G", "end": ">", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.structure.start.html", "patterns": [{ "include": "#attribute" }] }, { "include": "#tags" }] }], "repository": { "attribute": { "patterns": [{ "begin": "(s(hape-rendering|ystemLanguage|cale|t(yle|itchTiles|op-(color|opacity)|dDeviation|em(h|v)|artOffset|r(i(ng|kethrough-(thickness|position))|oke(-(opacity|dash(offset|array)|width|line(cap|join)|miterlimit))?))|urfaceScale|p(e(cular(Constant|Exponent)|ed)|acing|readMethod)|eed|lope)|h(oriz-(origin-x|adv-x)|eight|anging|ref(lang)?)|y(1|2|ChannelSelector)?|n(umOctaves|ame)|c(y|o(ntentS(criptType|tyleType)|lor(-(interpolation(-filters)?|profile|rendering))?)|ursor|l(ip(-(path|rule)|PathUnits)?|ass)|a(p-height|lcMode)|x)|t(ype|o|ext(-(decoration|anchor|rendering)|Length)|a(rget(X|Y)?|b(index|leValues))|ransform)|i(n(tercept|2)?|d(eographic)?|mage-rendering)|z(oomAndPan)?|o(p(erator|acity)|ver(flow|line-(thickness|position))|ffset|r(i(ent(ation)?|gin)|der))|d(y|i(splay|visor|ffuseConstant|rection)|ominant-baseline|ur|e(scent|celerate)|x)?|u(1|n(i(code(-(range|bidi))?|ts-per-em)|derline-(thickness|position))|2)|p(ing|oint(s(At(X|Y|Z))?|er-events)|a(nose-1|t(h(Length)?|tern(ContentUnits|Transform|Units))|int-order)|r(imitiveUnits|eserveA(spectRatio|lpha)))|e(n(d|able-background)|dgeMode|levation|x(ternalResourcesRequired|ponent))|v(i(sibility|ew(Box|Target))|-(hanging|ideographic|alphabetic|mathematical)|e(ctor-effect|r(sion|t-(origin-(y|x)|adv-y)))|alues)|k(1|2|3|e(y(Splines|Times|Points)|rn(ing|el(Matrix|UnitLength)))|4)?|f(y|il(ter(Res|Units)?|l(-(opacity|rule))?)|o(nt-(s(t(yle|retch)|ize(-adjust)?)|variant|family|weight)|rmat)|lood-(color|opacity)|r(om)?|x)|w(idth(s)?|ord-spacing|riting-mode)|l(i(ghting-color|mitingConeAngle)|ocal|e(ngthAdjust|tter-spacing)|ang)|a(scent|cc(umulate|ent-height)|ttribute(Name|Type)|zimuth|dditive|utoReverse|l(ignment-baseline|phabetic|lowReorder)|rabic-form|mplitude)|r(y|otate|e(s(tart|ult)|ndering-intent|peat(Count|Dur)|quired(Extensions|Features)|f(X|Y|errerPolicy)|l)|adius|x)?|g(1|2|lyph(Ref|-(name|orientation-(horizontal|vertical)))|radient(Transform|Units))|x(1|2|ChannelSelector|-height|link:(show|href|t(ype|itle)|a(ctuate|rcrole)|role)|ml:(space|lang|base))?|m(in|ode|e(thod|dia)|a(sk(ContentUnits|Units)?|thematical|rker(Height|-(start|end|mid)|Units|Width)|x))|b(y|ias|egin|ase(Profile|line-shift|Frequency)|box))(?![\\w:-])", "beginCaptures": { "0": { "name": "entity.other.attribute-name.html" } }, "end": "(?=\\s*+[^=\\s])", "name": "meta.attribute.$1.html", "patterns": [{ "include": "#attribute-interior" }] }, { "begin": `([^\\x{0020}"'<>/=\\x{0000}-\\x{001F}\\x{007F}-\\x{009F}\\x{FDD0}-\\x{FDEF}\\x{FFFE}\\x{FFFF}\\x{1FFFE}\\x{1FFFF}\\x{2FFFE}\\x{2FFFF}\\x{3FFFE}\\x{3FFFF}\\x{4FFFE}\\x{4FFFF}\\x{5FFFE}\\x{5FFFF}\\x{6FFFE}\\x{6FFFF}\\x{7FFFE}\\x{7FFFF}\\x{8FFFE}\\x{8FFFF}\\x{9FFFE}\\x{9FFFF}\\x{AFFFE}\\x{AFFFF}\\x{BFFFE}\\x{BFFFF}\\x{CFFFE}\\x{CFFFF}\\x{DFFFE}\\x{DFFFF}\\x{EFFFE}\\x{EFFFF}\\x{FFFFE}\\x{FFFFF}\\x{10FFFE}\\x{10FFFF}]+)`, "beginCaptures": { "0": { "name": "entity.other.attribute-name.html" } }, "comment": "Anything else that is valid", "end": "(?=\\s*+[^=\\s])", "name": "meta.attribute.unrecognized.$1.html", "patterns": [{ "include": "#attribute-interior" }] }, { "match": "[^\\s>]+", "name": "invalid.illegal.character-not-allowed-here.html" }] }, "tags": { "patterns": [{ "include": "#comment" }, { "include": "#cdata" }, { "captures": { "0": { "name": "meta.tag.metadata.svg.$2.void.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "patterns": [{ "include": "#attribute" }] }, "5": { "name": "punctuation.definition.tag.end.html" } }, "match": `(?i)(<)(color-profile|desc|metadata|script|style|title)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(/>))`, "name": "meta.element.metadata.svg.$2.html" }, { "begin": `(?i)(<)(color-profile|desc|metadata|script|style|title)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(>))?`, "beginCaptures": { "0": { "name": "meta.tag.metadata.svg.$2.start.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "patterns": [{ "include": "#attribute" }] }, "5": { "name": "punctuation.definition.tag.end.html" } }, "end": "(?i)(</)(\\2)\\s*(>)|(/>)|(?=</\\w+)", "endCaptures": { "0": { "name": "meta.tag.metadata.svg.$2.end.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "punctuation.definition.tag.end.html" }, "4": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.element.metadata.svg.$2.html", "patterns": [{ "begin": "(?<!>)\\G", "end": "(?=/>)|>", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.metadata.start.html", "patterns": [{ "include": "#attribute" }] }, { "include": "#tags" }] }, { "captures": { "0": { "name": "meta.tag.structure.svg.$2.void.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "patterns": [{ "include": "#attribute" }] }, "5": { "name": "punctuation.definition.tag.end.html" } }, "match": `(?i)(<)(animateMotion|clipPath|defs|feComponentTransfer|feDiffuseLighting|feMerge|feSpecularLighting|filter|g|hatch|linearGradient|marker|mask|mesh|meshgradient|meshpatch|meshrow|pattern|radialGradient|switch|text|textPath)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(/>))`, "name": "meta.element.structure.svg.$2.html" }, { "begin": `(?i)(<)(animateMotion|clipPath|defs|feComponentTransfer|feDiffuseLighting|feMerge|feSpecularLighting|filter|g|hatch|linearGradient|marker|mask|mesh|meshgradient|meshpatch|meshrow|pattern|radialGradient|switch|text|textPath)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(>))?`, "beginCaptures": { "0": { "name": "meta.tag.structure.svg.$2.start.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "patterns": [{ "include": "#attribute" }] }, "5": { "name": "punctuation.definition.tag.end.html" } }, "end": "(?i)(</)(\\2)\\s*(>)|(/>)|(?=</\\w+)", "endCaptures": { "0": { "name": "meta.tag.structure.svg.$2.end.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "punctuation.definition.tag.end.html" }, "4": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.element.structure.svg.$2.html", "patterns": [{ "begin": "(?<!>)\\G", "end": "(?=/>)|>", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.structure.start.html", "patterns": [{ "include": "#attribute" }] }, { "include": "#tags" }] }, { "captures": { "0": { "name": "meta.tag.inline.svg.$2.void.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "patterns": [{ "include": "#attribute" }] }, "5": { "name": "punctuation.definition.tag.end.html" } }, "match": `(?i)(<)(a|animate|discard|feBlend|feColorMatrix|feComposite|feConvolveMatrix|feDisplacementMap|feDistantLight|feDropShadow|feFlood|feFuncA|feFuncB|feFuncG|feFuncR|feGaussianBlur|feMergeNode|feMorphology|feOffset|fePointLight|feSpotLight|feTile|feTurbulence|hatchPath|mpath|set|solidcolor|stop|tspan)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(/>))`, "name": "meta.element.inline.svg.$2.html" }, { "begin": `(?i)(<)(a|animate|discard|feBlend|feColorMatrix|feComposite|feConvolveMatrix|feDisplacementMap|feDistantLight|feDropShadow|feFlood|feFuncA|feFuncB|feFuncG|feFuncR|feGaussianBlur|feMergeNode|feMorphology|feOffset|fePointLight|feSpotLight|feTile|feTurbulence|hatchPath|mpath|set|solidcolor|stop|tspan)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(>))?`, "beginCaptures": { "0": { "name": "meta.tag.inline.svg.$2.start.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "patterns": [{ "include": "#attribute" }] }, "5": { "name": "punctuation.definition.tag.end.html" } }, "end": "(?i)(</)(\\2)\\s*(>)|(/>)|(?=</\\w+)", "endCaptures": { "0": { "name": "meta.tag.inline.svg.$2.end.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "punctuation.definition.tag.end.html" }, "4": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.element.inline.svg.$2.html", "patterns": [{ "begin": "(?<!>)\\G", "end": "(?=/>)|>", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.inline.start.html", "patterns": [{ "include": "#attribute" }] }, { "include": "#tags" }] }, { "captures": { "0": { "name": "meta.tag.object.svg.$2.void.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "patterns": [{ "include": "#attribute" }] }, "5": { "name": "punctuation.definition.tag.end.html" } }, "match": `(?i)(<)(circle|ellipse|feImage|foreignObject|image|line|path|polygon|polyline|rect|symbol|use|view)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(/>))`, "name": "meta.element.object.svg.$2.html" }, { "begin": `(?i)(<)(a|circle|ellipse|feImage|foreignObject|image|line|path|polygon|polyline|rect|symbol|use|view)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(>))?`, "beginCaptures": { "0": { "name": "meta.tag.object.svg.$2.start.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "patterns": [{ "include": "#attribute" }] }, "5": { "name": "punctuation.definition.tag.end.html" } }, "end": "(?i)(</)(\\2)\\s*(>)|(/>)|(?=</\\w+)", "endCaptures": { "0": { "name": "meta.tag.object.svg.$2.end.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "punctuation.definition.tag.end.html" }, "4": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.element.object.svg.$2.html", "patterns": [{ "begin": "(?<!>)\\G", "end": "(?=/>)|>", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.object.start.html", "patterns": [{ "include": "#attribute" }] }, { "include": "#tags" }] }, { "captures": { "0": { "name": "meta.tag.other.svg.$2.void.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "invalid.deprecated.html" }, "4": { "patterns": [{ "include": "#attribute" }] }, "6": { "name": "punctuation.definition.tag.end.html" } }, "match": `(?i)(<)((altGlyph|altGlyphDef|altGlyphItem|animateColor|animateTransform|cursor|font|font-face|font-face-format|font-face-name|font-face-src|font-face-uri|glyph|glyphRef|hkern|missing-glyph|tref|vkern))(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(/>))`, "name": "meta.element.other.svg.$2.html" }, { "begin": `(?i)(<)((altGlyph|altGlyphDef|altGlyphItem|animateColor|animateTransform|cursor|font|font-face|font-face-format|font-face-name|font-face-src|font-face-uri|glyph|glyphRef|hkern|missing-glyph|tref|vkern))(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(>))?`, "beginCaptures": { "0": { "name": "meta.tag.other.svg.$2.start.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "invalid.deprecated.html" }, "4": { "patterns": [{ "include": "#attribute" }] }, "6": { "name": "punctuation.definition.tag.end.html" } }, "end": "(?i)(</)((\\2))\\s*(>)|(/>)|(?=</\\w+)", "endCaptures": { "0": { "name": "meta.tag.other.svg.$2.end.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "invalid.deprecated.html" }, "4": { "name": "punctuation.definition.tag.end.html" }, "5": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.element.other.svg.$2.html", "patterns": [{ "begin": "(?<!>)\\G", "end": "(?=/>)|>", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.other.start.html", "patterns": [{ "include": "#attribute" }] }, { "include": "#tags" }] }, { "captures": { "0": { "name": "meta.tag.other.invalid.void.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "invalid.illegal.unrecognized-tag.html" }, "4": { "patterns": [{ "include": "#attribute" }] }, "6": { "name": "punctuation.definition.tag.end.html" } }, "match": `(?i)(<)(([\\w:]+))(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(/>))`, "name": "meta.element.other.invalid.html" }, { "begin": `(?i)(<)((\\w[^\\s>]*))(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(>))?`, "beginCaptures": { "0": { "name": "meta.tag.other.invalid.start.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "invalid.illegal.unrecognized-tag.html" }, "4": { "patterns": [{ "include": "#attribute" }] }, "6": { "name": "punctuation.definition.tag.end.html" } }, "end": "(?i)(</)((\\2))\\s*(>)|(/>)|(?=</\\w+)", "endCaptures": { "0": { "name": "meta.tag.other.invalid.end.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "invalid.illegal.unrecognized-tag.html" }, "4": { "name": "punctuation.definition.tag.end.html" }, "5": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.element.other.invalid.html", "patterns": [{ "begin": "(?<!>)\\G", "end": "(?=/>)|>", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.other.invalid.start.html", "patterns": [{ "include": "#attribute" }] }, { "include": "#tags" }] }, { "include": "#tags-invalid" }] } } }, "tags-invalid": { "patterns": [{ "begin": "(</?)((\\w[^\\s>]*))(?<!/)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "invalid.illegal.unrecognized-tag.html" } }, "end": "((?: ?/)?>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.other.$2.html", "patterns": [{ "include": "#attribute" }] }] }, "tags-valid": { "patterns": [{ "begin": "(^[ \\t]+)?(?=<(?i:style)\\b(?!-))", "beginCaptures": { "1": { "name": "punctuation.whitespace.embedded.leading.html" } }, "end": "(?!\\G)([ \\t]*$\\n?)?", "endCaptures": { "1": { "name": "punctuation.whitespace.embedded.trailing.html" } }, "patterns": [{ "begin": "(?i)(<)(style)(?=\\s|/?>)", "beginCaptures": { "0": { "name": "meta.tag.metadata.style.start.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" } }, "end": "(?i)((<)/)(style)\\s*(>)", "endCaptures": { "0": { "name": "meta.tag.metadata.style.end.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "source.css-ignored-vscode" }, "3": { "name": "entity.name.tag.html" }, "4": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.embedded.block.html", "patterns": [{ "begin": "\\G", "captures": { "1": { "name": "punctuation.definition.tag.end.html" } }, "end": "(>)", "name": "meta.tag.metadata.style.start.html", "patterns": [{ "include": "#attribute" }] }, { "begin": "(?!\\G)", "end": "(?=</(?i:style))", "name": "source.css", "patterns": [{ "include": "source.css" }] }] }] }, { "begin": "(^[ \\t]+)?(?=<(?i:script)\\b(?!-))", "beginCaptures": { "1": { "name": "punctuation.whitespace.embedded.leading.html" } }, "end": "(?!\\G)([ \\t]*$\\n?)?", "endCaptures": { "1": { "name": "punctuation.whitespace.embedded.trailing.html" } }, "patterns": [{ "begin": "(<)((?i:script))\\b", "beginCaptures": { "0": { "name": "meta.tag.metadata.script.start.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" } }, "end": "(/)((?i:script))(>)", "endCaptures": { "0": { "name": "meta.tag.metadata.script.end.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.embedded.block.html", "patterns": [{ "begin": "\\G", "end": "(?=/)", "patterns": [{ "begin": "(>)", "beginCaptures": { "0": { "name": "meta.tag.metadata.script.start.html" }, "1": { "name": "punctuation.definition.tag.end.html" } }, "end": "((<))(?=/(?i:script))", "endCaptures": { "0": { "name": "meta.tag.metadata.script.end.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "source.js-ignored-vscode" } }, "patterns": [{ "begin": "\\G", "end": "(?=</(?i:script))", "name": "source.js", "patterns": [{ "begin": "(^[ \\t]+)?(?=//)", "beginCaptures": { "1": { "name": "punctuation.whitespace.comment.leading.js" } }, "end": "(?!\\G)", "patterns": [{ "begin": "//", "beginCaptures": { "0": { "name": "punctuation.definition.comment.js" } }, "end": "(?=<\/script)|\\n", "name": "comment.line.double-slash.js" }] }, { "begin": "/\\*", "captures": { "0": { "name": "punctuation.definition.comment.js" } }, "end": "\\*/|(?=<\/script)", "name": "comment.block.js" }, { "include": "source.js" }] }] }, { "begin": "\\G", "end": `(?ix:
												(?=>											# Tag without type attribute
												  | type(?=[\\s=])
												  	(?!\\s*=\\s*
														(
															''								# Empty
														  | ""									#   Values
														  | ('|"|)
															(
																text/							# Text mime-types
																(
																	javascript(1\\.[0-5])?
																  | x-javascript
																  | jscript
																  | livescript
																  | (x-)?ecmascript
																  | babel						# Javascript variant currently
																  								#   recognized as such
															  	)
															  | application/					# Application mime-types
															  	(
																	(x-)?javascript
																  | (x-)?ecmascript
																)
															  | module
														  	)
															[\\s"'>]
														)
													)
												)
											)`, "name": "meta.tag.metadata.script.start.html", "patterns": [{ "include": "#attribute" }] }, { "begin": `(?ix:
												(?=
													type\\s*=\\s*
													('|"|)
													text/
													(
														x-handlebars
													  | (x-(handlebars-)?|ng-)?template
													  | html
													)
													[\\s"'>]
												)
											)`, "end": "((<))(?=/(?i:script))", "endCaptures": { "0": { "name": "meta.tag.metadata.script.end.html" }, "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "text.html.basic" } }, "patterns": [{ "begin": "\\G", "end": "(>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.metadata.script.start.html", "patterns": [{ "include": "#attribute" }] }, { "begin": "(?!\\G)", "end": "(?=</(?i:script))", "name": "text.html.basic", "patterns": [{ "include": "text.html.basic" }] }] }, { "begin": "(?=(?i:type))", "end": "(<)(?=/(?i:script))", "endCaptures": { "0": { "name": "meta.tag.metadata.script.end.html" }, "1": { "name": "punctuation.definition.tag.begin.html" } }, "patterns": [{ "begin": "\\G", "end": "(>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.metadata.script.start.html", "patterns": [{ "include": "#attribute" }] }, { "begin": "(?!\\G)", "end": "(?=</(?i:script))", "name": "source.unknown" }] }] }] }] }, { "begin": "(?i)(<)(base|link|meta)(?=\\s|/?>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" } }, "end": "/?>", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.metadata.$2.void.html", "patterns": [{ "include": "#attribute" }] }, { "begin": "(?i)(<)(noscript|title)(?=\\s|/?>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" } }, "end": ">", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.metadata.$2.start.html", "patterns": [{ "include": "#attribute" }] }, { "begin": "(?i)(</)(noscript|title)(?=\\s|/?>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" } }, "end": ">", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.metadata.$2.end.html", "patterns": [{ "include": "#attribute" }] }, { "begin": "(?i)(<)(col|hr|input)(?=\\s|/?>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" } }, "end": "/?>", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.structure.$2.void.html", "patterns": [{ "include": "#attribute" }] }, { "begin": "(?i)(<)(address|article|aside|blockquote|body|button|caption|colgroup|datalist|dd|details|dialog|div|dl|dt|fieldset|figcaption|figure|footer|form|head|header|hgroup|html|h[1-6]|label|legend|li|main|map|menu|meter|nav|ol|optgroup|option|output|p|pre|progress|section|select|slot|summary|table|tbody|td|template|textarea|tfoot|th|thead|tr|ul)(?=\\s|/?>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" } }, "end": ">", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.structure.$2.start.html", "patterns": [{ "include": "#attribute" }] }, { "begin": "(?i)(</)(address|article|aside|blockquote|body|button|caption|colgroup|datalist|dd|details|dialog|div|dl|dt|fieldset|figcaption|figure|footer|form|head|header|hgroup|html|h[1-6]|label|legend|li|main|map|menu|meter|nav|ol|optgroup|option|output|p|pre|progress|section|select|slot|summary|table|tbody|td|template|textarea|tfoot|th|thead|tr|ul)(?=\\s|/?>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" } }, "end": ">", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.structure.$2.end.html", "patterns": [{ "include": "#attribute" }] }, { "begin": "(?i)(<)(area|br|wbr)(?=\\s|/?>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" } }, "end": "/?>", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.inline.$2.void.html", "patterns": [{ "include": "#attribute" }] }, { "begin": "(?i)(<)(a|abbr|b|bdi|bdo|cite|code|data|del|dfn|em|i|ins|kbd|mark|q|rp|rt|ruby|s|samp|small|span|strong|sub|sup|time|u|var)(?=\\s|/?>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" } }, "end": ">", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.inline.$2.start.html", "patterns": [{ "include": "#attribute" }] }, { "begin": "(?i)(</)(a|abbr|b|bdi|bdo|cite|code|data|del|dfn|em|i|ins|kbd|mark|q|rp|rt|ruby|s|samp|small|span|strong|sub|sup|time|u|var)(?=\\s|/?>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" } }, "end": ">", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.inline.$2.end.html", "patterns": [{ "include": "#attribute" }] }, { "begin": "(?i)(<)(embed|img|param|source|track)(?=\\s|/?>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" } }, "end": "/?>", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.object.$2.void.html", "patterns": [{ "include": "#attribute" }] }, { "begin": "(?i)(<)(audio|canvas|iframe|object|picture|video)(?=\\s|/?>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" } }, "end": ">", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.object.$2.start.html", "patterns": [{ "include": "#attribute" }] }, { "begin": "(?i)(</)(audio|canvas|iframe|object|picture|video)(?=\\s|/?>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" } }, "end": ">", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.object.$2.end.html", "patterns": [{ "include": "#attribute" }] }, { "begin": "(?i)(<)((basefont|isindex))(?=\\s|/?>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "invalid.deprecated.html" } }, "end": "/?>", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.metadata.$2.void.html", "patterns": [{ "include": "#attribute" }] }, { "begin": "(?i)(<)((center|frameset|noembed|noframes))(?=\\s|/?>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "invalid.deprecated.html" } }, "end": ">", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.structure.$2.start.html", "patterns": [{ "include": "#attribute" }] }, { "begin": "(?i)(</)((center|frameset|noembed|noframes))(?=\\s|/?>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "invalid.deprecated.html" } }, "end": ">", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.structure.$2.end.html", "patterns": [{ "include": "#attribute" }] }, { "begin": "(?i)(<)((acronym|big|blink|font|strike|tt|xmp))(?=\\s|/?>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "invalid.deprecated.html" } }, "end": ">", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.inline.$2.start.html", "patterns": [{ "include": "#attribute" }] }, { "begin": "(?i)(</)((acronym|big|blink|font|strike|tt|xmp))(?=\\s|/?>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "invalid.deprecated.html" } }, "end": ">", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.inline.$2.end.html", "patterns": [{ "include": "#attribute" }] }, { "begin": "(?i)(<)((frame))(?=\\s|/?>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "invalid.deprecated.html" } }, "end": "/?>", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.object.$2.void.html", "patterns": [{ "include": "#attribute" }] }, { "begin": "(?i)(<)((applet))(?=\\s|/?>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "invalid.deprecated.html" } }, "end": ">", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.object.$2.start.html", "patterns": [{ "include": "#attribute" }] }, { "begin": "(?i)(</)((applet))(?=\\s|/?>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "invalid.deprecated.html" } }, "end": ">", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.object.$2.end.html", "patterns": [{ "include": "#attribute" }] }, { "begin": "(?i)(<)((dir|keygen|listing|menuitem|plaintext|spacer))(?=\\s|/?>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "invalid.illegal.no-longer-supported.html" } }, "end": ">", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.other.$2.start.html", "patterns": [{ "include": "#attribute" }] }, { "begin": "(?i)(</)((dir|keygen|listing|menuitem|plaintext|spacer))(?=\\s|/?>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" }, "3": { "name": "invalid.illegal.no-longer-supported.html" } }, "end": ">", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.other.$2.end.html", "patterns": [{ "include": "#attribute" }] }, { "include": "#math" }, { "include": "#svg" }, { "begin": "(<)([a-zA-Z][.0-9_a-zA-Z\\x{00B7}\\x{00C0}-\\x{00D6}\\x{00D8}-\\x{00F6}\\x{00F8}-\\x{037D}\\x{037F}-\\x{1FFF}\\x{200C}-\\x{200D}\\x{203F}-\\x{2040}\\x{2070}-\\x{218F}\\x{2C00}-\\x{2FEF}\\x{3001}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFFD}\\x{10000}-\\x{EFFFF}]*-[\\-.0-9_a-zA-Z\\x{00B7}\\x{00C0}-\\x{00D6}\\x{00D8}-\\x{00F6}\\x{00F8}-\\x{037D}\\x{037F}-\\x{1FFF}\\x{200C}-\\x{200D}\\x{203F}-\\x{2040}\\x{2070}-\\x{218F}\\x{2C00}-\\x{2FEF}\\x{3001}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFFD}\\x{10000}-\\x{EFFFF}]*)(?=\\s|/?>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" } }, "end": "/?>", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.custom.start.html", "patterns": [{ "include": "#attribute" }] }, { "begin": "(</)([a-zA-Z][.0-9_a-zA-Z\\x{00B7}\\x{00C0}-\\x{00D6}\\x{00D8}-\\x{00F6}\\x{00F8}-\\x{037D}\\x{037F}-\\x{1FFF}\\x{200C}-\\x{200D}\\x{203F}-\\x{2040}\\x{2070}-\\x{218F}\\x{2C00}-\\x{2FEF}\\x{3001}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFFD}\\x{10000}-\\x{EFFFF}]*-[\\-.0-9_a-zA-Z\\x{00B7}\\x{00C0}-\\x{00D6}\\x{00D8}-\\x{00F6}\\x{00F8}-\\x{037D}\\x{037F}-\\x{1FFF}\\x{200C}-\\x{200D}\\x{203F}-\\x{2040}\\x{2070}-\\x{218F}\\x{2C00}-\\x{2FEF}\\x{3001}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFFD}\\x{10000}-\\x{EFFFF}]*)(?=\\s|/?>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html" }, "2": { "name": "entity.name.tag.html" } }, "end": ">", "endCaptures": { "0": { "name": "punctuation.definition.tag.end.html" } }, "name": "meta.tag.custom.end.html", "patterns": [{ "include": "#attribute" }] }] }, "xml-processing": { "begin": "(<\\?)(xml)", "captures": { "1": { "name": "punctuation.definition.tag.html" }, "2": { "name": "entity.name.tag.html" } }, "end": "(\\?>)", "name": "meta.tag.metadata.processing.xml.html", "patterns": [{ "include": "#attribute" }] } }, "scopeName": "text.html.basic", "embeddedLangs": ["javascript", "css"] });
var html = [
  ...javascript,
  ...css,
  lang$l
];
var lang$k = Object.freeze({ "displayName": "Markdown", "name": "markdown", "patterns": [{ "include": "#frontMatter" }, { "include": "#block" }], "repository": { "ampersand": { "comment": "Markdown will convert this for us. We match it so that the HTML grammar will not mark it up as invalid.", "match": "&(?!([a-zA-Z0-9]+|#[0-9]+|#x[0-9a-fA-F]+);)", "name": "meta.other.valid-ampersand.markdown" }, "block": { "patterns": [{ "include": "#separator" }, { "include": "#heading" }, { "include": "#blockquote" }, { "include": "#lists" }, { "include": "#fenced_code_block" }, { "include": "#raw_block" }, { "include": "#link-def" }, { "include": "#html" }, { "include": "#table" }, { "include": "#paragraph" }] }, "blockquote": { "begin": "(^|\\G)[ ]{0,3}(>) ?", "captures": { "2": { "name": "punctuation.definition.quote.begin.markdown" } }, "name": "markup.quote.markdown", "patterns": [{ "include": "#block" }], "while": "(^|\\G)\\s*(>) ?" }, "bold": { "begin": "(?x) (?<open>(\\*\\*(?=\\w)|(?<!\\w)\\*\\*|(?<!\\w)\\b__))(?=\\S) (?=\n  (\n    <[^>]*+>              # HTML tags\n    | (?<raw>`+)([^`]|(?!(?<!`)\\k<raw>(?!`))`)*+\\k<raw>\n                      # Raw\n    | \\\\[\\\\`*_{}\\[\\]()#.!+\\->]?+      # Escapes\n    | \\[\n    (\n        (?<square>          # Named group\n          [^\\[\\]\\\\]        # Match most chars\n          | \\\\.            # Escaped chars\n          | \\[ \\g<square>*+ \\]    # Nested brackets\n        )*+\n      \\]\n      (\n        (              # Reference Link\n          [ ]?          # Optional space\n          \\[[^\\]]*+\\]        # Ref name\n        )\n        | (              # Inline Link\n          \\(            # Opening paren\n            [ \\t]*+        # Optional whitespace\n            <?(.*?)>?      # URL\n            [ \\t]*+        # Optional whitespace\n            (          # Optional Title\n              (?<title>['\"])\n              (.*?)\n              \\k<title>\n            )?\n          \\)\n        )\n      )\n    )\n    | (?!(?<=\\S)\\k<open>).            # Everything besides\n                      # style closer\n  )++\n  (?<=\\S)(?=__\\b|\\*\\*)\\k<open>                # Close\n)\n", "captures": { "1": { "name": "punctuation.definition.bold.markdown" } }, "end": "(?<=\\S)(\\1)", "name": "markup.bold.markdown", "patterns": [{ "applyEndPatternLast": 1, "begin": "(?=<[^>]*?>)", "end": "(?<=>)", "patterns": [{ "include": "text.html.derivative" }] }, { "include": "#escape" }, { "include": "#ampersand" }, { "include": "#bracket" }, { "include": "#raw" }, { "include": "#bold" }, { "include": "#italic" }, { "include": "#image-inline" }, { "include": "#link-inline" }, { "include": "#link-inet" }, { "include": "#link-email" }, { "include": "#image-ref" }, { "include": "#link-ref-literal" }, { "include": "#link-ref" }, { "include": "#link-ref-shortcut" }, { "include": "#strikethrough" }] }, "bracket": { "comment": "Markdown will convert this for us. We match it so that the HTML grammar will not mark it up as invalid.", "match": "<(?![a-zA-Z/?\\$!])", "name": "meta.other.valid-bracket.markdown" }, "escape": { "match": "\\\\[-`*_#+.!(){}\\[\\]\\\\>]", "name": "constant.character.escape.markdown" }, "fenced_code_block": { "patterns": [{ "include": "#fenced_code_block_css" }, { "include": "#fenced_code_block_basic" }, { "include": "#fenced_code_block_ini" }, { "include": "#fenced_code_block_java" }, { "include": "#fenced_code_block_lua" }, { "include": "#fenced_code_block_makefile" }, { "include": "#fenced_code_block_perl" }, { "include": "#fenced_code_block_r" }, { "include": "#fenced_code_block_ruby" }, { "include": "#fenced_code_block_php" }, { "include": "#fenced_code_block_sql" }, { "include": "#fenced_code_block_vs_net" }, { "include": "#fenced_code_block_xml" }, { "include": "#fenced_code_block_xsl" }, { "include": "#fenced_code_block_yaml" }, { "include": "#fenced_code_block_dosbatch" }, { "include": "#fenced_code_block_clojure" }, { "include": "#fenced_code_block_coffee" }, { "include": "#fenced_code_block_c" }, { "include": "#fenced_code_block_cpp" }, { "include": "#fenced_code_block_diff" }, { "include": "#fenced_code_block_dockerfile" }, { "include": "#fenced_code_block_git_commit" }, { "include": "#fenced_code_block_git_rebase" }, { "include": "#fenced_code_block_go" }, { "include": "#fenced_code_block_groovy" }, { "include": "#fenced_code_block_pug" }, { "include": "#fenced_code_block_js" }, { "include": "#fenced_code_block_js_regexp" }, { "include": "#fenced_code_block_json" }, { "include": "#fenced_code_block_jsonc" }, { "include": "#fenced_code_block_less" }, { "include": "#fenced_code_block_objc" }, { "include": "#fenced_code_block_swift" }, { "include": "#fenced_code_block_scss" }, { "include": "#fenced_code_block_perl6" }, { "include": "#fenced_code_block_powershell" }, { "include": "#fenced_code_block_python" }, { "include": "#fenced_code_block_julia" }, { "include": "#fenced_code_block_regexp_python" }, { "include": "#fenced_code_block_rust" }, { "include": "#fenced_code_block_scala" }, { "include": "#fenced_code_block_shell" }, { "include": "#fenced_code_block_ts" }, { "include": "#fenced_code_block_tsx" }, { "include": "#fenced_code_block_csharp" }, { "include": "#fenced_code_block_fsharp" }, { "include": "#fenced_code_block_dart" }, { "include": "#fenced_code_block_handlebars" }, { "include": "#fenced_code_block_markdown" }, { "include": "#fenced_code_block_log" }, { "include": "#fenced_code_block_erlang" }, { "include": "#fenced_code_block_elixir" }, { "include": "#fenced_code_block_latex" }, { "include": "#fenced_code_block_bibtex" }, { "include": "#fenced_code_block_twig" }, { "include": "#fenced_code_block_unknown" }] }, "fenced_code_block_basic": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(html|htm|shtml|xhtml|inc|tmpl|tpl)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.html", "patterns": [{ "include": "text.html.basic" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_bibtex": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(bibtex)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.bibtex", "patterns": [{ "include": "text.bibtex" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_c": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(c|h)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.c", "patterns": [{ "include": "source.c" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_clojure": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(clj|cljs|clojure)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.clojure", "patterns": [{ "include": "source.clojure" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_coffee": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(coffee|Cakefile|coffee.erb)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.coffee", "patterns": [{ "include": "source.coffee" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_cpp": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(cpp|c\\+\\+|cxx)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.cpp source.cpp", "patterns": [{ "include": "source.cpp" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_csharp": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(cs|csharp|c#)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.csharp", "patterns": [{ "include": "source.cs" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_css": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(css|css.erb)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.css", "patterns": [{ "include": "source.css" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_dart": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(dart)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.dart", "patterns": [{ "include": "source.dart" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_diff": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(patch|diff|rej)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.diff", "patterns": [{ "include": "source.diff" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_dockerfile": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(dockerfile|Dockerfile)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.dockerfile", "patterns": [{ "include": "source.dockerfile" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_dosbatch": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(bat|batch)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.dosbatch", "patterns": [{ "include": "source.batchfile" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_elixir": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(elixir)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.elixir", "patterns": [{ "include": "source.elixir" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_erlang": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(erlang)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.erlang", "patterns": [{ "include": "source.erlang" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_fsharp": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(fs|fsharp|f#)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.fsharp", "patterns": [{ "include": "source.fsharp" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_git_commit": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(COMMIT_EDITMSG|MERGE_MSG)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.git_commit", "patterns": [{ "include": "text.git-commit" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_git_rebase": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(git-rebase-todo)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.git_rebase", "patterns": [{ "include": "text.git-rebase" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_go": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(go|golang)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.go", "patterns": [{ "include": "source.go" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_groovy": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(groovy|gvy)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.groovy", "patterns": [{ "include": "source.groovy" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_handlebars": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(handlebars|hbs)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.handlebars", "patterns": [{ "include": "text.html.handlebars" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_ini": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(ini|conf)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.ini", "patterns": [{ "include": "source.ini" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_java": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(java|bsh)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.java", "patterns": [{ "include": "source.java" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_js": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(js|jsx|javascript|es6|mjs|cjs|dataviewjs|\\{\\.js.+?\\})((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.javascript", "patterns": [{ "include": "source.js" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_js_regexp": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(regexp)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.js_regexp", "patterns": [{ "include": "source.js.regexp" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_json": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(json|json5|sublime-settings|sublime-menu|sublime-keymap|sublime-mousemap|sublime-theme|sublime-build|sublime-project|sublime-completions)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.json", "patterns": [{ "include": "source.json" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_jsonc": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(jsonc)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.jsonc", "patterns": [{ "include": "source.json.comments" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_julia": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(julia|\\{\\.julia.+?\\})((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.julia", "patterns": [{ "include": "source.julia" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_latex": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(latex|tex)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.latex", "patterns": [{ "include": "text.tex.latex" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_less": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(less)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.less", "patterns": [{ "include": "source.css.less" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_log": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(log)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.log", "patterns": [{ "include": "text.log" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_lua": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(lua)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.lua", "patterns": [{ "include": "source.lua" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_makefile": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(Makefile|makefile|GNUmakefile|OCamlMakefile)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.makefile", "patterns": [{ "include": "source.makefile" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_markdown": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(markdown|md)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.markdown", "patterns": [{ "include": "text.html.markdown" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_objc": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(objectivec|objective-c|mm|objc|obj-c|m|h)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.objc", "patterns": [{ "include": "source.objc" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_perl": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(perl|pl|pm|pod|t|PL|psgi|vcl)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.perl", "patterns": [{ "include": "source.perl" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_perl6": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(perl6|p6|pl6|pm6|nqp)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.perl6", "patterns": [{ "include": "source.perl.6" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_php": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(php|php3|php4|php5|phpt|phtml|aw|ctp)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.php", "patterns": [{ "include": "text.html.basic" }, { "include": "source.php" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_powershell": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(powershell|ps1|psm1|psd1)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.powershell", "patterns": [{ "include": "source.powershell" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_pug": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(jade|pug)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.pug", "patterns": [{ "include": "text.pug" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_python": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(python|py|py3|rpy|pyw|cpy|SConstruct|Sconstruct|sconstruct|SConscript|gyp|gypi|\\{\\.python.+?\\})((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.python", "patterns": [{ "include": "source.python" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_r": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(R|r|s|S|Rprofile|\\{\\.r.+?\\})((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.r", "patterns": [{ "include": "source.r" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_regexp_python": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(re)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.regexp_python", "patterns": [{ "include": "source.regexp.python" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_ruby": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(ruby|rb|rbx|rjs|Rakefile|rake|cgi|fcgi|gemspec|irbrc|Capfile|ru|prawn|Cheffile|Gemfile|Guardfile|Hobofile|Vagrantfile|Appraisals|Rantfile|Berksfile|Berksfile.lock|Thorfile|Puppetfile)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.ruby", "patterns": [{ "include": "source.ruby" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_rust": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(rust|rs|\\{\\.rust.+?\\})((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.rust", "patterns": [{ "include": "source.rust" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_scala": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(scala|sbt)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.scala", "patterns": [{ "include": "source.scala" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_scss": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(scss)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.scss", "patterns": [{ "include": "source.css.scss" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_shell": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(shell|sh|bash|zsh|bashrc|bash_profile|bash_login|profile|bash_logout|.textmate_init|\\{\\.bash.+?\\})((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.shellscript", "patterns": [{ "include": "source.shell" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_sql": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(sql|ddl|dml)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.sql", "patterns": [{ "include": "source.sql" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_swift": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(swift)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.swift", "patterns": [{ "include": "source.swift" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_ts": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(typescript|ts)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.typescript", "patterns": [{ "include": "source.ts" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_tsx": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(tsx)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.typescriptreact", "patterns": [{ "include": "source.tsx" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_twig": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(twig)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.twig", "patterns": [{ "include": "source.twig" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_unknown": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?=([^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown" }, "fenced_code_block_vs_net": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(vb)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.vs_net", "patterns": [{ "include": "source.asp.vb.net" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_xml": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(xml|xsd|tld|jsp|pt|cpt|dtml|rss|opml)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.xml", "patterns": [{ "include": "text.xml" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_xsl": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(xsl|xslt)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.xsl", "patterns": [{ "include": "text.xml.xsl" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "fenced_code_block_yaml": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(yaml|yml)((\\s+|:|,|\\{|\\?)[^`]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "begin": "(^|\\G)(\\s*)(.*)", "contentName": "meta.embedded.block.yaml", "patterns": [{ "include": "source.yaml" }], "while": "(^|\\G)(?!\\s*([`~]{3,})\\s*$)" }] }, "frontMatter": { "begin": "\\A-{3}\\s*$", "contentName": "meta.embedded.block.frontmatter", "end": "(^|\\G)-{3}|\\.{3}\\s*$", "patterns": [{ "include": "source.yaml" }] }, "heading": { "captures": { "1": { "patterns": [{ "captures": { "1": { "name": "punctuation.definition.heading.markdown" }, "2": { "name": "entity.name.section.markdown", "patterns": [{ "include": "#inline" }, { "include": "text.html.derivative" }] }, "3": { "name": "punctuation.definition.heading.markdown" } }, "match": "(#{6})\\s+(.*?)(?:\\s+(#+))?\\s*$", "name": "heading.6.markdown" }, { "captures": { "1": { "name": "punctuation.definition.heading.markdown" }, "2": { "name": "entity.name.section.markdown", "patterns": [{ "include": "#inline" }, { "include": "text.html.derivative" }] }, "3": { "name": "punctuation.definition.heading.markdown" } }, "match": "(#{5})\\s+(.*?)(?:\\s+(#+))?\\s*$", "name": "heading.5.markdown" }, { "captures": { "1": { "name": "punctuation.definition.heading.markdown" }, "2": { "name": "entity.name.section.markdown", "patterns": [{ "include": "#inline" }, { "include": "text.html.derivative" }] }, "3": { "name": "punctuation.definition.heading.markdown" } }, "match": "(#{4})\\s+(.*?)(?:\\s+(#+))?\\s*$", "name": "heading.4.markdown" }, { "captures": { "1": { "name": "punctuation.definition.heading.markdown" }, "2": { "name": "entity.name.section.markdown", "patterns": [{ "include": "#inline" }, { "include": "text.html.derivative" }] }, "3": { "name": "punctuation.definition.heading.markdown" } }, "match": "(#{3})\\s+(.*?)(?:\\s+(#+))?\\s*$", "name": "heading.3.markdown" }, { "captures": { "1": { "name": "punctuation.definition.heading.markdown" }, "2": { "name": "entity.name.section.markdown", "patterns": [{ "include": "#inline" }, { "include": "text.html.derivative" }] }, "3": { "name": "punctuation.definition.heading.markdown" } }, "match": "(#{2})\\s+(.*?)(?:\\s+(#+))?\\s*$", "name": "heading.2.markdown" }, { "captures": { "1": { "name": "punctuation.definition.heading.markdown" }, "2": { "name": "entity.name.section.markdown", "patterns": [{ "include": "#inline" }, { "include": "text.html.derivative" }] }, "3": { "name": "punctuation.definition.heading.markdown" } }, "match": "(#{1})\\s+(.*?)(?:\\s+(#+))?\\s*$", "name": "heading.1.markdown" }] } }, "match": "(?:^|\\G)[ ]{0,3}(#{1,6}\\s+(.*?)(\\s+#{1,6})?\\s*)$", "name": "markup.heading.markdown" }, "heading-setext": { "patterns": [{ "match": "^(={3,})(?=[ \\t]*$\\n?)", "name": "markup.heading.setext.1.markdown" }, { "match": "^(-{3,})(?=[ \\t]*$\\n?)", "name": "markup.heading.setext.2.markdown" }] }, "html": { "patterns": [{ "begin": "(^|\\G)\\s*(<!--)", "captures": { "1": { "name": "punctuation.definition.comment.html" }, "2": { "name": "punctuation.definition.comment.html" } }, "end": "(-->)", "name": "comment.block.html" }, { "begin": "(?i)(^|\\G)\\s*(?=<(script|style|pre)(\\s|$|>)(?!.*?</(script|style|pre)>))", "end": "(?i)(.*)((</)(script|style|pre)(>))", "endCaptures": { "1": { "patterns": [{ "include": "text.html.derivative" }] }, "2": { "name": "meta.tag.structure.$4.end.html" }, "3": { "name": "punctuation.definition.tag.begin.html" }, "4": { "name": "entity.name.tag.html" }, "5": { "name": "punctuation.definition.tag.end.html" } }, "patterns": [{ "begin": "(\\s*|$)", "patterns": [{ "include": "text.html.derivative" }], "while": "(?i)^(?!.*</(script|style|pre)>)" }] }, { "begin": "(?i)(^|\\G)\\s*(?=</?[a-zA-Z]+[^\\s/&gt;]*(\\s|$|/?>))", "patterns": [{ "include": "text.html.derivative" }], "while": "^(?!\\s*$)" }, { "begin": "(^|\\G)\\s*(?=(<[a-zA-Z0-9\\-](/?>|\\s.*?>)|</[a-zA-Z0-9\\-]>)\\s*$)", "patterns": [{ "include": "text.html.derivative" }], "while": "^(?!\\s*$)" }] }, "image-inline": { "captures": { "1": { "name": "punctuation.definition.link.description.begin.markdown" }, "2": { "name": "string.other.link.description.markdown" }, "4": { "name": "punctuation.definition.link.description.end.markdown" }, "5": { "name": "punctuation.definition.metadata.markdown" }, "7": { "name": "punctuation.definition.link.markdown" }, "8": { "name": "markup.underline.link.image.markdown" }, "9": { "name": "punctuation.definition.link.markdown" }, "10": { "name": "markup.underline.link.image.markdown" }, "12": { "name": "string.other.link.description.title.markdown" }, "13": { "name": "punctuation.definition.string.begin.markdown" }, "14": { "name": "punctuation.definition.string.end.markdown" }, "15": { "name": "string.other.link.description.title.markdown" }, "16": { "name": "punctuation.definition.string.begin.markdown" }, "17": { "name": "punctuation.definition.string.end.markdown" }, "18": { "name": "string.other.link.description.title.markdown" }, "19": { "name": "punctuation.definition.string.begin.markdown" }, "20": { "name": "punctuation.definition.string.end.markdown" }, "21": { "name": "punctuation.definition.metadata.markdown" } }, "match": `(?x)
  (\\!\\[)((?<square>[^\\[\\]\\\\]|\\\\.|\\[\\g<square>*+\\])*+)(\\])
                # Match the link text.
  (\\()            # Opening paren for url
    # The url
      [ \\t]*
      (
         (<)((?:\\\\[<>]|[^<>\\n])*)(>)
         | ((?<url>(?>[^\\s()]+)|\\(\\g<url>*\\))*)
      )
      [ \\t]*
    (?:
        ((\\().+?(\\)))    # Match title in parens…
      | ((").+?("))    # or in double quotes…
      | ((').+?('))    # or in single quotes.
    )?            # Title is optional
    \\s*            # Optional whitespace
  (\\))
`, "name": "meta.image.inline.markdown" }, "image-ref": { "captures": { "1": { "name": "punctuation.definition.link.description.begin.markdown" }, "2": { "name": "string.other.link.description.markdown" }, "4": { "name": "punctuation.definition.link.description.end.markdown" }, "5": { "name": "punctuation.definition.constant.markdown" }, "6": { "name": "constant.other.reference.link.markdown" }, "7": { "name": "punctuation.definition.constant.markdown" } }, "match": "(\\!\\[)((?<square>[^\\[\\]\\\\]|\\\\.|\\[\\g<square>*+\\])*+)(\\])[ ]?(\\[)(.*?)(\\])", "name": "meta.image.reference.markdown" }, "inline": { "patterns": [{ "include": "#ampersand" }, { "include": "#bracket" }, { "include": "#bold" }, { "include": "#italic" }, { "include": "#raw" }, { "include": "#strikethrough" }, { "include": "#escape" }, { "include": "#image-inline" }, { "include": "#image-ref" }, { "include": "#link-email" }, { "include": "#link-inet" }, { "include": "#link-inline" }, { "include": "#link-ref" }, { "include": "#link-ref-literal" }, { "include": "#link-ref-shortcut" }] }, "italic": { "begin": "(?x) (?<open>(\\*(?=\\w)|(?<!\\w)\\*|(?<!\\w)\\b_))(?=\\S)                # Open\n  (?=\n    (\n      <[^>]*+>              # HTML tags\n      | (?<raw>`+)([^`]|(?!(?<!`)\\k<raw>(?!`))`)*+\\k<raw>\n                        # Raw\n      | \\\\[\\\\`*_{}\\[\\]()#.!+\\->]?+      # Escapes\n      | \\[\n      (\n          (?<square>          # Named group\n            [^\\[\\]\\\\]        # Match most chars\n            | \\\\.            # Escaped chars\n            | \\[ \\g<square>*+ \\]    # Nested brackets\n          )*+\n        \\]\n        (\n          (              # Reference Link\n            [ ]?          # Optional space\n            \\[[^\\]]*+\\]        # Ref name\n          )\n          | (              # Inline Link\n            \\(            # Opening paren\n              [ \\t]*+        # Optional whtiespace\n              <?(.*?)>?      # URL\n              [ \\t]*+        # Optional whtiespace\n              (          # Optional Title\n                (?<title>['\"])\n                (.*?)\n                \\k<title>\n              )?\n            \\)\n          )\n        )\n      )\n      | \\k<open>\\k<open>                   # Must be bold closer\n      | (?!(?<=\\S)\\k<open>).            # Everything besides\n                        # style closer\n    )++\n    (?<=\\S)(?=_\\b|\\*)\\k<open>                # Close\n  )\n", "captures": { "1": { "name": "punctuation.definition.italic.markdown" } }, "end": "(?<=\\S)(\\1)((?!\\1)|(?=\\1\\1))", "name": "markup.italic.markdown", "patterns": [{ "applyEndPatternLast": 1, "begin": "(?=<[^>]*?>)", "end": "(?<=>)", "patterns": [{ "include": "text.html.derivative" }] }, { "include": "#escape" }, { "include": "#ampersand" }, { "include": "#bracket" }, { "include": "#raw" }, { "include": "#bold" }, { "include": "#image-inline" }, { "include": "#link-inline" }, { "include": "#link-inet" }, { "include": "#link-email" }, { "include": "#image-ref" }, { "include": "#link-ref-literal" }, { "include": "#link-ref" }, { "include": "#link-ref-shortcut" }, { "include": "#strikethrough" }] }, "link-def": { "captures": { "1": { "name": "punctuation.definition.constant.markdown" }, "2": { "name": "constant.other.reference.link.markdown" }, "3": { "name": "punctuation.definition.constant.markdown" }, "4": { "name": "punctuation.separator.key-value.markdown" }, "5": { "name": "punctuation.definition.link.markdown" }, "6": { "name": "markup.underline.link.markdown" }, "7": { "name": "punctuation.definition.link.markdown" }, "8": { "name": "markup.underline.link.markdown" }, "9": { "name": "string.other.link.description.title.markdown" }, "10": { "name": "punctuation.definition.string.begin.markdown" }, "11": { "name": "punctuation.definition.string.end.markdown" }, "12": { "name": "string.other.link.description.title.markdown" }, "13": { "name": "punctuation.definition.string.begin.markdown" }, "14": { "name": "punctuation.definition.string.end.markdown" }, "15": { "name": "string.other.link.description.title.markdown" }, "16": { "name": "punctuation.definition.string.begin.markdown" }, "17": { "name": "punctuation.definition.string.end.markdown" } }, "match": `(?x)
  \\s*            # Leading whitespace
  (\\[)([^]]+?)(\\])(:)    # Reference name
  [ \\t]*          # Optional whitespace
  (?:(<)((?:\\\\[<>]|[^<>\\n])*)(>)|(\\S+?))      # The url
  [ \\t]*          # Optional whitespace
  (?:
      ((\\().+?(\\)))    # Match title in parens…
    | ((").+?("))    # or in double quotes…
    | ((').+?('))    # or in single quotes.
  )?            # Title is optional
  \\s*            # Optional whitespace
  $
`, "name": "meta.link.reference.def.markdown" }, "link-email": { "captures": { "1": { "name": "punctuation.definition.link.markdown" }, "2": { "name": "markup.underline.link.markdown" }, "4": { "name": "punctuation.definition.link.markdown" } }, "match": "(<)((?:mailto:)?[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*)(>)", "name": "meta.link.email.lt-gt.markdown" }, "link-inet": { "captures": { "1": { "name": "punctuation.definition.link.markdown" }, "2": { "name": "markup.underline.link.markdown" }, "3": { "name": "punctuation.definition.link.markdown" } }, "match": "(<)((?:https?|ftp)://.*?)(>)", "name": "meta.link.inet.markdown" }, "link-inline": { "captures": { "1": { "name": "punctuation.definition.link.title.begin.markdown" }, "2": { "name": "string.other.link.title.markdown", "patterns": [{ "include": "#raw" }, { "include": "#bold" }, { "include": "#italic" }, { "include": "#strikethrough" }, { "include": "#image-inline" }] }, "4": { "name": "punctuation.definition.link.title.end.markdown" }, "5": { "name": "punctuation.definition.metadata.markdown" }, "7": { "name": "punctuation.definition.link.markdown" }, "8": { "name": "markup.underline.link.markdown" }, "9": { "name": "punctuation.definition.link.markdown" }, "10": { "name": "markup.underline.link.markdown" }, "12": { "name": "string.other.link.description.title.markdown" }, "13": { "name": "punctuation.definition.string.begin.markdown" }, "14": { "name": "punctuation.definition.string.end.markdown" }, "15": { "name": "string.other.link.description.title.markdown" }, "16": { "name": "punctuation.definition.string.begin.markdown" }, "17": { "name": "punctuation.definition.string.end.markdown" }, "18": { "name": "string.other.link.description.title.markdown" }, "19": { "name": "punctuation.definition.string.begin.markdown" }, "20": { "name": "punctuation.definition.string.end.markdown" }, "21": { "name": "punctuation.definition.metadata.markdown" } }, "match": `(?x)
  (\\[)((?<square>[^\\[\\]\\\\]|\\\\.|\\[\\g<square>*+\\])*+)(\\])
                # Match the link text.
  (\\()            # Opening paren for url
    # The url
      [ \\t]*
      (
         (<)((?:\\\\[<>]|[^<>\\n])*)(>)
         | ((?<url>(?>[^\\s()]+)|\\(\\g<url>*\\))*)
      )
      [ \\t]*
    # The title  
    (?:
        ((\\()[^()]*(\\)))    # Match title in parens…
      | ((")[^"]*("))    # or in double quotes…
      | ((')[^']*('))    # or in single quotes.
    )?            # Title is optional
    \\s*            # Optional whitespace
  (\\))
`, "name": "meta.link.inline.markdown" }, "link-ref": { "captures": { "1": { "name": "punctuation.definition.link.title.begin.markdown" }, "2": { "name": "string.other.link.title.markdown", "patterns": [{ "include": "#raw" }, { "include": "#bold" }, { "include": "#italic" }, { "include": "#strikethrough" }, { "include": "#image-inline" }] }, "4": { "name": "punctuation.definition.link.title.end.markdown" }, "5": { "name": "punctuation.definition.constant.begin.markdown" }, "6": { "name": "constant.other.reference.link.markdown" }, "7": { "name": "punctuation.definition.constant.end.markdown" } }, "match": "(?<![\\]\\\\])(\\[)((?<square>[^\\[\\]\\\\]|\\\\.|\\[\\g<square>*+\\])*+)(\\])(\\[)([^\\]]*+)(\\])", "name": "meta.link.reference.markdown" }, "link-ref-literal": { "captures": { "1": { "name": "punctuation.definition.link.title.begin.markdown" }, "2": { "name": "string.other.link.title.markdown" }, "4": { "name": "punctuation.definition.link.title.end.markdown" }, "5": { "name": "punctuation.definition.constant.begin.markdown" }, "6": { "name": "punctuation.definition.constant.end.markdown" } }, "match": "(?<![\\]\\\\])(\\[)((?<square>[^\\[\\]\\\\]|\\\\.|\\[\\g<square>*+\\])*+)(\\])[ ]?(\\[)(\\])", "name": "meta.link.reference.literal.markdown" }, "link-ref-shortcut": { "captures": { "1": { "name": "punctuation.definition.link.title.begin.markdown" }, "2": { "name": "string.other.link.title.markdown" }, "3": { "name": "punctuation.definition.link.title.end.markdown" } }, "match": "(?<![\\]\\\\])(\\[)((?:[^\\s\\[\\]\\\\]|\\\\[\\[\\]])+?)((?<!\\\\)\\])", "name": "meta.link.reference.markdown" }, "list_paragraph": { "begin": "(^|\\G)(?=\\S)(?![*+->]\\s|[0-9]+\\.\\s)", "name": "meta.paragraph.markdown", "patterns": [{ "include": "#inline" }, { "include": "text.html.derivative" }, { "include": "#heading-setext" }], "while": "(^|\\G)(?!\\s*$|#|[ ]{0,3}([-*_>][ ]{2,}){3,}[ \\t]*$\\n?|[ ]{0,3}[*+->]|[ ]{0,3}[0-9]+\\.)" }, "lists": { "patterns": [{ "begin": "(^|\\G)([ ]{0,3})([*+-])([ \\t])", "beginCaptures": { "3": { "name": "punctuation.definition.list.begin.markdown" } }, "comment": "Currently does not support un-indented second lines.", "name": "markup.list.unnumbered.markdown", "patterns": [{ "include": "#block" }, { "include": "#list_paragraph" }], "while": "((^|\\G)([ ]{2,4}|\\t))|(^[ \\t]*$)" }, { "begin": "(^|\\G)([ ]{0,3})([0-9]+[\\.\\)])([ \\t])", "beginCaptures": { "3": { "name": "punctuation.definition.list.begin.markdown" } }, "name": "markup.list.numbered.markdown", "patterns": [{ "include": "#block" }, { "include": "#list_paragraph" }], "while": "((^|\\G)([ ]{2,4}|\\t))|(^[ \\t]*$)" }] }, "paragraph": { "begin": "(^|\\G)[ ]{0,3}(?=[^ \\t\\n])", "name": "meta.paragraph.markdown", "patterns": [{ "include": "#inline" }, { "include": "text.html.derivative" }, { "include": "#heading-setext" }], "while": "(^|\\G)((?=\\s*[-=]{3,}\\s*$)|[ ]{4,}(?=[^ \\t\\n]))" }, "raw": { "captures": { "1": { "name": "punctuation.definition.raw.markdown" }, "3": { "name": "punctuation.definition.raw.markdown" } }, "match": "(`+)((?:[^`]|(?!(?<!`)\\1(?!`))`)*+)(\\1)", "name": "markup.inline.raw.string.markdown" }, "raw_block": { "begin": "(^|\\G)([ ]{4}|\\t)", "name": "markup.raw.block.markdown", "while": "(^|\\G)([ ]{4}|\\t)" }, "separator": { "match": "(^|\\G)[ ]{0,3}([\\*\\-\\_])([ ]{0,2}\\2){2,}[ \\t]*$\\n?", "name": "meta.separator.markdown" }, "strikethrough": { "captures": { "1": { "name": "punctuation.definition.strikethrough.markdown" }, "2": { "patterns": [{ "applyEndPatternLast": 1, "begin": "(?=<[^>]*?>)", "end": "(?<=>)", "patterns": [{ "include": "text.html.derivative" }] }, { "include": "#escape" }, { "include": "#ampersand" }, { "include": "#bracket" }, { "include": "#raw" }, { "include": "#bold" }, { "include": "#italic" }, { "include": "#image-inline" }, { "include": "#link-inline" }, { "include": "#link-inet" }, { "include": "#link-email" }, { "include": "#image-ref" }, { "include": "#link-ref-literal" }, { "include": "#link-ref" }, { "include": "#link-ref-shortcut" }] }, "3": { "name": "punctuation.definition.strikethrough.markdown" } }, "match": "(?<!\\\\)(~{2,})((?:[^~]|(?!(?<![~\\\\])\\1(?!~))~)*+)(\\1)", "name": "markup.strikethrough.markdown" }, "table": { "begin": "(^|\\G)(\\|)(?=[^|].+\\|\\s*$)", "beginCaptures": { "2": { "name": "punctuation.definition.table.markdown" } }, "name": "markup.table.markdown", "patterns": [{ "match": "\\|", "name": "punctuation.definition.table.markdown" }, { "captures": { "1": { "name": "punctuation.separator.table.markdown" } }, "match": "(?<=\\|)\\s*(:?-+:?)\\s*(?=\\|)" }, { "captures": { "1": { "patterns": [{ "include": "#inline" }] } }, "match": "(?<=\\|)\\s*(?=\\S)((\\\\\\||[^|])+)(?<=\\S)\\s*(?=\\|)" }], "while": "(^|\\G)(?=\\|)" } }, "scopeName": "text.html.markdown", "embeddedLangs": [], "aliases": ["md"], "embeddedLangsLazy": ["css", "html", "ini", "java", "lua", "make", "perl", "r", "ruby", "php", "sql", "vb", "xml", "xsl", "yaml", "bat", "clojure", "coffee", "c", "cpp", "diff", "docker", "git-commit", "git-rebase", "go", "groovy", "pug", "javascript", "json", "jsonc", "less", "objective-c", "swift", "scss", "raku", "powershell", "python", "julia", "rust", "scala", "shellscript", "typescript", "tsx", "csharp", "fsharp", "dart", "handlebars", "erlang", "elixir", "latex", "bibtex"] });
var markdown = [
  lang$k
];
var lang$j = Object.freeze({ "displayName": "Sass", "fileTypes": ["sass"], "foldingStartMarker": "/\\*|^#|^\\*|^\\b|*#?region|^\\.", "foldingStopMarker": "\\*/|*#?endregion|^\\s*$", "name": "sass", "patterns": [{ "begin": "^(\\s*)(/\\*)", "end": "(\\*/)|^(?!\\s\\1)", "name": "comment.block.sass", "patterns": [{ "include": "#comment-tag" }, { "include": "#comment-param" }] }, { "match": "^[\\t ]*/?//[\\t ]*[SRI][\\t ]*$", "name": "keyword.other.sass.formatter.action" }, { "begin": "^[\\t ]*//[\\t ]*(import)[\\t ]*(css-variables)[\\t ]*(from)", "captures": { "1": { "name": "keyword.control" }, "2": { "name": "variable" }, "3": { "name": "keyword.control" } }, "end": "$\\n?", "name": "comment.import.css.variables", "patterns": [{ "include": "#import-quotes" }] }, { "include": "#double-slash" }, { "include": "#double-quoted" }, { "include": "#single-quoted" }, { "include": "#interpolation" }, { "include": "#curly-brackets" }, { "include": "#placeholder-selector" }, { "begin": "\\$[a-zA-Z0-9_-]+(?=:)", "captures": { "0": { "name": "variable.other.name" } }, "end": "$\\n?|(?=\\)\\s\\)|\\)\\n)", "name": "sass.script.maps", "patterns": [{ "include": "#double-slash" }, { "include": "#double-quoted" }, { "include": "#single-quoted" }, { "include": "#interpolation" }, { "include": "#variable" }, { "include": "#rgb-value" }, { "include": "#numeric" }, { "include": "#unit" }, { "include": "#flag" }, { "include": "#comma" }, { "include": "#function" }, { "include": "#function-content" }, { "include": "#operator" }, { "include": "#reserved-words" }, { "include": "#parent-selector" }, { "include": "#property-value" }, { "include": "#semicolon" }, { "include": "#dotdotdot" }] }, { "include": "#variable-root" }, { "include": "#numeric" }, { "include": "#unit" }, { "include": "#flag" }, { "include": "#comma" }, { "include": "#semicolon" }, { "include": "#dotdotdot" }, { "begin": "@include|\\+(?!\\W|\\d)", "captures": { "0": { "name": "keyword.control.at-rule.css.sass" } }, "end": "(?=\\n|\\()", "name": "support.function.name.sass.library" }, { "begin": "^(@use)", "captures": { "0": { "name": "keyword.control.at-rule.css.sass.use" } }, "end": "(?=\\n)", "name": "sass.use", "patterns": [{ "match": "as|with", "name": "support.type.css.sass" }, { "include": "#numeric" }, { "include": "#unit" }, { "include": "#variable-root" }, { "include": "#rgb-value" }, { "include": "#comma" }, { "include": "#parenthesis-open" }, { "include": "#parenthesis-close" }, { "include": "#colon" }, { "include": "#import-quotes" }] }, { "begin": "^@import(.*?)( as.*)?$", "captures": { "1": { "name": "constant.character.css.sass" }, "2": { "name": "invalid" } }, "end": "(?=\\n)", "name": "keyword.control.at-rule.use" }, { "begin": "@mixin|^[\\t ]*=|@function", "captures": { "0": { "name": "keyword.control.at-rule.css.sass" } }, "end": "$\\n?|(?=\\()", "name": "support.function.name.sass", "patterns": [{ "match": "[\\w-]+", "name": "entity.name.function" }] }, { "begin": "@", "end": "$\\n?|\\s(?!(all|braille|embossed|handheld|print|projection|screen|speech|tty|tv|if|only|not)(\\s|,))", "name": "keyword.control.at-rule.css.sass" }, { "begin": "(?<!\\-|\\()\\b(a|abbr|acronym|address|applet|area|article|aside|audio|b|base|big|blockquote|body|br|button|canvas|caption|cite|code|col|colgroup|datalist|dd|del|details|dfn|dialog|div|dl|dt|em|embed|eventsource|fieldset|figure|figcaption|footer|form|frame|frameset|(h[1-6])|head|header|hgroup|hr|html|i|iframe|img|input|ins|kbd|label|legend|li|link|map|mark|menu|meta|meter|nav|noframes|noscript|object|ol|optgroup|option|output|p|param|picture|pre|progress|q|samp|script|section|select|small|source|span|strike|strong|style|sub|summary|sup|table|tbody|td|textarea|tfoot|th|thead|time|title|tr|tt|ul|var|video|main|svg|rect|ruby|center|circle|ellipse|line|polyline|polygon|path|text|u|slot)\\b(?!-|\\)|:\\s)|&", "end": "$\\n?|(?=\\s|,|\\(|\\)|\\.|\\#|\\[|>|-|_)", "name": "entity.name.tag.css.sass.symbol", "patterns": [{ "include": "#interpolation" }, { "include": "#pseudo-class" }] }, { "begin": "#", "end": "$\\n?|(?=\\s|,|\\(|\\)|\\.|\\[|>)", "name": "entity.other.attribute-name.id.css.sass", "patterns": [{ "include": "#interpolation" }, { "include": "#pseudo-class" }] }, { "begin": "\\.|(?<=&)(-|_)", "end": "$\\n?|(?=\\s|,|\\(|\\)|\\[|>)", "name": "entity.other.attribute-name.class.css.sass", "patterns": [{ "include": "#interpolation" }, { "include": "#pseudo-class" }] }, { "begin": "\\[", "end": "\\]", "name": "entity.other.attribute-selector.sass", "patterns": [{ "include": "#double-quoted" }, { "include": "#single-quoted" }, { "match": "\\^|\\$|\\*|~", "name": "keyword.other.regex.sass" }] }, { "match": "^((?<=\\]|\\)|not\\(|\\*|>|>\\s)|\n*):[a-z:-]+|(::|:-)[a-z:-]+", "name": "entity.other.attribute-name.pseudo-class.css.sass" }, { "include": "#module" }, { "match": "[\\w-]*\\(", "name": "entity.name.function" }, { "match": "\\)", "name": "entity.name.function.close" }, { "begin": ":", "end": "$\\n?|(?=\\s\\(|and\\(|\\),)", "name": "meta.property-list.css.sass.prop", "patterns": [{ "match": "(?<=:)[a-z-]+\\s", "name": "support.type.property-name.css.sass.prop.name" }, { "include": "#double-slash" }, { "include": "#double-quoted" }, { "include": "#single-quoted" }, { "include": "#interpolation" }, { "include": "#curly-brackets" }, { "include": "#variable" }, { "include": "#rgb-value" }, { "include": "#numeric" }, { "include": "#unit" }, { "include": "#module" }, { "match": "--.+?(?=\\))", "name": "variable.css" }, { "match": "[\\w-]*\\(", "name": "entity.name.function" }, { "match": "\\)", "name": "entity.name.function.close" }, { "include": "#flag" }, { "include": "#comma" }, { "include": "#semicolon" }, { "include": "#function" }, { "include": "#function-content" }, { "include": "#operator" }, { "include": "#parent-selector" }, { "include": "#property-value" }] }, { "include": "#rgb-value" }, { "include": "#function" }, { "include": "#function-content" }, { "begin": "(?<=})(?!\\n|\\(|\\)|[a-zA-Z0-9_-]+:)", "end": "\\s|(?=,|\\.|\\[|\\)|\\n)", "name": "entity.name.tag.css.sass", "patterns": [{ "include": "#interpolation" }, { "include": "#pseudo-class" }] }, { "include": "#operator" }, { "match": "[a-z-]+((?=:|#{))", "name": "support.type.property-name.css.sass.prop.name" }, { "include": "#reserved-words" }, { "include": "#property-value" }], "repository": { "colon": { "match": ":", "name": "meta.property-list.css.sass.colon" }, "comma": { "match": "\\band\\b|\\bor\\b|,", "name": "comment.punctuation.comma.sass" }, "comment-param": { "match": "\\@(\\w+)", "name": "storage.type.class.jsdoc" }, "comment-tag": { "begin": "(?<={{)", "end": "(?=}})", "name": "comment.tag.sass" }, "curly-brackets": { "match": "{|}", "name": "invalid" }, "dotdotdot": { "match": "\\.\\.\\.", "name": "variable.other" }, "double-quoted": { "begin": '"', "end": '"', "name": "string.quoted.double.css.sass", "patterns": [{ "include": "#quoted-interpolation" }] }, "double-slash": { "begin": "//", "end": "$\\n?", "name": "comment.line.sass", "patterns": [{ "include": "#comment-tag" }] }, "flag": { "match": "!(important|default|optional|global)", "name": "keyword.other.important.css.sass" }, "function": { "match": "(?<=[\\s|\\(|,|:])(?!url|format|attr)[a-zA-Z0-9_-][\\w-]*(?=\\()", "name": "support.function.name.sass" }, "function-content": { "begin": "(?<=url\\(|format\\(|attr\\()", "end": ".(?=\\))", "name": "string.quoted.double.css.sass" }, "import-quotes": { "match": `["']?\\.{0,2}[\\w/]+["']?`, "name": "constant.character.css.sass" }, "interpolation": { "begin": "#{", "end": "}", "name": "support.function.interpolation.sass", "patterns": [{ "include": "#variable" }, { "include": "#numeric" }, { "include": "#operator" }, { "include": "#unit" }, { "include": "#comma" }, { "include": "#double-quoted" }, { "include": "#single-quoted" }] }, "module": { "captures": { "1": { "name": "constant.character.module.name" }, "2": { "name": "constant.numeric.module.dot" } }, "match": "([\\w-]+?)(\\.)", "name": "constant.character.module" }, "numeric": { "match": "(-|\\.)?[0-9]+(\\.[0-9]+)?", "name": "constant.numeric.css.sass" }, "operator": { "match": "\\+|\\s-\\s|\\s-(?=\\$)|(?<=\\()-(?=\\$)|\\s-(?=\\()|\\*|/|%|=|!|<|>|~", "name": "keyword.operator.sass" }, "parent-selector": { "match": "&", "name": "entity.name.tag.css.sass" }, "parenthesis-close": { "match": "\\)", "name": "entity.name.function.parenthesis.close" }, "parenthesis-open": { "match": "\\(", "name": "entity.name.function.parenthesis.open" }, "placeholder-selector": { "begin": "(?<!\\d)%(?!\\d)", "end": "$\\n?|\\s", "name": "entity.other.inherited-class.placeholder-selector.css.sass" }, "property-value": { "match": "[a-zA-Z0-9_-]+", "name": "meta.property-value.css.sass support.constant.property-value.css.sass" }, "pseudo-class": { "match": ":[a-z:-]+", "name": "entity.other.attribute-name.pseudo-class.css.sass" }, "quoted-interpolation": { "begin": "#{", "end": "}", "name": "support.function.interpolation.sass", "patterns": [{ "include": "#variable" }, { "include": "#numeric" }, { "include": "#operator" }, { "include": "#unit" }, { "include": "#comma" }] }, "reserved-words": { "match": "\\b(false|from|in|not|null|through|to|true)\\b", "name": "support.type.property-name.css.sass" }, "rgb-value": { "match": "(#)([0-9a-fA-F]{3,4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})\\b", "name": "constant.language.color.rgb-value.css.sass" }, "semicolon": { "match": ";", "name": "invalid" }, "single-quoted": { "begin": "'", "end": "'", "name": "string.quoted.single.css.sass", "patterns": [{ "include": "#quoted-interpolation" }] }, "unit": { "match": "(?<=[\\d]|})(ch|cm|deg|dpcm|dpi|dppx|em|ex|grad|Hz|in|kHz|mm|ms|pc|pt|px|rad|rem|s|turn|vh|vmax|vmin|vw|fr|%)", "name": "keyword.control.unit.css.sass" }, "variable": { "match": "\\$[a-zA-Z0-9_-]+", "name": "variable.other.value" }, "variable-root": { "match": "\\$[a-zA-Z0-9_-]+", "name": "variable.other.root" } }, "scopeName": "source.sass" });
var sass = [
  lang$j
];
var lang$i = Object.freeze({ "displayName": "SCSS", "name": "scss", "patterns": [{ "include": "#variable_setting" }, { "include": "#at_rule_forward" }, { "include": "#at_rule_use" }, { "include": "#at_rule_include" }, { "include": "#at_rule_import" }, { "include": "#general" }, { "include": "#flow_control" }, { "include": "#rules" }, { "include": "#property_list" }, { "include": "#at_rule_mixin" }, { "include": "#at_rule_media" }, { "include": "#at_rule_function" }, { "include": "#at_rule_charset" }, { "include": "#at_rule_option" }, { "include": "#at_rule_namespace" }, { "include": "#at_rule_fontface" }, { "include": "#at_rule_page" }, { "include": "#at_rule_keyframes" }, { "include": "#at_rule_at_root" }, { "include": "#at_rule_supports" }, { "match": ";", "name": "punctuation.terminator.rule.css" }], "repository": { "at_rule_at_root": { "begin": "\\s*((@)(at-root))(\\s+|$)", "beginCaptures": { "1": { "name": "keyword.control.at-rule.at-root.scss" }, "2": { "name": "punctuation.definition.keyword.scss" } }, "end": "\\s*(?={)", "name": "meta.at-rule.at-root.scss", "patterns": [{ "include": "#function_attributes" }, { "include": "#functions" }, { "include": "#selectors" }] }, "at_rule_charset": { "begin": "\\s*((@)charset\\b)\\s*", "captures": { "1": { "name": "keyword.control.at-rule.charset.scss" }, "2": { "name": "punctuation.definition.keyword.scss" } }, "end": "\\s*((?=;|$))", "name": "meta.at-rule.charset.scss", "patterns": [{ "include": "#variable" }, { "include": "#string_single" }, { "include": "#string_double" }] }, "at_rule_content": { "begin": "\\s*((@)content\\b)\\s*", "captures": { "1": { "name": "keyword.control.content.scss" } }, "end": "\\s*((?=;))", "name": "meta.content.scss", "patterns": [{ "include": "#variable" }, { "include": "#selectors" }, { "include": "#property_values" }] }, "at_rule_each": { "begin": "\\s*((@)each\\b)\\s*", "captures": { "1": { "name": "keyword.control.each.scss" }, "2": { "name": "punctuation.definition.keyword.scss" } }, "end": "\\s*((?=}))", "name": "meta.at-rule.each.scss", "patterns": [{ "match": "\\b(in|,)\\b", "name": "keyword.control.operator" }, { "include": "#variable" }, { "include": "#property_values" }, { "include": "$self" }] }, "at_rule_else": { "begin": "\\s*((@)else(\\s*(if)?))\\s*", "captures": { "1": { "name": "keyword.control.else.scss" }, "2": { "name": "punctuation.definition.keyword.scss" } }, "end": "\\s*(?={)", "name": "meta.at-rule.else.scss", "patterns": [{ "include": "#conditional_operators" }, { "include": "#variable" }, { "include": "#property_values" }] }, "at_rule_extend": { "begin": "\\s*((@)extend\\b)\\s*", "captures": { "1": { "name": "keyword.control.at-rule.extend.scss" }, "2": { "name": "punctuation.definition.keyword.scss" } }, "end": "\\s*(?=;)", "name": "meta.at-rule.extend.scss", "patterns": [{ "include": "#variable" }, { "include": "#selectors" }, { "include": "#property_values" }] }, "at_rule_fontface": { "patterns": [{ "begin": "^\\s*((@)font-face\\b)", "beginCaptures": { "1": { "name": "keyword.control.at-rule.fontface.scss" }, "2": { "name": "punctuation.definition.keyword.scss" } }, "end": "\\s*(?={)", "name": "meta.at-rule.fontface.scss", "patterns": [{ "include": "#function_attributes" }] }] }, "at_rule_for": { "begin": "\\s*((@)for\\b)\\s*", "captures": { "1": { "name": "keyword.control.for.scss" }, "2": { "name": "punctuation.definition.keyword.scss" } }, "end": "\\s*(?={)", "name": "meta.at-rule.for.scss", "patterns": [{ "match": "(==|!=|<=|>=|<|>|from|to|through)", "name": "keyword.control.operator" }, { "include": "#variable" }, { "include": "#property_values" }, { "include": "$self" }] }, "at_rule_forward": { "begin": "\\s*((@)forward\\b)\\s*", "captures": { "1": { "name": "keyword.control.at-rule.forward.scss" }, "2": { "name": "punctuation.definition.keyword.scss" } }, "end": "\\s*(?=;)", "name": "meta.at-rule.forward.scss", "patterns": [{ "match": "\\b(as|hide|show)\\b", "name": "keyword.control.operator" }, { "captures": { "1": { "name": "entity.other.attribute-name.module.scss" }, "2": { "name": "punctuation.definition.wildcard.scss" } }, "match": "\\b([\\w-]+)(\\*)" }, { "match": "\\b[\\w-]+\\b", "name": "entity.name.function.scss" }, { "include": "#variable" }, { "include": "#string_single" }, { "include": "#string_double" }, { "include": "#comment_line" }, { "include": "#comment_block" }] }, "at_rule_function": { "patterns": [{ "begin": "\\s*((@)function\\b)\\s*", "captures": { "1": { "name": "keyword.control.at-rule.function.scss" }, "2": { "name": "punctuation.definition.keyword.scss" }, "3": { "name": "entity.name.function.scss" } }, "end": "\\s*(?={)", "name": "meta.at-rule.function.scss", "patterns": [{ "include": "#function_attributes" }] }, { "captures": { "1": { "name": "keyword.control.at-rule.function.scss" }, "2": { "name": "punctuation.definition.keyword.scss" }, "3": { "name": "entity.name.function.scss" } }, "match": "\\s*((@)function\\b)\\s*", "name": "meta.at-rule.function.scss" }] }, "at_rule_if": { "begin": "\\s*((@)if\\b)\\s*", "captures": { "1": { "name": "keyword.control.if.scss" }, "2": { "name": "punctuation.definition.keyword.scss" } }, "end": "\\s*(?={)", "name": "meta.at-rule.if.scss", "patterns": [{ "include": "#conditional_operators" }, { "include": "#variable" }, { "include": "#property_values" }] }, "at_rule_import": { "begin": "\\s*((@)import\\b)\\s*", "captures": { "1": { "name": "keyword.control.at-rule.import.scss" }, "2": { "name": "punctuation.definition.keyword.scss" } }, "end": "\\s*((?=;)|(?=}))", "name": "meta.at-rule.import.scss", "patterns": [{ "include": "#variable" }, { "include": "#string_single" }, { "include": "#string_double" }, { "include": "#functions" }, { "include": "#comment_line" }] }, "at_rule_include": { "patterns": [{ "begin": "(?<=@include)\\s+(?:([\\w-]+)\\s*(\\.))?([\\w-]+)\\s*(\\()", "beginCaptures": { "1": { "name": "variable.scss" }, "2": { "name": "punctuation.access.module.scss" }, "3": { "name": "entity.name.function.scss" }, "4": { "name": "punctuation.definition.parameters.begin.bracket.round.scss" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.parameters.end.bracket.round.scss" } }, "name": "meta.at-rule.include.scss", "patterns": [{ "include": "#function_attributes" }] }, { "captures": { "0": { "name": "meta.at-rule.include.scss" }, "1": { "name": "variable.scss" }, "2": { "name": "punctuation.access.module.scss" }, "3": { "name": "entity.name.function.scss" } }, "match": "(?<=@include)\\s+(?:([\\w-]+)\\s*(\\.))?([\\w-]+)" }, { "captures": { "0": { "name": "meta.at-rule.include.scss" }, "1": { "name": "keyword.control.at-rule.include.scss" }, "2": { "name": "punctuation.definition.keyword.scss" } }, "match": "((@)include)\\b" }] }, "at_rule_keyframes": { "begin": "(?<=^|\\s)(@)(?:-(?:webkit|moz)-)?keyframes\\b", "beginCaptures": { "0": { "name": "keyword.control.at-rule.keyframes.scss" }, "1": { "name": "punctuation.definition.keyword.scss" } }, "end": "(?<=})", "name": "meta.at-rule.keyframes.scss", "patterns": [{ "captures": { "1": { "name": "entity.name.function.scss" } }, "match": "(?<=@keyframes)\\s+((?:[_A-Za-z][-\\w]|-[_A-Za-z])[-\\w]*)" }, { "begin": '(?<=@keyframes)\\s+(")', "beginCaptures": { "1": { "name": "punctuation.definition.string.begin.scss" } }, "contentName": "entity.name.function.scss", "end": '"', "endCaptures": { "0": { "name": "punctuation.definition.string.end.scss" } }, "name": "string.quoted.double.scss", "patterns": [{ "match": "\\\\(\\h{1,6}|.)", "name": "constant.character.escape.scss" }, { "include": "#interpolation" }] }, { "begin": "(?<=@keyframes)\\s+(')", "beginCaptures": { "1": { "name": "punctuation.definition.string.begin.scss" } }, "contentName": "entity.name.function.scss", "end": "'", "endCaptures": { "0": { "name": "punctuation.definition.string.end.scss" } }, "name": "string.quoted.single.scss", "patterns": [{ "match": "\\\\(\\h{1,6}|.)", "name": "constant.character.escape.scss" }, { "include": "#interpolation" }] }, { "begin": "{", "beginCaptures": { "0": { "name": "punctuation.section.keyframes.begin.scss" } }, "end": "}", "endCaptures": { "0": { "name": "punctuation.section.keyframes.end.scss" } }, "patterns": [{ "match": "\\b(?:(?:100|[1-9]\\d|\\d)%|from|to)(?=\\s*{)", "name": "entity.other.attribute-name.scss" }, { "include": "#flow_control" }, { "include": "#interpolation" }, { "include": "#property_list" }, { "include": "#rules" }] }] }, "at_rule_media": { "patterns": [{ "begin": "^\\s*((@)media)\\b", "beginCaptures": { "1": { "name": "keyword.control.at-rule.media.scss" }, "2": { "name": "punctuation.definition.keyword.scss" } }, "end": "\\s*(?={)", "name": "meta.at-rule.media.scss", "patterns": [{ "include": "#comment_docblock" }, { "include": "#comment_block" }, { "include": "#comment_line" }, { "match": "\\b(only)\\b", "name": "keyword.control.operator.css.scss" }, { "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.media-query.begin.bracket.round.scss" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.media-query.end.bracket.round.scss" } }, "name": "meta.property-list.media-query.scss", "patterns": [{ "begin": "(?<![-a-z])(?=[-a-z])", "end": "$|(?![-a-z])", "name": "meta.property-name.media-query.scss", "patterns": [{ "include": "source.css#media-features" }, { "include": "source.css#property-names" }] }, { "begin": "(:)\\s*(?!(\\s*{))", "beginCaptures": { "1": { "name": "punctuation.separator.key-value.scss" } }, "contentName": "meta.property-value.media-query.scss", "end": "\\s*(;|(?=}|\\)))", "endCaptures": { "1": { "name": "punctuation.terminator.rule.scss" } }, "patterns": [{ "include": "#general" }, { "include": "#property_values" }] }] }, { "include": "#variable" }, { "include": "#conditional_operators" }, { "include": "source.css#media-types" }] }] }, "at_rule_mixin": { "patterns": [{ "begin": "(?<=@mixin)\\s+([\\w-]+)\\s*(\\()", "beginCaptures": { "1": { "name": "entity.name.function.scss" }, "2": { "name": "punctuation.definition.parameters.begin.bracket.round.scss" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.parameters.end.bracket.round.scss" } }, "name": "meta.at-rule.mixin.scss", "patterns": [{ "include": "#function_attributes" }] }, { "captures": { "1": { "name": "entity.name.function.scss" } }, "match": "(?<=@mixin)\\s+([\\w-]+)", "name": "meta.at-rule.mixin.scss" }, { "captures": { "1": { "name": "keyword.control.at-rule.mixin.scss" }, "2": { "name": "punctuation.definition.keyword.scss" } }, "match": "((@)mixin)\\b", "name": "meta.at-rule.mixin.scss" }] }, "at_rule_namespace": { "patterns": [{ "begin": "(?<=@namespace)\\s+(?=url)", "end": "(?=;|$)", "name": "meta.at-rule.namespace.scss", "patterns": [{ "include": "#property_values" }, { "include": "#string_single" }, { "include": "#string_double" }] }, { "begin": "(?<=@namespace)\\s+([\\w-]*)", "captures": { "1": { "name": "entity.name.namespace-prefix.scss" } }, "end": "(?=;|$)", "name": "meta.at-rule.namespace.scss", "patterns": [{ "include": "#variables" }, { "include": "#property_values" }, { "include": "#string_single" }, { "include": "#string_double" }] }, { "captures": { "1": { "name": "keyword.control.at-rule.namespace.scss" }, "2": { "name": "punctuation.definition.keyword.scss" } }, "match": "((@)namespace)\\b", "name": "meta.at-rule.namespace.scss" }] }, "at_rule_option": { "captures": { "1": { "name": "keyword.control.at-rule.charset.scss" }, "2": { "name": "punctuation.definition.keyword.scss" } }, "match": "^\\s*((@)option\\b)\\s*", "name": "meta.at-rule.option.scss" }, "at_rule_page": { "patterns": [{ "begin": "^\\s*((@)page)(?=:|\\s)\\s*([-:\\w]*)", "captures": { "1": { "name": "keyword.control.at-rule.page.scss" }, "2": { "name": "punctuation.definition.keyword.scss" }, "3": { "name": "entity.name.function.scss" } }, "end": "\\s*(?={)", "name": "meta.at-rule.page.scss" }] }, "at_rule_return": { "begin": "\\s*((@)(return)\\b)", "captures": { "1": { "name": "keyword.control.return.scss" }, "2": { "name": "punctuation.definition.keyword.scss" } }, "end": "\\s*((?=;))", "name": "meta.at-rule.return.scss", "patterns": [{ "include": "#variable" }, { "include": "#property_values" }] }, "at_rule_supports": { "begin": "(?<=^|\\s)(@)supports\\b", "captures": { "0": { "name": "keyword.control.at-rule.supports.scss" }, "1": { "name": "punctuation.definition.keyword.scss" } }, "end": "(?={)|$", "name": "meta.at-rule.supports.scss", "patterns": [{ "include": "#logical_operators" }, { "include": "#properties" }, { "match": "\\(", "name": "punctuation.definition.condition.begin.bracket.round.scss" }, { "match": "\\)", "name": "punctuation.definition.condition.end.bracket.round.scss" }] }, "at_rule_use": { "begin": "\\s*((@)use\\b)\\s*", "captures": { "1": { "name": "keyword.control.at-rule.use.scss" }, "2": { "name": "punctuation.definition.keyword.scss" } }, "end": "\\s*(?=;)", "name": "meta.at-rule.use.scss", "patterns": [{ "match": "\\b(as|with)\\b", "name": "keyword.control.operator" }, { "match": "\\b[\\w-]+\\b", "name": "variable.scss" }, { "match": "\\*", "name": "variable.language.expanded-namespace.scss" }, { "include": "#string_single" }, { "include": "#string_double" }, { "include": "#comment_line" }, { "include": "#comment_block" }, { "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.parameters.begin.bracket.round.scss" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.parameters.end.bracket.round.scss" } }, "patterns": [{ "include": "#function_attributes" }] }] }, "at_rule_warn": { "begin": "\\s*((@)(warn|debug|error)\\b)\\s*", "captures": { "1": { "name": "keyword.control.warn.scss" }, "2": { "name": "punctuation.definition.keyword.scss" } }, "end": "\\s*(?=;)", "name": "meta.at-rule.warn.scss", "patterns": [{ "include": "#variable" }, { "include": "#string_double" }, { "include": "#string_single" }] }, "at_rule_while": { "begin": "\\s*((@)while\\b)\\s*", "captures": { "1": { "name": "keyword.control.while.scss" }, "2": { "name": "punctuation.definition.keyword.scss" } }, "end": "\\s*(?=})", "name": "meta.at-rule.while.scss", "patterns": [{ "include": "#conditional_operators" }, { "include": "#variable" }, { "include": "#property_values" }, { "include": "$self" }] }, "comment_block": { "begin": "/\\*", "beginCaptures": { "0": { "name": "punctuation.definition.comment.scss" } }, "end": "\\*/", "endCaptures": { "0": { "name": "punctuation.definition.comment.scss" } }, "name": "comment.block.scss" }, "comment_docblock": { "begin": "///", "beginCaptures": { "0": { "name": "punctuation.definition.comment.scss" } }, "end": "(?=$)", "name": "comment.block.documentation.scss", "patterns": [{ "include": "source.sassdoc" }] }, "comment_line": { "begin": "//", "beginCaptures": { "0": { "name": "punctuation.definition.comment.scss" } }, "end": "\\n", "name": "comment.line.scss" }, "comparison_operators": { "match": "==|!=|<=|>=|<|>", "name": "keyword.operator.comparison.scss" }, "conditional_operators": { "patterns": [{ "include": "#comparison_operators" }, { "include": "#logical_operators" }] }, "constant_default": { "match": "!default", "name": "keyword.other.default.scss" }, "constant_functions": { "begin": "(?:([\\w-]+)(\\.))?([\\w-]+)(\\()", "beginCaptures": { "1": { "name": "variable.scss" }, "2": { "name": "punctuation.access.module.scss" }, "3": { "name": "support.function.misc.scss" }, "4": { "name": "punctuation.section.function.scss" } }, "end": "(\\))", "endCaptures": { "1": { "name": "punctuation.section.function.scss" } }, "patterns": [{ "include": "#parameters" }] }, "constant_important": { "match": "!important", "name": "keyword.other.important.scss" }, "constant_mathematical_symbols": { "match": "\\b(\\+|-|\\*|/)\\b", "name": "support.constant.mathematical-symbols.scss" }, "constant_optional": { "match": "!optional", "name": "keyword.other.optional.scss" }, "constant_sass_functions": { "begin": "(headings|stylesheet-url|rgba?|hsla?|ie-hex-str|red|green|blue|alpha|opacity|hue|saturation|lightness|prefixed|prefix|-moz|-svg|-css2|-pie|-webkit|-ms|font-(?:files|url)|grid-image|image-(?:width|height|url|color)|sprites?|sprite-(?:map|map-name|file|url|position)|inline-(?:font-files|image)|opposite-position|grad-point|grad-end-position|color-stops|color-stops-in-percentages|grad-color-stops|(?:radial|linear)-(?:gradient|svg-gradient)|opacify|fade-?in|transparentize|fade-?out|lighten|darken|saturate|desaturate|grayscale|adjust-(?:hue|lightness|saturation|color)|scale-(?:lightness|saturation|color)|change-color|spin|complement|invert|mix|-compass-(?:list|space-list|slice|nth|list-size)|blank|compact|nth|first-value-of|join|length|append|nest|append-selector|headers|enumerate|range|percentage|unitless|unit|if|type-of|comparable|elements-of-type|quote|unquote|escape|e|sin|cos|tan|abs|round|ceil|floor|pi|translate(?:X|Y))(\\()", "beginCaptures": { "1": { "name": "support.function.misc.scss" }, "2": { "name": "punctuation.section.function.scss" } }, "end": "(\\))", "endCaptures": { "1": { "name": "punctuation.section.function.scss" } }, "patterns": [{ "include": "#parameters" }] }, "flow_control": { "patterns": [{ "include": "#at_rule_if" }, { "include": "#at_rule_else" }, { "include": "#at_rule_warn" }, { "include": "#at_rule_for" }, { "include": "#at_rule_while" }, { "include": "#at_rule_each" }, { "include": "#at_rule_return" }] }, "function_attributes": { "patterns": [{ "match": ":", "name": "punctuation.separator.key-value.scss" }, { "include": "#general" }, { "include": "#property_values" }, { "match": "[={}\\?;@]", "name": "invalid.illegal.scss" }] }, "functions": { "patterns": [{ "begin": "([\\w-]{1,})(\\()\\s*", "beginCaptures": { "1": { "name": "support.function.misc.scss" }, "2": { "name": "punctuation.section.function.scss" } }, "end": "(\\))", "endCaptures": { "1": { "name": "punctuation.section.function.scss" } }, "patterns": [{ "include": "#parameters" }] }, { "match": "([\\w-]{1,})", "name": "support.function.misc.scss" }] }, "general": { "patterns": [{ "include": "#variable" }, { "include": "#comment_docblock" }, { "include": "#comment_block" }, { "include": "#comment_line" }] }, "interpolation": { "begin": "#{", "beginCaptures": { "0": { "name": "punctuation.definition.interpolation.begin.bracket.curly.scss" } }, "end": "}", "endCaptures": { "0": { "name": "punctuation.definition.interpolation.end.bracket.curly.scss" } }, "name": "variable.interpolation.scss", "patterns": [{ "include": "#variable" }, { "include": "#property_values" }] }, "logical_operators": { "match": "\\b(not|or|and)\\b", "name": "keyword.operator.logical.scss" }, "map": { "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.map.begin.bracket.round.scss" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.map.end.bracket.round.scss" } }, "name": "meta.definition.variable.map.scss", "patterns": [{ "include": "#comment_docblock" }, { "include": "#comment_block" }, { "include": "#comment_line" }, { "captures": { "1": { "name": "support.type.map.key.scss" }, "2": { "name": "punctuation.separator.key-value.scss" } }, "match": "\\b([\\w-]+)\\s*(:)" }, { "match": ",", "name": "punctuation.separator.delimiter.scss" }, { "include": "#map" }, { "include": "#variable" }, { "include": "#property_values" }] }, "operators": { "match": "[-+*/](?!\\s*[-+*/])", "name": "keyword.operator.css" }, "parameters": { "patterns": [{ "include": "#variable" }, { "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.begin.bracket.round.scss" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.end.bracket.round.scss" } }, "patterns": [{ "include": "#function_attributes" }] }, { "include": "#property_values" }, { "include": "#comment_block" }, { "match": `[^'",) \\t]+`, "name": "variable.parameter.url.scss" }, { "match": ",", "name": "punctuation.separator.delimiter.scss" }] }, "parent_selector_suffix": { "captures": { "1": { "name": "punctuation.definition.entity.css" }, "2": { "patterns": [{ "include": "#interpolation" }, { "match": "\\\\([0-9a-fA-F]{1,6}|.)", "name": "constant.character.escape.scss" }, { "match": "\\$|}", "name": "invalid.illegal.identifier.scss" }] } }, "match": "(?x)\n(?<=&)\n(\n  (?: [-a-zA-Z_0-9]|[^\\x00-\\x7F]     # Valid identifier characters\n    | \\\\(?:[0-9a-fA-F]{1,6}|.)       # Escape sequence\n    | \\#\\{                           # Interpolation (escaped to avoid Coffeelint errors)\n    | \\$                              # Possible start of interpolation variable\n    | }                                # Possible end of interpolation\n  )+\n)                                      # Followed by either:\n(?= $                                  # - End of the line\n  | [\\s,.\\#)\\[:{>+~|]               # - Another selector\n  | /\\*                               # - A block comment\n)", "name": "entity.other.attribute-name.parent-selector-suffix.css" }, "properties": { "patterns": [{ "begin": "(?<![-a-z])(?=[-a-z])", "end": "$|(?![-a-z])", "name": "meta.property-name.scss", "patterns": [{ "include": "source.css#property-names" }, { "include": "#at_rule_include" }] }, { "begin": "(:)\\s*(?!(\\s*{))", "beginCaptures": { "1": { "name": "punctuation.separator.key-value.scss" } }, "contentName": "meta.property-value.scss", "end": "\\s*(;|(?=}|\\)))", "endCaptures": { "1": { "name": "punctuation.terminator.rule.scss" } }, "patterns": [{ "include": "#general" }, { "include": "#property_values" }] }] }, "property_list": { "begin": "{", "beginCaptures": { "0": { "name": "punctuation.section.property-list.begin.bracket.curly.scss" } }, "end": "}", "endCaptures": { "0": { "name": "punctuation.section.property-list.end.bracket.curly.scss" } }, "name": "meta.property-list.scss", "patterns": [{ "include": "#flow_control" }, { "include": "#rules" }, { "include": "#properties" }, { "include": "$self" }] }, "property_values": { "patterns": [{ "include": "#string_single" }, { "include": "#string_double" }, { "include": "#constant_functions" }, { "include": "#constant_sass_functions" }, { "include": "#constant_important" }, { "include": "#constant_default" }, { "include": "#constant_optional" }, { "include": "source.css#numeric-values" }, { "include": "source.css#property-keywords" }, { "include": "source.css#color-keywords" }, { "include": "source.css#property-names" }, { "include": "#constant_mathematical_symbols" }, { "include": "#operators" }, { "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.begin.bracket.round.scss" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.end.bracket.round.scss" } }, "patterns": [{ "include": "#general" }, { "include": "#property_values" }] }] }, "rules": { "patterns": [{ "include": "#general" }, { "include": "#at_rule_extend" }, { "include": "#at_rule_content" }, { "include": "#at_rule_include" }, { "include": "#at_rule_media" }, { "include": "#selectors" }] }, "selector_attribute": { "captures": { "1": { "name": "punctuation.definition.attribute-selector.begin.bracket.square.scss" }, "2": { "name": "entity.other.attribute-name.attribute.scss", "patterns": [{ "include": "#interpolation" }, { "match": "\\\\([0-9a-fA-F]{1,6}|.)", "name": "constant.character.escape.scss" }, { "match": "\\$|}", "name": "invalid.illegal.scss" }] }, "3": { "name": "keyword.operator.scss" }, "4": { "name": "string.unquoted.attribute-value.scss", "patterns": [{ "include": "#interpolation" }, { "match": "\\\\([0-9a-fA-F]{1,6}|.)", "name": "constant.character.escape.scss" }, { "match": "\\$|}", "name": "invalid.illegal.scss" }] }, "5": { "name": "string.quoted.double.attribute-value.scss" }, "6": { "name": "punctuation.definition.string.begin.scss" }, "7": { "patterns": [{ "include": "#interpolation" }, { "match": "\\\\([0-9a-fA-F]{1,6}|.)", "name": "constant.character.escape.scss" }, { "match": "\\$|}", "name": "invalid.illegal.scss" }] }, "8": { "name": "punctuation.definition.string.end.scss" }, "9": { "name": "string.quoted.single.attribute-value.scss" }, "10": { "name": "punctuation.definition.string.begin.scss" }, "11": { "patterns": [{ "include": "#interpolation" }, { "match": "\\\\([0-9a-fA-F]{1,6}|.)", "name": "constant.character.escape.scss" }, { "match": "\\$|}", "name": "invalid.illegal.scss" }] }, "12": { "name": "punctuation.definition.string.end.scss" }, "13": { "name": "punctuation.definition.attribute-selector.end.bracket.square.scss" } }, "match": `(?xi)
(\\[)
\\s*
(
  (?:
    [-a-zA-Z_0-9]|[^\\x00-\\x7F]       # Valid identifier characters
    | \\\\(?:[0-9a-fA-F]{1,6}|.)       # Escape sequence
    | \\#\\{                           # Interpolation (escaped to avoid Coffeelint errors)
    | \\.?\\$                          # Possible start of interpolation variable
    | }                                # Possible end of interpolation
  )+?
)
(?:
  \\s*([~|^$*]?=)\\s*
  (?:
    (
      (?:
        [-a-zA-Z_0-9]|[^\\x00-\\x7F]       # Valid identifier characters
        | \\\\(?:[0-9a-fA-F]{1,6}|.)       # Escape sequence
        | \\#\\{                           # Interpolation (escaped to avoid Coffeelint errors)
        | \\.?\\$                          # Possible start of interpolation variable
        | }                                # Possible end of interpolation
      )+
    )
    |
    ((")(.*?)("))
    |
    ((')(.*?)('))
  )
)?
\\s*
(\\])`, "name": "meta.attribute-selector.scss" }, "selector_class": { "captures": { "1": { "name": "punctuation.definition.entity.css" }, "2": { "patterns": [{ "include": "#interpolation" }, { "match": "\\\\([0-9a-fA-F]{1,6}|.)", "name": "constant.character.escape.scss" }, { "match": "\\$|}", "name": "invalid.illegal.scss" }] } }, "match": "(?x)\n(\\.)                                  # Valid class-name\n(\n  (?: [-a-zA-Z_0-9]|[^\\x00-\\x7F]     # Valid identifier characters\n    | \\\\(?:[0-9a-fA-F]{1,6}|.)       # Escape sequence\n    | \\#\\{                           # Interpolation (escaped to avoid Coffeelint errors)\n    | \\.?\\$                          # Possible start of interpolation variable\n    | }                                # Possible end of interpolation\n  )+\n)                                      # Followed by either:\n(?= $                                  # - End of the line\n  | [\\s,\\#)\\[:{>+~|]                # - Another selector\n  | \\.[^$]                            # - Class selector, negating module variable\n  | /\\*                               # - A block comment\n  | ;                                  # - A semicolon\n)", "name": "entity.other.attribute-name.class.css" }, "selector_custom": { "match": "\\b([a-zA-Z0-9]+(-[a-zA-Z0-9]+)+)(?=\\.|\\s++[^:]|\\s*[,\\[{]|:(link|visited|hover|active|focus|target|lang|disabled|enabled|checked|indeterminate|root|nth-(child|last-child|of-type|last-of-type)|first-child|last-child|first-of-type|last-of-type|only-child|only-of-type|empty|not|valid|invalid)(\\([0-9A-Za-z]*\\))?)", "name": "entity.name.tag.custom.scss" }, "selector_id": { "captures": { "1": { "name": "punctuation.definition.entity.css" }, "2": { "patterns": [{ "include": "#interpolation" }, { "match": "\\\\([0-9a-fA-F]{1,6}|.)", "name": "constant.character.escape.scss" }, { "match": "\\$|}", "name": "invalid.illegal.identifier.scss" }] } }, "match": "(?x)\n(\\#)                                  # Valid id-name\n(\n  (?: [-a-zA-Z_0-9]|[^\\x00-\\x7F]     # Valid identifier characters\n    | \\\\(?:[0-9a-fA-F]{1,6}|.)       # Escape sequence\n    | \\#\\{                           # Interpolation (escaped to avoid Coffeelint errors)\n    | \\.?\\$                          # Possible start of interpolation variable\n    | }                                # Possible end of interpolation\n  )+\n)                                      # Followed by either:\n(?= $                                  # - End of the line\n  | [\\s,\\#)\\[:{>+~|]                # - Another selector\n  | \\.[^$]                            # - Class selector, negating module variable\n  | /\\*                               # - A block comment\n)", "name": "entity.other.attribute-name.id.css" }, "selector_placeholder": { "captures": { "1": { "name": "punctuation.definition.entity.css" }, "2": { "patterns": [{ "include": "#interpolation" }, { "match": "\\\\([0-9a-fA-F]{1,6}|.)", "name": "constant.character.escape.scss" }, { "match": "\\$|}", "name": "invalid.illegal.identifier.scss" }] } }, "match": "(?x)\n(%)                                    # Valid placeholder-name\n(\n  (?: [-a-zA-Z_0-9]|[^\\x00-\\x7F]     # Valid identifier characters\n    | \\\\(?:[0-9a-fA-F]{1,6}|.)       # Escape sequence\n    | \\#\\{                           # Interpolation (escaped to avoid Coffeelint errors)\n    | \\.\\$                           # Possible start of interpolation module scope variable\n    | \\$                              # Possible start of interpolation variable\n    | }                                # Possible end of interpolation\n  )+\n)                                      # Followed by either:\n(?= ;                                  # - End of statement\n  | $                                  # - End of the line\n  | [\\s,\\#)\\[:{>+~|]                # - Another selector\n  | \\.[^$]                            # - Class selector, negating module variable\n  | /\\*                               # - A block comment\n)", "name": "entity.other.attribute-name.placeholder.css" }, "selector_pseudo_class": { "patterns": [{ "begin": "((:)\\bnth-(?:child|last-child|of-type|last-of-type))(\\()", "beginCaptures": { "1": { "name": "entity.other.attribute-name.pseudo-class.css" }, "2": { "name": "punctuation.definition.entity.css" }, "3": { "name": "punctuation.definition.pseudo-class.begin.bracket.round.css" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.pseudo-class.end.bracket.round.css" } }, "patterns": [{ "include": "#interpolation" }, { "match": "\\d+", "name": "constant.numeric.css" }, { "match": "(?<=\\d)n\\b|\\b(n|even|odd)\\b", "name": "constant.other.scss" }, { "match": "\\w+", "name": "invalid.illegal.scss" }] }, { "include": "source.css#pseudo-classes" }, { "include": "source.css#pseudo-elements" }, { "include": "source.css#functional-pseudo-classes" }] }, "selectors": { "patterns": [{ "include": "source.css#tag-names" }, { "include": "#selector_custom" }, { "include": "#selector_class" }, { "include": "#selector_id" }, { "include": "#selector_pseudo_class" }, { "include": "#tag_wildcard" }, { "include": "#tag_parent_reference" }, { "include": "source.css#pseudo-elements" }, { "include": "#selector_attribute" }, { "include": "#selector_placeholder" }, { "include": "#parent_selector_suffix" }] }, "string_double": { "begin": '"', "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.scss" } }, "end": '"', "endCaptures": { "0": { "name": "punctuation.definition.string.end.scss" } }, "name": "string.quoted.double.scss", "patterns": [{ "match": "\\\\(\\h{1,6}|.)", "name": "constant.character.escape.scss" }, { "include": "#interpolation" }] }, "string_single": { "begin": "'", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.scss" } }, "end": "'", "endCaptures": { "0": { "name": "punctuation.definition.string.end.scss" } }, "name": "string.quoted.single.scss", "patterns": [{ "match": "\\\\(\\h{1,6}|.)", "name": "constant.character.escape.scss" }, { "include": "#interpolation" }] }, "tag_parent_reference": { "match": "&", "name": "entity.name.tag.reference.scss" }, "tag_wildcard": { "match": "\\*", "name": "entity.name.tag.wildcard.scss" }, "variable": { "patterns": [{ "include": "#variables" }, { "include": "#interpolation" }] }, "variable_setting": { "begin": "(?=\\$[\\w-]+\\s*:)", "contentName": "meta.definition.variable.scss", "end": ";", "endCaptures": { "0": { "name": "punctuation.terminator.rule.scss" } }, "patterns": [{ "match": "\\$[\\w-]+(?=\\s*:)", "name": "variable.scss" }, { "begin": ":", "beginCaptures": { "0": { "name": "punctuation.separator.key-value.scss" } }, "end": "(?=;)", "patterns": [{ "include": "#comment_docblock" }, { "include": "#comment_block" }, { "include": "#comment_line" }, { "include": "#map" }, { "include": "#property_values" }, { "include": "#variable" }, { "match": ",", "name": "punctuation.separator.delimiter.scss" }] }] }, "variables": { "patterns": [{ "captures": { "1": { "name": "variable.scss" }, "2": { "name": "punctuation.access.module.scss" }, "3": { "name": "variable.scss" } }, "match": "\\b([\\w-]+)(\\.)(\\$[\\w-]+)\\b" }, { "match": "(\\$|\\-\\-)[A-Za-z0-9_-]+\\b", "name": "variable.scss" }] } }, "scopeName": "source.css.scss", "embeddedLangs": ["css"] });
var scss = [
  ...css,
  lang$i
];
var lang$h = Object.freeze({ "displayName": "Stylus", "fileTypes": ["styl", "stylus", "css.styl", "css.stylus"], "name": "stylus", "patterns": [{ "include": "#comment" }, { "include": "#at_rule" }, { "include": "#language_keywords" }, { "include": "#language_constants" }, { "include": "#variable_declaration" }, { "include": "#function" }, { "include": "#selector" }, { "include": "#declaration" }, { "captures": { "1": { "name": "punctuation.section.property-list.begin.css" }, "2": { "name": "punctuation.section.property-list.end.css" } }, "match": "(\\{)(\\})", "name": "meta.brace.curly.css" }, { "match": "\\{|\\}", "name": "meta.brace.curly.css" }, { "include": "#numeric" }, { "include": "#string" }, { "include": "#operator" }], "repository": { "at_rule": { "patterns": [{ "begin": "\\s*((@)(import|require))\\b\\s*", "beginCaptures": { "1": { "name": "keyword.control.at-rule.import.stylus" }, "2": { "name": "punctuation.definition.keyword.stylus" } }, "end": "\\s*((?=;|$|\\n))", "endCaptures": { "1": { "name": "punctuation.terminator.rule.css" } }, "name": "meta.at-rule.import.css", "patterns": [{ "include": "#string" }] }, { "begin": "\\s*((@)(extend[s]?)\\b)\\s*", "beginCaptures": { "1": { "name": "keyword.control.at-rule.extend.stylus" }, "2": { "name": "punctuation.definition.keyword.stylus" } }, "end": "\\s*((?=;|$|\\n))", "endCaptures": { "1": { "name": "punctuation.terminator.rule.css" } }, "name": "meta.at-rule.extend.css", "patterns": [{ "include": "#selector" }] }, { "captures": { "1": { "name": "keyword.control.at-rule.fontface.stylus" }, "2": { "name": "punctuation.definition.keyword.stylus" } }, "match": "^\\s*((@)font-face)\\b", "name": "meta.at-rule.fontface.stylus" }, { "captures": { "1": { "name": "keyword.control.at-rule.css.stylus" }, "2": { "name": "punctuation.definition.keyword.stylus" } }, "match": "^\\s*((@)css)\\b", "name": "meta.at-rule.css.stylus" }, { "begin": "\\s*((@)charset)\\b\\s*", "beginCaptures": { "1": { "name": "keyword.control.at-rule.charset.stylus" }, "2": { "name": "punctuation.definition.keyword.stylus" } }, "end": "\\s*((?=;|$|\\n))", "name": "meta.at-rule.charset.stylus", "patterns": [{ "include": "#string" }] }, { "begin": "\\s*((@)keyframes)\\b\\s+([a-zA-Z_-][a-zA-Z0-9_-]*)", "beginCaptures": { "1": { "name": "keyword.control.at-rule.keyframes.stylus" }, "2": { "name": "punctuation.definition.keyword.stylus" }, "3": { "name": "entity.name.function.keyframe.stylus" } }, "end": "\\s*((?=\\{|$|\\n))", "name": "meta.at-rule.keyframes.stylus" }, { "begin": "(?=(\\b(\\d+%|from\\b|to\\b)))", "end": "(?=(\\{|\\n))", "name": "meta.at-rule.keyframes.stylus", "patterns": [{ "match": "(\\b(\\d+%|from\\b|to\\b))", "name": "entity.other.attribute-name.stylus" }] }, { "captures": { "1": { "name": "keyword.control.at-rule.media.stylus" }, "2": { "name": "punctuation.definition.keyword.stylus" } }, "match": "^\\s*((@)media)\\b", "name": "meta.at-rule.media.stylus" }, { "match": "(?:(?=\\w)(?<![\\w-]))(width|scan|resolution|orientation|monochrome|min-width|min-resolution|min-monochrome|min-height|min-device-width|min-device-height|min-device-aspect-ratio|min-color-index|min-color|min-aspect-ratio|max-width|max-resolution|max-monochrome|max-height|max-device-width|max-device-height|max-device-aspect-ratio|max-color-index|max-color|max-aspect-ratio|height|grid|device-width|device-height|device-aspect-ratio|color-index|color|aspect-ratio)(?:(?<=\\w)(?![\\w-]))", "name": "support.type.property-name.media-feature.media.css" }, { "match": "(?:(?=\\w)(?<![\\w-]))(tv|tty|screen|projection|print|handheld|embossed|braille|aural|all)(?:(?<=\\w)(?![\\w-]))", "name": "support.constant.media-type.media.css" }, { "match": "(?:(?=\\w)(?<![\\w-]))(portrait|landscape)(?:(?<=\\w)(?![\\w-]))", "name": "support.constant.property-value.media-property.media.css" }] }, "char_escape": { "match": "\\\\(.)", "name": "constant.character.escape.stylus" }, "color": { "patterns": [{ "begin": "\\b(rgb|rgba|hsl|hsla)(\\()", "beginCaptures": { "1": { "name": "support.function.color.css" }, "2": { "name": "punctuation.section.function.css" } }, "end": "(\\))", "endCaptures": { "1": { "name": "punctuation.section.function.css" } }, "name": "meta.function.color.css", "patterns": [{ "match": "\\s*(,)\\s*", "name": "punctuation.separator.parameter.css" }, { "include": "#numeric" }, { "include": "#property_variable" }] }, { "captures": { "1": { "name": "punctuation.definition.constant.css" } }, "match": "(#)([0-9a-fA-F]{3}|[0-9a-fA-F]{6})\\b", "name": "constant.other.color.rgb-value.css" }, { "comment": "http://www.w3.org/TR/CSS21/syndata.html#value-def-color", "match": "\\b(aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow)\\b", "name": "support.constant.color.w3c-standard-color-name.css" }, { "comment": "http://www.w3.org/TR/css3-color/#svg-color", "match": "\\b(aliceblue|antiquewhite|aquamarine|azure|beige|bisque|blanchedalmond|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|gainsboro|ghostwhite|gold|goldenrod|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|limegreen|linen|magenta|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|oldlace|olivedrab|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|thistle|tomato|turquoise|violet|wheat|whitesmoke|yellowgreen)\\b", "name": "support.constant.color.w3c-extended-color-name.css" }] }, "comment": { "patterns": [{ "include": "#comment_block" }, { "include": "#comment_line" }] }, "comment_block": { "begin": "/\\*", "beginCaptures": { "0": { "name": "punctuation.definition.comment.begin.css" } }, "end": "\\*/", "endCaptures": { "0": { "name": "punctuation.definition.comment.end.css" } }, "name": "comment.block.css" }, "comment_line": { "begin": "(^[ \\t]+)?(?=//)", "beginCaptures": { "1": { "name": "punctuation.whitespace.comment.leading.stylus" } }, "end": "(?!\\G)", "patterns": [{ "begin": "//", "beginCaptures": { "0": { "name": "punctuation.definition.comment.stylus" } }, "end": "(?=\\n)", "name": "comment.line.double-slash.stylus" }] }, "declaration": { "begin": "((?<=^)[^\\S\\n]+)|((?<=;)[^\\S\\n]*)|((?<=\\{)[^\\S\\n]*)", "end": "(?=\\n)|(;)|(?=\\})|(\\n)", "endCaptures": { "2": { "name": "punctuation.terminator.rule.css" } }, "name": "meta.property-list.css", "patterns": [{ "match": "(?x) (?<![\\w-])\n--\n(?:[-a-zA-Z_]    | [^\\x00-\\x7F])     # First letter\n(?:[-a-zA-Z0-9_] | [^\\x00-\\x7F]      # Remainder of identifier\n  |\\\\(?:[0-9a-fA-F]{1,6}|.)\n)*", "name": "variable.css" }, { "include": "#language_keywords" }, { "include": "#language_constants" }, { "match": "(?:(?<=^)[^\\S\\n]+(\\n))" }, { "captures": { "1": { "name": "support.type.property-name.css" }, "2": { "name": "punctuation.separator.key-value.css" }, "3": { "name": "variable.section.css" } }, "match": "\\G\\s*(counter-reset|counter-increment)(?:(:)|[^\\S\\n])[^\\S\\n]*([a-zA-Z_-][a-zA-Z0-9_-]*)", "name": "meta.property.counter.css" }, { "begin": "\\G\\s*(filter)(?:(:)|[^\\S\\n])[^\\S\\n]*", "beginCaptures": { "1": { "name": "support.type.property-name.css" }, "2": { "name": "punctuation.separator.key-value.css" } }, "end": "(?=\\n|;|\\}|$)", "name": "meta.property.filter.css", "patterns": [{ "include": "#function" }, { "include": "#property_values" }] }, { "include": "#property" }, { "include": "#interpolation" }, { "include": "$self" }] }, "font_name": { "match": "(\\b(?i:arial|century|comic|courier|cursive|fantasy|futura|garamond|georgia|helvetica|impact|lucida|monospace|symbol|system|tahoma|times|trebuchet|utopia|verdana|webdings|sans-serif|serif)\\b)", "name": "support.constant.font-name.css" }, "function": { "begin": "(?=[a-zA-Z_-][a-zA-Z0-9_-]*\\()", "end": "(\\))", "endCaptures": { "1": { "name": "punctuation.section.function.css" } }, "patterns": [{ "begin": "(format|url|local)(\\()", "beginCaptures": { "1": { "name": "support.function.misc.css" }, "2": { "name": "punctuation.section.function.css" } }, "end": "(?=\\))", "name": "meta.function.misc.css", "patterns": [{ "match": "(?<=\\()[^\\)\\s]*(?=\\))", "name": "string.css" }, { "include": "#string" }, { "include": "#variable" }, { "include": "#operator" }, { "match": "\\s*" }] }, { "captures": { "1": { "name": "support.function.misc.counter.css" }, "2": { "name": "punctuation.section.function.css" }, "3": { "name": "variable.section.css" } }, "match": "(counter)(\\()([a-zA-Z_-][a-zA-Z0-9_-]*)(?=\\))", "name": "meta.function.misc.counter.css" }, { "begin": "(counters)(\\()", "beginCaptures": { "1": { "name": "support.function.misc.counters.css" }, "2": { "name": "punctuation.section.function.css" } }, "end": "(?=\\))", "name": "meta.function.misc.counters.css", "patterns": [{ "match": "\\G[a-zA-Z_-][a-zA-Z0-9_-]*", "name": "variable.section.css" }, { "match": "\\s*(,)\\s*", "name": "punctuation.separator.parameter.css" }, { "include": "#string" }, { "include": "#interpolation" }] }, { "begin": "(attr)(\\()", "beginCaptures": { "1": { "name": "support.function.misc.attr.css" }, "2": { "name": "punctuation.section.function.css" } }, "end": "(?=\\))", "name": "meta.function.misc.attr.css", "patterns": [{ "match": "\\G[a-zA-Z_-][a-zA-Z0-9_-]*", "name": "entity.other.attribute-name.attribute.css" }, { "match": "(?<=[a-zA-Z0-9_-])\\s*\\b(string|color|url|integer|number|length|em|ex|px|rem|vw|vh|vmin|vmax|mm|cm|in|pt|pc|angle|deg|grad|rad|time|s|ms|frequency|Hz|kHz|%)\\b", "name": "support.type.attr.css" }, { "match": "\\s*(,)\\s*", "name": "punctuation.separator.parameter.css" }, { "include": "#string" }, { "include": "#interpolation" }] }, { "begin": "(calc)(\\()", "beginCaptures": { "1": { "name": "support.function.misc.calc.css" }, "2": { "name": "punctuation.section.function.css" } }, "end": "(?=\\))", "name": "meta.function.misc.calc.css", "patterns": [{ "include": "#property_values" }] }, { "begin": "(cubic-bezier)(\\()", "beginCaptures": { "1": { "name": "support.function.timing.cubic-bezier.css" }, "2": { "name": "punctuation.section.function.css" } }, "end": "(?=\\))", "name": "meta.function.timing.cubic-bezier.css", "patterns": [{ "match": "\\s*(,)\\s*", "name": "punctuation.separator.parameter.css" }, { "include": "#numeric" }, { "include": "#interpolation" }] }, { "begin": "(steps)(\\()", "beginCaptures": { "1": { "name": "support.function.timing.steps.css" }, "2": { "name": "punctuation.section.function.css" } }, "end": "(?=\\))", "name": "meta.function.timing.steps.css", "patterns": [{ "match": "\\s*(,)\\s*", "name": "punctuation.separator.parameter.css" }, { "include": "#numeric" }, { "match": "\\b(start|end)\\b", "name": "support.constant.timing.steps.direction.css" }, { "include": "#interpolation" }] }, { "begin": "(linear-gradient|radial-gradient|repeating-linear-gradient|repeating-radial-gradient)(\\()", "beginCaptures": { "1": { "name": "support.function.gradient.css" }, "2": { "name": "punctuation.section.function.css" } }, "end": "(?=\\))", "name": "meta.function.gradient.css", "patterns": [{ "match": "\\s*(,)\\s*", "name": "punctuation.separator.parameter.css" }, { "include": "#numeric" }, { "include": "#color" }, { "match": "\\b(to|bottom|right|left|top|circle|ellipse|center|closest-side|closest-corner|farthest-side|farthest-corner|at)\\b", "name": "support.constant.gradient.css" }, { "include": "#interpolation" }] }, { "begin": "(blur|brightness|contrast|grayscale|hue-rotate|invert|opacity|saturate|sepia)(\\()", "beginCaptures": { "1": { "name": "support.function.filter.css" }, "2": { "name": "punctuation.section.function.css" } }, "end": "(?=\\))", "name": "meta.function.filter.css", "patterns": [{ "include": "#numeric" }, { "include": "#property_variable" }, { "include": "#interpolation" }] }, { "begin": "(drop-shadow)(\\()", "beginCaptures": { "1": { "name": "support.function.filter.drop-shadow.css" }, "2": { "name": "punctuation.section.function.css" } }, "end": "(?=\\))", "name": "meta.function.filter.drop-shadow.css", "patterns": [{ "include": "#numeric" }, { "include": "#color" }, { "include": "#property_variable" }, { "include": "#interpolation" }] }, { "begin": "(matrix|matrix3d|perspective|rotate|rotate3d|rotate[Xx]|rotate[yY]|rotate[zZ]|scale|scale3d|scale[xX]|scale[yY]|scale[zZ]|skew|skew[xX]|skew[yY]|translate|translate3d|translate[xX]|translate[yY]|translate[zZ])(\\()", "beginCaptures": { "1": { "name": "support.function.transform.css" }, "2": { "name": "punctuation.section.function.css" } }, "end": "(?=\\))", "name": "meta.function.transform.css", "patterns": [{ "include": "#numeric" }, { "include": "#property_variable" }, { "include": "#interpolation" }] }, { "match": "(url|local|format|counter|counters|attr|calc)(?=\\()", "name": "support.function.misc.css" }, { "match": "(cubic-bezier|steps)(?=\\()", "name": "support.function.timing.css" }, { "match": "(linear-gradient|radial-gradient|repeating-linear-gradient|repeating-radial-gradient)(?=\\()", "name": "support.function.gradient.css" }, { "match": "(blur|brightness|contrast|drop-shadow|grayscale|hue-rotate|invert|opacity|saturate|sepia)(?=\\()", "name": "support.function.filter.css" }, { "match": "(matrix|matrix3d|perspective|rotate|rotate3d|rotate[Xx]|rotate[yY]|rotate[zZ]|scale|scale3d|scale[xX]|scale[yY]|scale[zZ]|skew|skew[xX]|skew[yY]|translate|translate3d|translate[xX]|translate[yY]|translate[zZ])(?=\\()", "name": "support.function.transform.css" }, { "begin": "([a-zA-Z_-][a-zA-Z0-9_-]*)(\\()", "beginCaptures": { "1": { "name": "entity.name.function.stylus" }, "2": { "name": "punctuation.section.function.css" } }, "end": "(?=\\))", "name": "meta.function.stylus", "patterns": [{ "match": "(?x)\n--\n(?:[-a-zA-Z_]    | [^\\x00-\\x7F])     # First letter\n(?:[-a-zA-Z0-9_] | [^\\x00-\\x7F]      # Remainder of identifier\n  |\\\\(?:[0-9a-fA-F]{1,6}|.)\n)*", "name": "variable.argument.stylus" }, { "match": "\\s*(,)\\s*", "name": "punctuation.separator.parameter.css" }, { "include": "#interpolation" }, { "include": "#property_values" }] }, { "match": "\\(", "name": "punctuation.section.function.css" }] }, "interpolation": { "begin": "(?:(\\{)[^\\S\\n]*)(?=[^;=]*[^\\S\\n]*\\})", "beginCaptures": { "1": { "name": "meta.brace.curly" } }, "end": "(?:[^\\S\\n]*(\\}))|\\n|$", "endCaptures": { "1": { "name": "meta.brace.curly" } }, "name": "meta.interpolation.stylus", "patterns": [{ "include": "#variable" }, { "include": "#numeric" }, { "include": "#string" }, { "include": "#operator" }] }, "language_constants": { "match": "\\b(true|false|null)\\b", "name": "constant.language.stylus" }, "language_keywords": { "patterns": [{ "match": "(\\b|\\s)(return|else|for|unless|if|else)\\b", "name": "keyword.control.stylus" }, { "match": "(\\b|\\s)(!important|in|is defined|is a)\\b", "name": "keyword.other.stylus" }, { "match": "\\barguments\\b", "name": "variable.language.stylus" }] }, "numeric": { "patterns": [{ "captures": { "1": { "name": "keyword.other.unit.css" } }, "match": "(?x) (?<!\\w|-)(?:(?:-|\\+)?(?:[0-9]+(?:\\.[0-9]+)?)|(?:\\.[0-9]+)) ((?:px|pt|ch|cm|mm|in|r?em|ex|pc|deg|g?rad|dpi|dpcm|dppx|fr|ms|s|turn|vh|vmax|vmin|vw)\\b|%)?", "name": "constant.numeric.css" }] }, "operator": { "patterns": [{ "match": "((?:\\?|:|!|~|\\+|(\\s-\\s)|(?:\\*)?\\*|\\/|%|(\\.)?\\.\\.|<|>|(?:=|:|\\?|\\+|-|\\*|\\/|%|<|>)?=|!=)|\\b(?:in|is(?:nt)?|(?<!:)not|or|and)\\b)", "name": "keyword.operator.stylus" }, { "include": "#char_escape" }] }, "property": { "begin": "(?x:\\G\\s*(?:\n  (-webkit-[-A-Za-z]+|-moz-[-A-Za-z]+|-o-[-A-Za-z]+|-ms-[-A-Za-z]+|-khtml-[-A-Za-z]+|zoom|z-index|y|x|wrap|word-wrap|word-spacing|word-break|word|width|widows|white-space-collapse|white-space|white|weight|volume|voice-volume|voice-stress|voice-rate|voice-pitch-range|voice-pitch|voice-family|voice-duration|voice-balance|voice|visibility|vertical-align|variant|user-select|up|unicode-bidi|unicode-range|unicode|trim|transition-timing-function|transition-property|transition-duration|transition-delay|transition|transform|touch-action|top-width|top-style|top-right-radius|top-left-radius|top-color|top|timing-function|text-wrap|text-transform|text-shadow|text-replace|text-rendering|text-overflow|text-outline|text-justify|text-indent|text-height|text-emphasis|text-decoration|text-align-last|text-align|text|target-position|target-new|target-name|target|table-layout|tab-size|style-type|style-position|style-image|style|string-set|stretch|stress|stacking-strategy|stacking-shift|stacking-ruby|stacking|src|speed|speech-rate|speech|speak-punctuation|speak-numeral|speak-header|speak|span|spacing|space-collapse|space|sizing|size-adjust|size|shadow|respond-to|rule-width|rule-style|rule-color|rule|ruby-span|ruby-position|ruby-overhang|ruby-align|ruby|rows|rotation-point|rotation|role|right-width|right-style|right-color|right|richness|rest-before|rest-after|rest|resource|resize|reset|replace|repeat|rendering-intent|rate|radius|quotes|punctuation-trim|punctuation|property|profile|presentation-level|presentation|position|pointer-events|point|play-state|play-during|play-count|pitch-range|pitch|phonemes|pause-before|pause-after|pause|page-policy|page-break-inside|page-break-before|page-break-after|page|padding-top|padding-right|padding-left|padding-bottom|padding|pack|overhang|overflow-y|overflow-x|overflow-style|overflow|outline-width|outline-style|outline-offset|outline-color|outline|orphans|origin|orientation|orient|ordinal-group|order|opacity|offset|numeral|new|nav-up|nav-right|nav-left|nav-index|nav-down|nav|name|move-to|model|mix-blend-mode|min-width|min-height|min|max-width|max-height|max|marquee-style|marquee-speed|marquee-play-count|marquee-direction|marquee|marks|mark-before|mark-after|mark|margin-top|margin-right|margin-left|margin-bottom|margin|mask-image|list-style-type|list-style-position|list-style-image|list-style|list|lines|line-stacking-strategy|line-stacking-shift|line-stacking-ruby|line-stacking|line-height|line-break|level|letter-spacing|length|left-width|left-style|left-color|left|label|justify-content|justify|iteration-count|inline-box-align|initial-value|initial-size|initial-before-align|initial-before-adjust|initial-after-align|initial-after-adjust|index|indent|increment|image-resolution|image-orientation|image|icon|hyphens|hyphenate-resource|hyphenate-lines|hyphenate-character|hyphenate-before|hyphenate-after|hyphenate|height|header|hanging-punctuation|gap|grid|grid-area|grid-auto-columns|grid-auto-flow|grid-auto-rows|grid-column|grid-column-end|grid-column-start|grid-row|grid-row-end|grid-row-start|grid-template|grid-template-areas|grid-template-columns|grid-template-rows|row-gap|gap|font-kerning|font-language-override|font-weight|font-variant-caps|font-variant|font-style|font-synthesis|font-stretch|font-size-adjust|font-size|font-family|font|float-offset|float|flex-wrap|flex-shrink|flex-grow|flex-group|flex-flow|flex-direction|flex-basis|flex|fit-position|fit|fill|filter|family|empty-cells|emphasis|elevation|duration|drop-initial-value|drop-initial-size|drop-initial-before-align|drop-initial-before-adjust|drop-initial-after-align|drop-initial-after-adjust|drop|down|dominant-baseline|display-role|display-model|display|direction|delay|decoration-break|decoration|cursor|cue-before|cue-after|cue|crop|counter-reset|counter-increment|counter|count|content|columns|column-width|column-span|column-rule-width|column-rule-style|column-rule-color|column-rule|column-gap|column-fill|column-count|column-break-before|column-break-after|column|color-profile|color|collapse|clip|clear|character|caption-side|break-inside|break-before|break-after|break|box-sizing|box-shadow|box-pack|box-orient|box-ordinal-group|box-lines|box-flex-group|box-flex|box-direction|box-decoration-break|box-align|box|bottom-width|bottom-style|bottom-right-radius|bottom-left-radius|bottom-color|bottom|border-width|border-top-width|border-top-style|border-top-right-radius|border-top-left-radius|border-top-color|border-top|border-style|border-spacing|border-right-width|border-right-style|border-right-color|border-right|border-radius|border-length|border-left-width|border-left-style|border-left-color|border-left|border-image|border-color|border-collapse|border-bottom-width|border-bottom-style|border-bottom-right-radius|border-bottom-left-radius|border-bottom-color|border-bottom|border|bookmark-target|bookmark-level|bookmark-label|bookmark|binding|bidi|before|baseline-shift|baseline|balance|background-blend-mode|background-size|background-repeat|background-position|background-origin|background-image|background-color|background-clip|background-break|background-attachment|background|azimuth|attachment|appearance|animation-timing-function|animation-play-state|animation-name|animation-iteration-count|animation-duration|animation-direction|animation-delay|animation-fill-mode|animation|alignment-baseline|alignment-adjust|alignment|align-self|align-last|align-items|align-content|align|after|adjust|will-change)|\n  (writing-mode|text-anchor|stroke-width|stroke-opacity|stroke-miterlimit|stroke-linejoin|stroke-linecap|stroke-dashoffset|stroke-dasharray|stroke|stop-opacity|stop-color|shape-rendering|marker-start|marker-mid|marker-end|lighting-color|kerning|image-rendering|glyph-orientation-vertical|glyph-orientation-horizontal|flood-opacity|flood-color|fill-rule|fill-opacity|fill|enable-background|color-rendering|color-interpolation-filters|color-interpolation|clip-rule|clip-path)|\n  ([a-zA-Z_-][a-zA-Z0-9_-]*)\n)(?!([^\\S\\n]*&)|([^\\S\\n]*\\{))(?=:|([^\\S\\n]+[^\\s])))", "beginCaptures": { "1": { "name": "support.type.property-name.css" }, "2": { "name": "support.type.property-name.svg.css" }, "3": { "name": "support.function.mixin.stylus" } }, "end": "(;)|(?=\\n|\\}|$)", "endCaptures": { "1": { "name": "punctuation.terminator.rule.css" } }, "patterns": [{ "include": "#property_value" }] }, "property_value": { "begin": "\\G(?:(:)|(\\s))(\\s*)(?!&)", "beginCaptures": { "1": { "name": "punctuation.separator.key-value.css" }, "2": { "name": "punctuation.separator.key-value.css" } }, "end": "(?=\\n|;|\\})", "endCaptures": { "1": { "name": "punctuation.terminator.rule.css" } }, "name": "meta.property-value.css", "patterns": [{ "include": "#property_values" }, { "match": "[^\\n]+?" }] }, "property_values": { "patterns": [{ "include": "#function" }, { "include": "#comment" }, { "include": "#language_keywords" }, { "include": "#language_constants" }, { "match": "(?:(?=\\w)(?<![\\w-]))(wrap-reverse|wrap|whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|unicase|underline|ultra-expanded|ultra-condensed|transparent|transform|top|titling-caps|thin|thick|text-top|text-bottom|text|tb-rl|table-row-group|table-row|table-header-group|table-footer-group|table-column-group|table-column|table-cell|table|sw-resize|super|strict|stretch|step-start|step-end|static|square|space-between|space-around|space|solid|soft-light|small-caps|separate|semi-expanded|semi-condensed|se-resize|scroll|screen|saturation|s-resize|running|rtl|row-reverse|row-resize|row|round|right|ridge|reverse|repeat-y|repeat-x|repeat|relative|progressive|progress|pre-wrap|pre-line|pre|pointer|petite-caps|paused|pan-x|pan-left|pan-right|pan-y|pan-up|pan-down|padding-box|overline|overlay|outside|outset|optimizeSpeed|optimizeLegibility|opacity|oblique|nw-resize|nowrap|not-allowed|normal|none|no-repeat|no-drop|newspaper|ne-resize|n-resize|multiply|move|middle|medium|max-height|manipulation|main-size|luminosity|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|local|list-item|linear(?!-)|line-through|line-edge|line|lighter|lighten|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline-block|inline|inherit|infinite|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|hue|horizontal|hidden|help|hard-light|hand|groove|geometricPrecision|forwards|flex-start|flex-end|flex|fixed|extra-expanded|extra-condensed|expanded|exclusion|ellipsis|ease-out|ease-in-out|ease-in|ease|e-resize|double|dotted|distribute-space|distribute-letter|distribute-all-lines|distribute|disc|disabled|difference|default|decimal|dashed|darken|currentColor|crosshair|cover|content-box|contain|condensed|column-reverse|column|color-dodge|color-burn|color|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|border-box|bolder|bold|block|bidi-override|below|baseline|balance|backwards|auto|antialiased|always|alternate-reverse|alternate|all-small-caps|all-scroll|all-petite-caps|all|absolute)(?:(?<=\\w)(?![\\w-]))", "name": "support.constant.property-value.css" }, { "match": "(?:(?=\\w)(?<![\\w-]))(start|sRGB|square|round|optimizeSpeed|optimizeQuality|nonzero|miter|middle|linearRGB|geometricPrecision |evenodd |end |crispEdges|butt|bevel)(?:(?<=\\w)(?![\\w-]))", "name": "support.constant.property-value.svg.css" }, { "include": "#font_name" }, { "include": "#numeric" }, { "include": "#color" }, { "include": "#string" }, { "match": "\\!\\s*important", "name": "keyword.other.important.css" }, { "include": "#operator" }, { "include": "#stylus_keywords" }, { "include": "#property_variable" }] }, "property_variable": { "patterns": [{ "include": "#variable" }, { "match": "(?<!^)(\\@[a-zA-Z_-][a-zA-Z0-9_-]*)", "name": "variable.property.stylus" }] }, "selector": { "patterns": [{ "match": "(?:(?=\\w)(?<![\\w-]))(a|abbr|acronym|address|area|article|aside|audio|b|base|bdi|bdo|big|blockquote|body|br|button|canvas|caption|cite|code|col|colgroup|data|datalist|dd|del|details|dfn|dialog|div|dl|dt|em|embed|eventsource|fieldset|figure|figcaption|footer|form|frame|frameset|(h[1-6])|head|header|hgroup|hr|html|i|iframe|img|input|ins|kbd|keygen|label|legend|li|link|main|map|mark|math|menu|menuitem|meta|meter|nav|noframes|noscript|object|ol|optgroup|option|output|p|param|picture|pre|progress|q|rb|rp|rt|rtc|ruby|s|samp|script|section|select|small|source|span|strike|strong|style|sub|summary|sup|svg|table|tbody|td|template|textarea|tfoot|th|thead|time|title|tr|track|tt|u|ul|var|video|wbr)(?:(?<=\\w)(?![\\w-]))", "name": "entity.name.tag.css" }, { "match": "(?:(?=\\w)(?<![\\w-]))(vkern|view|use|tspan|tref|title|textPath|text|symbol|switch|svg|style|stop|set|script|rect|radialGradient|polyline|polygon|pattern|path|mpath|missing-glyph|metadata|mask|marker|linearGradient|line|image|hkern|glyphRef|glyph|g|foreignObject|font-face-uri|font-face-src|font-face-name|font-face-format|font-face|font|filter|feTurbulence|feTile|feSpotLight|feSpecularLighting|fePointLight|feOffset|feMorphology|feMergeNode|feMerge|feImage|feGaussianBlur|feFuncR|feFuncG|feFuncB|feFuncA|feFlood|feDistantLight|feDisplacementMap|feDiffuseLighting|feConvolveMatrix|feComposite|feComponentTransfer|feColorMatrix|feBlend|ellipse|desc|defs|cursor|color-profile|clipPath|circle|animateTransform|animateMotion|animateColor|animate|altGlyphItem|altGlyphDef|altGlyph|a)(?:(?<=\\w)(?![\\w-]))", "name": "entity.name.tag.svg.css" }, { "match": "\\s*(\\,)\\s*", "name": "meta.selector.stylus" }, { "match": "\\*", "name": "meta.selector.stylus" }, { "captures": { "2": { "name": "entity.other.attribute-name.parent-selector-suffix.stylus" } }, "match": "\\s*(\\&)([a-zA-Z0-9_-]+)\\s*", "name": "meta.selector.stylus" }, { "match": "\\s*(\\&)\\s*", "name": "meta.selector.stylus" }, { "captures": { "1": { "name": "punctuation.definition.entity.css" } }, "match": "(\\.)[a-zA-Z0-9_-]+", "name": "entity.other.attribute-name.class.css" }, { "captures": { "1": { "name": "punctuation.definition.entity.css" } }, "match": "(#)[a-zA-Z][a-zA-Z0-9_-]*", "name": "entity.other.attribute-name.id.css" }, { "captures": { "1": { "name": "punctuation.definition.entity.css" } }, "match": "(:+)(after|before|content|first-letter|first-line|host|(-(moz|webkit|ms)-)?selection)\\b", "name": "entity.other.attribute-name.pseudo-element.css" }, { "captures": { "1": { "name": "punctuation.definition.entity.css" } }, "match": "(:)((first|last)-child|(first|last|only)-of-type|empty|root|target|first|left|right)\\b", "name": "entity.other.attribute-name.pseudo-class.css" }, { "captures": { "1": { "name": "punctuation.definition.entity.css" } }, "match": "(:)(checked|enabled|default|disabled|indeterminate|invalid|optional|required|valid)\\b", "name": "entity.other.attribute-name.pseudo-class.ui-state.css" }, { "begin": "((:)not)(\\()", "beginCaptures": { "1": { "name": "entity.other.attribute-name.pseudo-class.css" }, "2": { "name": "punctuation.definition.entity.css" }, "3": { "name": "punctuation.section.function.css" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.section.function.css" } }, "patterns": [{ "include": "#selector" }] }, { "captures": { "1": { "name": "entity.other.attribute-name.pseudo-class.css" }, "2": { "name": "punctuation.definition.entity.css" }, "3": { "name": "punctuation.section.function.css" }, "4": { "name": "constant.numeric.css" }, "5": { "name": "punctuation.section.function.css" } }, "match": "((:)nth-(?:(?:last-)?child|(?:last-)?of-type))(\\()(\\-?(?:\\d+n?|n)(?:\\+\\d+)?|even|odd)(\\))" }, { "captures": { "1": { "name": "entity.other.attribute-name.pseudo-class.css" }, "2": { "name": "puncutation.definition.entity.css" }, "3": { "name": "punctuation.section.function.css" }, "4": { "name": "constant.language.css" }, "5": { "name": "punctuation.section.function.css" } }, "match": "((:)dir)\\s*(?:(\\()(ltr|rtl)?(\\)))?" }, { "captures": { "1": { "name": "entity.other.attribute-name.pseudo-class.css" }, "2": { "name": "puncutation.definition.entity.css" }, "3": { "name": "punctuation.section.function.css" }, "4": { "name": "constant.language.css" }, "6": { "name": "punctuation.section.function.css" } }, "match": "((:)lang)\\s*(?:(\\()(\\w+(-\\w+)?)?(\\)))?" }, { "captures": { "1": { "name": "punctuation.definition.entity.css" } }, "match": "(:)(active|hover|link|visited|focus)\\b", "name": "entity.other.attribute-name.pseudo-class.css" }, { "captures": { "1": { "name": "punctuation.definition.entity.css" } }, "match": "(::)(shadow)\\b", "name": "entity.other.attribute-name.pseudo-class.css" }, { "captures": { "1": { "name": "punctuation.definition.entity.css" }, "2": { "name": "entity.other.attribute-name.attribute.css" }, "3": { "name": "punctuation.separator.operator.css" }, "4": { "name": "string.unquoted.attribute-value.css" }, "5": { "name": "string.quoted.double.attribute-value.css" }, "6": { "name": "punctuation.definition.string.begin.css" }, "7": { "name": "punctuation.definition.string.end.css" }, "8": { "name": "punctuation.definition.entity.css" } }, "match": `(?i)(\\[)\\s*(-?[_a-z\\\\[[:^ascii:]]][_a-z0-9\\-\\\\[[:^ascii:]]]*)(?:\\s*([~|^$*]?=)\\s*(?:(-?[_a-z\\\\[[:^ascii:]]][_a-z0-9\\-\\\\[[:^ascii:]]]*)|((?>(['"])(?:[^\\\\]|\\\\.)*?(\\6)))))?\\s*(\\])`, "name": "meta.attribute-selector.css" }, { "include": "#interpolation" }, { "include": "#variable" }] }, "string": { "patterns": [{ "begin": '"', "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.css" } }, "end": '"', "endCaptures": { "0": { "name": "punctuation.definition.string.end.css" } }, "name": "string.quoted.double.css", "patterns": [{ "match": "\\\\([a-fA-F0-9]{1,6}|.)", "name": "constant.character.escape.css" }] }, { "begin": "'", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.css" } }, "end": "'", "endCaptures": { "0": { "name": "punctuation.definition.string.end.css" } }, "name": "string.quoted.single.css", "patterns": [{ "match": "\\\\([a-fA-F0-9]{1,6}|.)", "name": "constant.character.escape.css" }] }] }, "variable": { "match": "(\\$[a-zA-Z_-][a-zA-Z0-9_-]*)", "name": "variable.stylus" }, "variable_declaration": { "begin": "^[^\\S\\n]*(\\$?[a-zA-Z_-][a-zA-Z0-9_-]*)[^\\S\\n]*(\\=|\\?\\=|\\:\\=)", "beginCaptures": { "1": { "name": "variable.stylus" }, "2": { "name": "keyword.operator.stylus" } }, "end": "(\\n)|(;)|(?=\\})", "endCaptures": { "2": { "name": "punctuation.terminator.rule.css" } }, "patterns": [{ "include": "#property_values" }] } }, "scopeName": "source.stylus", "aliases": ["styl"] });
var stylus = [
  lang$h
];
var lang$g = Object.freeze({ "displayName": "CoffeeScript", "name": "coffee", "patterns": [{ "include": "#jsx" }, { "captures": { "1": { "name": "keyword.operator.new.coffee" }, "2": { "name": "storage.type.class.coffee" }, "3": { "name": "entity.name.type.instance.coffee" }, "4": { "name": "entity.name.type.instance.coffee" } }, "match": "(new)\\s+(?:(?:(class)\\s+(\\w+(?:\\.\\w*)*)?)|(\\w+(?:\\.\\w*)*))", "name": "meta.class.instance.constructor.coffee" }, { "begin": "'''", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.coffee" } }, "end": "'''", "endCaptures": { "0": { "name": "punctuation.definition.string.end.coffee" } }, "name": "string.quoted.single.heredoc.coffee", "patterns": [{ "captures": { "1": { "name": "punctuation.definition.escape.backslash.coffee" } }, "match": "(\\\\).", "name": "constant.character.escape.backslash.coffee" }] }, { "begin": '"""', "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.coffee" } }, "end": '"""', "endCaptures": { "0": { "name": "punctuation.definition.string.end.coffee" } }, "name": "string.quoted.double.heredoc.coffee", "patterns": [{ "captures": { "1": { "name": "punctuation.definition.escape.backslash.coffee" } }, "match": "(\\\\).", "name": "constant.character.escape.backslash.coffee" }, { "include": "#interpolated_coffee" }] }, { "captures": { "1": { "name": "punctuation.definition.string.begin.coffee" }, "2": { "name": "source.js.embedded.coffee", "patterns": [{ "include": "source.js" }] }, "3": { "name": "punctuation.definition.string.end.coffee" } }, "match": "(`)(.*)(`)", "name": "string.quoted.script.coffee" }, { "begin": "(?<!#)###(?!#)", "beginCaptures": { "0": { "name": "punctuation.definition.comment.coffee" } }, "end": "###", "endCaptures": { "0": { "name": "punctuation.definition.comment.coffee" } }, "name": "comment.block.coffee", "patterns": [{ "match": "(?<=^|\\s)@\\w*(?=\\s)", "name": "storage.type.annotation.coffee" }] }, { "begin": "#", "beginCaptures": { "0": { "name": "punctuation.definition.comment.coffee" } }, "end": "$", "name": "comment.line.number-sign.coffee" }, { "begin": "///", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.coffee" } }, "end": "(///)[gimuy]*", "endCaptures": { "1": { "name": "punctuation.definition.string.end.coffee" } }, "name": "string.regexp.multiline.coffee", "patterns": [{ "include": "#heregexp" }] }, { "begin": "(?<![\\w$])(/)(?=(?![/*+?])(.+)(/)[gimuy]*(?!\\s*[\\w$/(]))", "beginCaptures": { "1": { "name": "punctuation.definition.string.begin.coffee" } }, "end": "(/)[gimuy]*(?!\\s*[\\w$/(])", "endCaptures": { "1": { "name": "punctuation.definition.string.end.coffee" } }, "name": "string.regexp.coffee", "patterns": [{ "include": "source.js.regexp" }] }, { "match": "\\b(?<![\\.\\$])(break|by|catch|continue|else|finally|for|in|of|if|return|switch|then|throw|try|unless|when|while|until|loop|do|export|import|default|from|as|yield|async|await|(?<=for)\\s+own)(?!\\s*:)\\b", "name": "keyword.control.coffee" }, { "match": "\\b(?<![\\.\\$])(delete|instanceof|new|typeof)(?!\\s*:)\\b", "name": "keyword.operator.$1.coffee" }, { "match": "\\b(?<![\\.\\$])(case|function|var|void|with|const|let|enum|native|__hasProp|__extends|__slice|__bind|__indexOf|implements|interface|package|private|protected|public|static)(?!\\s*:)\\b", "name": "keyword.reserved.coffee" }, { "begin": "(?x)\n(?<=\\s|^)((@)?[a-zA-Z_$][\\w$]*)\n\\s*([:=])\\s*\n(?=(\\([^\\(\\)]*\\)\\s*)?[=-]>)", "beginCaptures": { "1": { "name": "entity.name.function.coffee" }, "2": { "name": "variable.other.readwrite.instance.coffee" }, "3": { "name": "keyword.operator.assignment.coffee" } }, "end": "[=-]>", "endCaptures": { "0": { "name": "storage.type.function.coffee" } }, "name": "meta.function.coffee", "patterns": [{ "include": "#function_params" }] }, { "begin": `(?x)
(?<=\\s|^)(?:((')([^']*?)('))|((")([^"]*?)(")))
\\s*([:=])\\s*
(?=(\\([^\\(\\)]*\\)\\s*)?[=-]>)`, "beginCaptures": { "1": { "name": "string.quoted.single.coffee" }, "2": { "name": "punctuation.definition.string.begin.coffee" }, "3": { "name": "entity.name.function.coffee" }, "4": { "name": "punctuation.definition.string.end.coffee" }, "5": { "name": "string.quoted.double.coffee" }, "6": { "name": "punctuation.definition.string.begin.coffee" }, "7": { "name": "entity.name.function.coffee" }, "8": { "name": "punctuation.definition.string.end.coffee" }, "9": { "name": "keyword.operator.assignment.coffee" } }, "end": "[=-]>", "endCaptures": { "0": { "name": "storage.type.function.coffee" } }, "name": "meta.function.coffee", "patterns": [{ "include": "#function_params" }] }, { "begin": "(?=(\\([^\\(\\)]*\\)\\s*)?[=-]>)", "end": "[=-]>", "endCaptures": { "0": { "name": "storage.type.function.coffee" } }, "name": "meta.function.inline.coffee", "patterns": [{ "include": "#function_params" }] }, { "begin": `(?<=\\s|^)({)(?=[^'"#]+?}[\\s\\]}]*=)`, "beginCaptures": { "1": { "name": "punctuation.definition.destructuring.begin.bracket.curly.coffee" } }, "end": "}", "endCaptures": { "0": { "name": "punctuation.definition.destructuring.end.bracket.curly.coffee" } }, "name": "meta.variable.assignment.destructured.object.coffee", "patterns": [{ "include": "$self" }, { "match": "[a-zA-Z$_]\\w*", "name": "variable.assignment.coffee" }] }, { "begin": `(?<=\\s|^)(\\[)(?=[^'"#]+?\\][\\s\\]}]*=)`, "beginCaptures": { "1": { "name": "punctuation.definition.destructuring.begin.bracket.square.coffee" } }, "end": "\\]", "endCaptures": { "0": { "name": "punctuation.definition.destructuring.end.bracket.square.coffee" } }, "name": "meta.variable.assignment.destructured.array.coffee", "patterns": [{ "include": "$self" }, { "match": "[a-zA-Z$_]\\w*", "name": "variable.assignment.coffee" }] }, { "match": "\\b(?<!\\.|::)(true|on|yes)(?!\\s*[:=][^=])\\b", "name": "constant.language.boolean.true.coffee" }, { "match": "\\b(?<!\\.|::)(false|off|no)(?!\\s*[:=][^=])\\b", "name": "constant.language.boolean.false.coffee" }, { "match": "\\b(?<!\\.|::)null(?!\\s*[:=][^=])\\b", "name": "constant.language.null.coffee" }, { "match": "\\b(?<!\\.|::)extends(?!\\s*[:=])\\b", "name": "variable.language.coffee" }, { "match": "(?<!\\.)\\b(?<!\\$)(super|this|arguments)(?!\\s*[:=][^=]|\\$)\\b", "name": "variable.language.$1.coffee" }, { "captures": { "1": { "name": "storage.type.class.coffee" }, "2": { "name": "keyword.control.inheritance.coffee" }, "3": { "name": "entity.other.inherited-class.coffee" } }, "match": "(?<=\\s|^|\\[|\\()(class)\\s+(extends)\\s+(@?[a-zA-Z\\$\\._][\\w\\.]*)", "name": "meta.class.coffee" }, { "captures": { "1": { "name": "storage.type.class.coffee" }, "2": { "name": "entity.name.type.class.coffee" }, "3": { "name": "keyword.control.inheritance.coffee" }, "4": { "name": "entity.other.inherited-class.coffee" } }, "match": "(?<=\\s|^|\\[|\\()(class\\b)\\s+(@?[a-zA-Z\\$_][\\w\\.]*)?(?:\\s+(extends)\\s+(@?[a-zA-Z\\$\\._][\\w\\.]*))?", "name": "meta.class.coffee" }, { "match": "\\b(debugger|\\\\)\\b", "name": "keyword.other.coffee" }, { "match": "\\b(Array|ArrayBuffer|Blob|Boolean|Date|document|Function|Int(8|16|32|64)Array|Math|Map|Number|Object|Proxy|RegExp|Set|String|WeakMap|window|Uint(8|16|32|64)Array|XMLHttpRequest)\\b", "name": "support.class.coffee" }, { "match": "\\b(console)\\b", "name": "entity.name.type.object.coffee" }, { "match": "((?<=console\\.)(debug|warn|info|log|error|time|timeEnd|assert))\\b", "name": "support.function.console.coffee" }, { "match": "((?<=\\.)(apply|call|concat|every|filter|forEach|from|hasOwnProperty|indexOf|isPrototypeOf|join|lastIndexOf|map|of|pop|propertyIsEnumerable|push|reduce(Right)?|reverse|shift|slice|some|sort|splice|to(Locale)?String|unshift|valueOf))\\b", "name": "support.function.method.array.coffee" }, { "match": "((?<=Array\\.)(isArray))\\b", "name": "support.function.static.array.coffee" }, { "match": "((?<=Object\\.)(create|definePropert(ies|y)|freeze|getOwnProperty(Descriptors?|Names)|getProperty(Descriptor|Names)|getPrototypeOf|is(Extensible|Frozen|Sealed)?|isnt|keys|preventExtensions|seal))\\b", "name": "support.function.static.object.coffee" }, { "match": "((?<=Math\\.)(abs|acos|acosh|asin|asinh|atan|atan2|atanh|ceil|cos|cosh|exp|expm1|floor|hypot|log|log10|log1p|log2|max|min|pow|random|round|sign|sin|sinh|sqrt|tan|tanh|trunc))\\b", "name": "support.function.static.math.coffee" }, { "match": "((?<=Number\\.)(is(Finite|Integer|NaN)|toInteger))\\b", "name": "support.function.static.number.coffee" }, { "match": "(?<!\\.)\\b(module|exports|__filename|__dirname|global|process)(?!\\s*:)\\b", "name": "support.variable.coffee" }, { "match": "\\b(Infinity|NaN|undefined)\\b", "name": "constant.language.coffee" }, { "include": "#operators" }, { "include": "#method_calls" }, { "include": "#function_calls" }, { "include": "#numbers" }, { "include": "#objects" }, { "include": "#properties" }, { "match": "::", "name": "keyword.operator.prototype.coffee" }, { "match": "(?<!\\$)\\b[0-9]+[\\w$]*", "name": "invalid.illegal.identifier.coffee" }, { "match": ";", "name": "punctuation.terminator.statement.coffee" }, { "match": ",", "name": "punctuation.separator.delimiter.coffee" }, { "begin": "{", "beginCaptures": { "0": { "name": "meta.brace.curly.coffee" } }, "end": "}", "endCaptures": { "0": { "name": "meta.brace.curly.coffee" } }, "patterns": [{ "include": "$self" }] }, { "begin": "\\[", "beginCaptures": { "0": { "name": "punctuation.definition.array.begin.bracket.square.coffee" } }, "end": "\\]", "endCaptures": { "0": { "name": "punctuation.definition.array.end.bracket.square.coffee" } }, "patterns": [{ "match": "(?<!\\.)\\.{3}", "name": "keyword.operator.slice.exclusive.coffee" }, { "match": "(?<!\\.)\\.{2}", "name": "keyword.operator.slice.inclusive.coffee" }, { "include": "$self" }] }, { "begin": "\\(", "beginCaptures": { "0": { "name": "meta.brace.round.coffee" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.coffee" } }, "patterns": [{ "include": "$self" }] }, { "include": "#instance_variable" }, { "include": "#single_quoted_string" }, { "include": "#double_quoted_string" }], "repository": { "arguments": { "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.arguments.begin.bracket.round.coffee" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.arguments.end.bracket.round.coffee" } }, "name": "meta.arguments.coffee", "patterns": [{ "include": "$self" }] }, { "begin": `(?=(@|@?[\\w$]+|[=-]>|\\-\\d|\\[|{|"|'))`, "end": "(?=\\s*(?<![\\w$])(of|in|then|is|isnt|and|or|for|else|when|if|unless|by|instanceof)(?![\\w$]))|(?=\\s*(}|\\]|\\)|#|$))", "name": "meta.arguments.coffee", "patterns": [{ "include": "$self" }] }] }, "double_quoted_string": { "patterns": [{ "begin": '"', "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.coffee" } }, "end": '"', "endCaptures": { "0": { "name": "punctuation.definition.string.end.coffee" } }, "name": "string.quoted.double.coffee", "patterns": [{ "captures": { "1": { "name": "punctuation.definition.escape.backslash.coffee" } }, "match": "(\\\\)(x[0-9A-Fa-f]{2}|[0-2][0-7]{0,2}|3[0-6][0-7]|37[0-7]?|[4-7][0-7]?|.)", "name": "constant.character.escape.backslash.coffee" }, { "include": "#interpolated_coffee" }] }] }, "embedded_comment": { "patterns": [{ "captures": { "1": { "name": "punctuation.definition.comment.coffee" } }, "match": "(?<!\\\\)(#).*$\\n?", "name": "comment.line.number-sign.coffee" }] }, "function_calls": { "patterns": [{ "begin": "(@)?([\\w$]+)(?=\\()", "beginCaptures": { "1": { "name": "variable.other.readwrite.instance.coffee" }, "2": { "patterns": [{ "include": "#function_names" }] } }, "end": "(?<=\\))", "name": "meta.function-call.coffee", "patterns": [{ "include": "#arguments" }] }, { "begin": `(?x)
(@)?([\\w$]+)
\\s*
(?=\\s+(?!(?<![\\w$])(of|in|then|is|isnt|and|or|for|else|when|if|unless|by|instanceof)(?![\\w$]))(?=(@?[\\w$]+|[=-]>|\\-\\d|\\[|{|"|')))`, "beginCaptures": { "1": { "name": "variable.other.readwrite.instance.coffee" }, "2": { "patterns": [{ "include": "#function_names" }] } }, "end": "(?=\\s*(?<![\\w$])(of|in|then|is|isnt|and|or|for|else|when|if|unless|by|instanceof)(?![\\w$]))|(?=\\s*(}|\\]|\\)|#|$))", "name": "meta.function-call.coffee", "patterns": [{ "include": "#arguments" }] }] }, "function_names": { "patterns": [{ "match": "(?x)\n\\b(isNaN|isFinite|eval|uneval|parseInt|parseFloat|decodeURI|\ndecodeURIComponent|encodeURI|encodeURIComponent|escape|unescape|\nrequire|set(Interval|Timeout)|clear(Interval|Timeout))\\b", "name": "support.function.coffee" }, { "match": "[a-zA-Z_$][\\w$]*", "name": "entity.name.function.coffee" }, { "match": "\\d[\\w$]*", "name": "invalid.illegal.identifier.coffee" }] }, "function_params": { "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.parameters.begin.bracket.round.coffee" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.parameters.end.bracket.round.coffee" } }, "name": "meta.parameters.coffee", "patterns": [{ "captures": { "1": { "name": "variable.parameter.function.coffee" }, "2": { "name": "keyword.operator.splat.coffee" } }, "match": "([a-zA-Z_$][\\w$]*)(\\.\\.\\.)?" }, { "captures": { "1": { "name": "variable.parameter.function.readwrite.instance.coffee" }, "2": { "name": "keyword.operator.splat.coffee" } }, "match": "(@(?:[a-zA-Z_$][\\w$]*)?)(\\.\\.\\.)?" }, { "include": "$self" }] }] }, "heregexp": { "patterns": [{ "match": "\\\\[bB]|\\^|\\$", "name": "keyword.control.anchor.regexp" }, { "match": "\\\\[1-9]\\d*", "name": "keyword.other.back-reference.regexp" }, { "match": "[?+*]|\\{(\\d+,\\d+|\\d+,|,\\d+|\\d+)\\}\\??", "name": "keyword.operator.quantifier.regexp" }, { "match": "\\|", "name": "keyword.operator.or.regexp" }, { "begin": "(\\()((\\?=)|(\\?!))", "beginCaptures": { "1": { "name": "punctuation.definition.group.regexp" }, "3": { "name": "meta.assertion.look-ahead.regexp" }, "4": { "name": "meta.assertion.negative-look-ahead.regexp" } }, "end": "(\\))", "endCaptures": { "1": { "name": "punctuation.definition.group.regexp" } }, "name": "meta.group.assertion.regexp", "patterns": [{ "include": "#heregexp" }] }, { "begin": "\\((\\?:)?", "beginCaptures": { "0": { "name": "punctuation.definition.group.regexp" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.regexp" } }, "name": "meta.group.regexp", "patterns": [{ "include": "#heregexp" }] }, { "begin": "(\\[)(\\^)?", "beginCaptures": { "1": { "name": "punctuation.definition.character-class.regexp" }, "2": { "name": "keyword.operator.negation.regexp" } }, "end": "(\\])", "endCaptures": { "1": { "name": "punctuation.definition.character-class.regexp" } }, "name": "constant.other.character-class.set.regexp", "patterns": [{ "captures": { "1": { "name": "constant.character.numeric.regexp" }, "2": { "name": "constant.character.control.regexp" }, "3": { "name": "constant.character.escape.backslash.regexp" }, "4": { "name": "constant.character.numeric.regexp" }, "5": { "name": "constant.character.control.regexp" }, "6": { "name": "constant.character.escape.backslash.regexp" } }, "match": "(?:.|(\\\\(?:[0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}))|(\\\\c[A-Z])|(\\\\.))\\-(?:[^\\]\\\\]|(\\\\(?:[0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}))|(\\\\c[A-Z])|(\\\\.))", "name": "constant.other.character-class.range.regexp" }, { "include": "#regex-character-class" }] }, { "include": "#regex-character-class" }, { "include": "#interpolated_coffee" }, { "include": "#embedded_comment" }] }, "instance_variable": { "patterns": [{ "match": "(@)([a-zA-Z_\\$]\\w*)?", "name": "variable.other.readwrite.instance.coffee" }] }, "interpolated_coffee": { "patterns": [{ "begin": "\\#\\{", "captures": { "0": { "name": "punctuation.section.embedded.coffee" } }, "end": "\\}", "name": "source.coffee.embedded.source", "patterns": [{ "include": "$self" }] }] }, "jsx": { "patterns": [{ "include": "#jsx-tag" }, { "include": "#jsx-end-tag" }] }, "jsx-attribute": { "patterns": [{ "captures": { "1": { "name": "entity.other.attribute-name.coffee" }, "2": { "name": "keyword.operator.assignment.coffee" } }, "match": "(?:^|\\s+)([-\\w.]+)\\s*(=)" }, { "include": "#double_quoted_string" }, { "include": "#single_quoted_string" }, { "include": "#jsx-expression" }] }, "jsx-end-tag": { "patterns": [{ "begin": "(</)([-\\w\\.]+)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.coffee" }, "2": { "name": "entity.name.tag.coffee" } }, "end": "(/?>)", "name": "meta.tag.coffee" }] }, "jsx-expression": { "begin": "{", "beginCaptures": { "0": { "name": "meta.brace.curly.coffee" } }, "end": "}", "endCaptures": { "0": { "name": "meta.brace.curly.coffee" } }, "patterns": [{ "include": "#double_quoted_string" }, { "include": "$self" }] }, "jsx-tag": { "patterns": [{ "begin": "(<)([-\\w\\.]+)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.coffee" }, "2": { "name": "entity.name.tag.coffee" } }, "end": "(/?>)", "name": "meta.tag.coffee", "patterns": [{ "include": "#jsx-attribute" }] }] }, "method_calls": { "patterns": [{ "begin": "(?:(\\.)|(::))\\s*([\\w$]+)\\s*(?=\\()", "beginCaptures": { "1": { "name": "punctuation.separator.method.period.coffee" }, "2": { "name": "keyword.operator.prototype.coffee" }, "3": { "patterns": [{ "include": "#method_names" }] } }, "end": "(?<=\\))", "name": "meta.method-call.coffee", "patterns": [{ "include": "#arguments" }] }, { "begin": `(?:(\\.)|(::))\\s*([\\w$]+)\\s*(?=\\s+(?!(?<![\\w$])(of|in|then|is|isnt|and|or|for|else|when|if|unless|by|instanceof)(?![\\w$]))(?=(@|@?[\\w$]+|[=-]>|\\-\\d|\\[|{|"|')))`, "beginCaptures": { "1": { "name": "punctuation.separator.method.period.coffee" }, "2": { "name": "keyword.operator.prototype.coffee" }, "3": { "patterns": [{ "include": "#method_names" }] } }, "end": "(?=\\s*(?<![\\w$])(of|in|then|is|isnt|and|or|for|else|when|if|unless|by|instanceof)(?![\\w$]))|(?=\\s*(}|\\]|\\)|#|$))", "name": "meta.method-call.coffee", "patterns": [{ "include": "#arguments" }] }] }, "method_names": { "patterns": [{ "match": "(?x)\n\\bon(Rowsinserted|Rowsdelete|Rowenter|Rowexit|Resize|Resizestart|Resizeend|Reset|\nReadystatechange|Mouseout|Mouseover|Mousedown|Mouseup|Mousemove|\nBefore(cut|deactivate|unload|update|paste|print|editfocus|activate)|\nBlur|Scrolltop|Submit|Select|Selectstart|Selectionchange|Hover|Help|\nChange|Contextmenu|Controlselect|Cut|Cellchange|Clock|Close|Deactivate|\nDatasetchanged|Datasetcomplete|Dataavailable|Drop|Drag|Dragstart|Dragover|\nDragdrop|Dragenter|Dragend|Dragleave|Dblclick|Unload|Paste|Propertychange|Error|\nErrorupdate|Keydown|Keyup|Keypress|Focus|Load|Activate|Afterupdate|Afterprint|Abort)\\b", "name": "support.function.event-handler.coffee" }, { "match": "(?x)\n\\b(shift|showModelessDialog|showModalDialog|showHelp|scroll|scrollX|scrollByPages|\nscrollByLines|scrollY|scrollTo|stop|strike|sizeToContent|sidebar|signText|sort|\nsup|sub|substr|substring|splice|split|send|set(Milliseconds|Seconds|Minutes|Hours|\nMonth|Year|FullYear|Date|UTC(Milliseconds|Seconds|Minutes|Hours|Month|FullYear|Date)|\nTime|Hotkeys|Cursor|ZOptions|Active|Resizable|RequestHeader)|search|slice|\nsavePreferences|small|home|handleEvent|navigate|char|charCodeAt|charAt|concat|\ncontextual|confirm|compile|clear|captureEvents|call|createStyleSheet|createPopup|\ncreateEventObject|to(GMTString|UTCString|String|Source|UpperCase|LowerCase|LocaleString)|\ntest|taint|taintEnabled|indexOf|italics|disableExternalCapture|dump|detachEvent|unshift|\nuntaint|unwatch|updateCommands|join|javaEnabled|pop|push|plugins.refresh|paddings|parse|\nprint|prompt|preference|enableExternalCapture|exec|execScript|valueOf|UTC|find|file|\nfileModifiedDate|fileSize|fileCreatedDate|fileUpdatedDate|fixed|fontsize|fontcolor|\nforward|fromCharCode|watch|link|load|lastIndexOf|anchor|attachEvent|atob|apply|alert|\nabort|routeEvents|resize|resizeBy|resizeTo|recalc|returnValue|replace|reverse|reload|\nreleaseCapture|releaseEvents|go|get(Milliseconds|Seconds|Minutes|Hours|Month|Day|Year|FullYear|\nTime|Date|TimezoneOffset|UTC(Milliseconds|Seconds|Minutes|Hours|Day|Month|FullYear|Date)|\nAttention|Selection|ResponseHeader|AllResponseHeaders)|moveBy|moveBelow|moveTo|\nmoveToAbsolute|moveAbove|mergeAttributes|match|margins|btoa|big|bold|borderWidths|blink|back)\\b", "name": "support.function.coffee" }, { "match": "(?x)\n\\b(acceptNode|add|addEventListener|addTextTrack|adoptNode|after|animate|append|\nappendChild|appendData|before|blur|canPlayType|captureStream|\ncaretPositionFromPoint|caretRangeFromPoint|checkValidity|clear|click|\ncloneContents|cloneNode|cloneRange|close|closest|collapse|\ncompareBoundaryPoints|compareDocumentPosition|comparePoint|contains|\nconvertPointFromNode|convertQuadFromNode|convertRectFromNode|createAttribute|\ncreateAttributeNS|createCaption|createCDATASection|createComment|\ncreateContextualFragment|createDocument|createDocumentFragment|\ncreateDocumentType|createElement|createElementNS|createEntityReference|\ncreateEvent|createExpression|createHTMLDocument|createNodeIterator|\ncreateNSResolver|createProcessingInstruction|createRange|createShadowRoot|\ncreateTBody|createTextNode|createTFoot|createTHead|createTreeWalker|delete|\ndeleteCaption|deleteCell|deleteContents|deleteData|deleteRow|deleteTFoot|\ndeleteTHead|detach|disconnect|dispatchEvent|elementFromPoint|elementsFromPoint|\nenableStyleSheetsForSet|entries|evaluate|execCommand|exitFullscreen|\nexitPointerLock|expand|extractContents|fastSeek|firstChild|focus|forEach|get|\ngetAll|getAnimations|getAttribute|getAttributeNames|getAttributeNode|\ngetAttributeNodeNS|getAttributeNS|getBoundingClientRect|getBoxQuads|\ngetClientRects|getContext|getDestinationInsertionPoints|getElementById|\ngetElementsByClassName|getElementsByName|getElementsByTagName|\ngetElementsByTagNameNS|getItem|getNamedItem|getSelection|getStartDate|\ngetVideoPlaybackQuality|has|hasAttribute|hasAttributeNS|hasAttributes|\nhasChildNodes|hasFeature|hasFocus|importNode|initEvent|insertAdjacentElement|\ninsertAdjacentHTML|insertAdjacentText|insertBefore|insertCell|insertData|\ninsertNode|insertRow|intersectsNode|isDefaultNamespace|isEqualNode|\nisPointInRange|isSameNode|item|key|keys|lastChild|load|lookupNamespaceURI|\nlookupPrefix|matches|move|moveAttribute|moveAttributeNode|moveChild|\nmoveNamedItem|namedItem|nextNode|nextSibling|normalize|observe|open|\nparentNode|pause|play|postMessage|prepend|preventDefault|previousNode|\npreviousSibling|probablySupportsContext|queryCommandEnabled|\nqueryCommandIndeterm|queryCommandState|queryCommandSupported|queryCommandValue|\nquerySelector|querySelectorAll|registerContentHandler|registerElement|\nregisterProtocolHandler|releaseCapture|releaseEvents|remove|removeAttribute|\nremoveAttributeNode|removeAttributeNS|removeChild|removeEventListener|\nremoveItem|replace|replaceChild|replaceData|replaceWith|reportValidity|\nrequestFullscreen|requestPointerLock|reset|scroll|scrollBy|scrollIntoView|\nscrollTo|seekToNextFrame|select|selectNode|selectNodeContents|set|setAttribute|\nsetAttributeNode|setAttributeNodeNS|setAttributeNS|setCapture|\nsetCustomValidity|setEnd|setEndAfter|setEndBefore|setItem|setNamedItem|\nsetRangeText|setSelectionRange|setSinkId|setStart|setStartAfter|setStartBefore|\nslice|splitText|stepDown|stepUp|stopImmediatePropagation|stopPropagation|\nsubmit|substringData|supports|surroundContents|takeRecords|terminate|toBlob|\ntoDataURL|toggle|toString|values|write|writeln)\\b", "name": "support.function.dom.coffee" }, { "match": "[a-zA-Z_$][\\w$]*", "name": "entity.name.function.coffee" }, { "match": "\\d[\\w$]*", "name": "invalid.illegal.identifier.coffee" }] }, "numbers": { "patterns": [{ "match": "\\b(?<!\\$)0(x|X)[0-9a-fA-F]+\\b(?!\\$)", "name": "constant.numeric.hex.coffee" }, { "match": "\\b(?<!\\$)0(b|B)[01]+\\b(?!\\$)", "name": "constant.numeric.binary.coffee" }, { "match": "\\b(?<!\\$)0(o|O)?[0-7]+\\b(?!\\$)", "name": "constant.numeric.octal.coffee" }, { "captures": { "0": { "name": "constant.numeric.decimal.coffee" }, "1": { "name": "punctuation.separator.decimal.period.coffee" }, "2": { "name": "punctuation.separator.decimal.period.coffee" }, "3": { "name": "punctuation.separator.decimal.period.coffee" }, "4": { "name": "punctuation.separator.decimal.period.coffee" }, "5": { "name": "punctuation.separator.decimal.period.coffee" }, "6": { "name": "punctuation.separator.decimal.period.coffee" } }, "match": "(?x)\n(?<!\\$)(?:\n  (?:\\b[0-9]+(\\.)[0-9]+[eE][+-]?[0-9]+\\b)| # 1.1E+3\n  (?:\\b[0-9]+(\\.)[eE][+-]?[0-9]+\\b)|       # 1.E+3\n  (?:\\B(\\.)[0-9]+[eE][+-]?[0-9]+\\b)|       # .1E+3\n  (?:\\b[0-9]+[eE][+-]?[0-9]+\\b)|            # 1E+3\n  (?:\\b[0-9]+(\\.)[0-9]+\\b)|                # 1.1\n  (?:\\b[0-9]+(?=\\.{2,3}))|                  # 1 followed by a slice\n  (?:\\b[0-9]+(\\.)\\B)|                      # 1.\n  (?:\\B(\\.)[0-9]+\\b)|                      # .1\n  (?:\\b[0-9]+\\b(?!\\.))                     # 1\n)(?!\\$)" }] }, "objects": { "patterns": [{ "match": "[A-Z][A-Z0-9_$]*(?=\\s*\\??(\\.\\s*[a-zA-Z_$]\\w*|::))", "name": "constant.other.object.coffee" }, { "match": "[a-zA-Z_$][\\w$]*(?=\\s*\\??(\\.\\s*[a-zA-Z_$]\\w*|::))", "name": "variable.other.object.coffee" }] }, "operators": { "patterns": [{ "captures": { "1": { "name": "variable.assignment.coffee" }, "2": { "name": "keyword.operator.assignment.compound.coffee" } }, "match": "(?:([a-zA-Z$_][\\w$]*)?\\s+|(?<![\\w$]))(and=|or=)" }, { "captures": { "1": { "name": "variable.assignment.coffee" }, "2": { "name": "keyword.operator.assignment.compound.coffee" } }, "match": "([a-zA-Z$_][\\w$]*)?\\s*(%=|\\+=|-=|\\*=|&&=|\\|\\|=|\\?=|(?<!\\()/=)" }, { "captures": { "1": { "name": "variable.assignment.coffee" }, "2": { "name": "keyword.operator.assignment.compound.bitwise.coffee" } }, "match": "([a-zA-Z$_][\\w$]*)?\\s*(&=|\\^=|<<=|>>=|>>>=|\\|=)" }, { "match": "<<|>>>|>>", "name": "keyword.operator.bitwise.shift.coffee" }, { "match": "!=|<=|>=|==|<|>", "name": "keyword.operator.comparison.coffee" }, { "match": "&&|!|\\|\\|", "name": "keyword.operator.logical.coffee" }, { "match": "&|\\||\\^|~", "name": "keyword.operator.bitwise.coffee" }, { "captures": { "1": { "name": "variable.assignment.coffee" }, "2": { "name": "keyword.operator.assignment.coffee" } }, "match": "([a-zA-Z$_][\\w$]*)?\\s*(=|:(?!:))(?![>=])" }, { "match": "--", "name": "keyword.operator.decrement.coffee" }, { "match": "\\+\\+", "name": "keyword.operator.increment.coffee" }, { "match": "\\.\\.\\.", "name": "keyword.operator.splat.coffee" }, { "match": "\\?", "name": "keyword.operator.existential.coffee" }, { "match": "%|\\*|/|-|\\+", "name": "keyword.operator.coffee" }, { "captures": { "1": { "name": "keyword.operator.logical.coffee" }, "2": { "name": "keyword.operator.comparison.coffee" } }, "match": "(?x)\n\\b(?<![\\.\\$])\n(?:\n  (and|or|not) # logical\n  |\n  (is|isnt) # comparison\n)\n(?!\\s*:)\\b" }] }, "properties": { "patterns": [{ "captures": { "1": { "name": "punctuation.separator.property.period.coffee" }, "2": { "name": "keyword.operator.prototype.coffee" }, "3": { "name": "constant.other.object.property.coffee" } }, "match": "(?:(\\.)|(::))\\s*([A-Z][A-Z0-9_$]*\\b\\$*)(?=\\s*\\??(\\.\\s*[a-zA-Z_$]\\w*|::))" }, { "captures": { "1": { "name": "punctuation.separator.property.period.coffee" }, "2": { "name": "keyword.operator.prototype.coffee" }, "3": { "name": "variable.other.object.property.coffee" } }, "match": "(?:(\\.)|(::))\\s*(\\$*[a-zA-Z_$][\\w$]*)(?=\\s*\\??(\\.\\s*[a-zA-Z_$]\\w*|::))" }, { "captures": { "1": { "name": "punctuation.separator.property.period.coffee" }, "2": { "name": "keyword.operator.prototype.coffee" }, "3": { "name": "constant.other.property.coffee" } }, "match": "(?:(\\.)|(::))\\s*([A-Z][A-Z0-9_$]*\\b\\$*)" }, { "captures": { "1": { "name": "punctuation.separator.property.period.coffee" }, "2": { "name": "keyword.operator.prototype.coffee" }, "3": { "name": "variable.other.property.coffee" } }, "match": "(?:(\\.)|(::))\\s*(\\$*[a-zA-Z_$][\\w$]*)" }, { "captures": { "1": { "name": "punctuation.separator.property.period.coffee" }, "2": { "name": "keyword.operator.prototype.coffee" }, "3": { "name": "invalid.illegal.identifier.coffee" } }, "match": "(?:(\\.)|(::))\\s*([0-9][\\w$]*)" }] }, "regex-character-class": { "patterns": [{ "match": "\\\\[wWsSdD]|\\.", "name": "constant.character.character-class.regexp" }, { "match": "\\\\([0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4})", "name": "constant.character.numeric.regexp" }, { "match": "\\\\c[A-Z]", "name": "constant.character.control.regexp" }, { "match": "\\\\.", "name": "constant.character.escape.backslash.regexp" }] }, "single_quoted_string": { "patterns": [{ "begin": "'", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.coffee" } }, "end": "'", "endCaptures": { "0": { "name": "punctuation.definition.string.end.coffee" } }, "name": "string.quoted.single.coffee", "patterns": [{ "captures": { "1": { "name": "punctuation.definition.escape.backslash.coffee" } }, "match": "(\\\\)(x[0-9A-Fa-f]{2}|[0-2][0-7]{0,2}|3[0-6][0-7]?|37[0-7]?|[4-7][0-7]?|.)", "name": "constant.character.escape.backslash.coffee" }] }] } }, "scopeName": "source.coffee", "embeddedLangs": ["javascript"], "aliases": ["coffeescript"] });
var coffee = [
  ...javascript,
  lang$g
];
var lang$f = Object.freeze({ "displayName": "Pug", "name": "pug", "patterns": [{ "comment": "Doctype declaration.", "match": "^(!!!|doctype)(\\s*[a-zA-Z0-9-_]+)?", "name": "meta.tag.sgml.doctype.html" }, { "begin": "^(\\s*)//-", "comment": "Unbuffered (pug-only) comments.", "end": "^(?!(\\1\\s)|\\s*$)", "name": "comment.unbuffered.block.pug" }, { "begin": "^(\\s*)//", "comment": "Buffered (html) comments.", "end": "^(?!(\\1\\s)|\\s*$)", "name": "string.comment.buffered.block.pug", "patterns": [{ "captures": { "1": { "name": "invalid.illegal.comment.comment.block.pug" } }, "comment": "Buffered comments inside buffered comments will generate invalid html.", "match": "^\\s*(//)(?!-)", "name": "string.comment.buffered.block.pug" }] }, { "begin": "<!--", "end": "--\\s*>", "name": "comment.unbuffered.block.pug", "patterns": [{ "match": "--", "name": "invalid.illegal.comment.comment.block.pug" }] }, { "begin": "^(\\s*)-$", "comment": "Unbuffered code block.", "end": "^(?!(\\1\\s)|\\s*$)", "name": "source.js", "patterns": [{ "include": "source.js" }] }, { "begin": "^(\\s*)(script)((\\.$)|(?=[^\\n]*((text|application)/javascript|module).*\\.$))", "beginCaptures": { "2": { "name": "entity.name.tag.pug" } }, "comment": "Script tag with JavaScript code.", "end": "^(?!(\\1\\s)|\\s*$)", "name": "meta.tag.other", "patterns": [{ "begin": "\\G(?=\\()", "end": "$", "patterns": [{ "include": "#tag_attributes" }] }, { "begin": "\\G(?=[.#])", "end": "$", "patterns": [{ "include": "#complete_tag" }] }, { "include": "source.js" }] }, { "begin": "^(\\s*)(style)((\\.$)|(?=[.#(].*\\.$))", "beginCaptures": { "2": { "name": "entity.name.tag.pug" } }, "comment": "Style tag with CSS code.", "end": "^(?!(\\1\\s)|\\s*$)", "name": "meta.tag.other", "patterns": [{ "begin": "\\G(?=\\()", "end": "$", "patterns": [{ "include": "#tag_attributes" }] }, { "begin": "\\G(?=[.#])", "end": "$", "patterns": [{ "include": "#complete_tag" }] }, { "include": "source.css" }] }, { "begin": "^(\\s*):(sass)(?=\\(|$)", "beginCaptures": { "2": { "name": "constant.language.name.sass.filter.pug" } }, "end": "^(?!(\\1\\s)|\\s*$)", "name": "source.sass.filter.pug", "patterns": [{ "include": "#tag_attributes" }, { "include": "source.sass" }] }, { "begin": "^(\\s*):(scss)(?=\\(|$)", "beginCaptures": { "2": { "name": "constant.language.name.scss.filter.pug" } }, "end": "^(?!(\\1\\s)|\\s*$)", "name": "source.css.scss.filter.pug", "patterns": [{ "include": "#tag_attributes" }, { "include": "source.css.scss" }] }, { "begin": "^(\\s*):(less)(?=\\(|$)", "beginCaptures": { "2": { "name": "constant.language.name.less.filter.pug" } }, "end": "^(?!(\\1\\s)|\\s*$)", "name": "source.less.filter.pug", "patterns": [{ "include": "#tag_attributes" }, { "include": "source.less" }] }, { "begin": "^(\\s*):(stylus)(?=\\(|$)", "beginCaptures": { "2": { "name": "constant.language.name.stylus.filter.pug" } }, "end": "^(?!(\\1\\s)|\\s*$)", "patterns": [{ "include": "#tag_attributes" }, { "include": "source.stylus" }] }, { "begin": "^(\\s*):(coffee(-?script)?)(?=\\(|$)", "beginCaptures": { "2": { "name": "constant.language.name.coffeescript.filter.pug" } }, "end": "^(?!(\\1\\s)|\\s*$)", "name": "source.coffeescript.filter.pug", "patterns": [{ "include": "#tag_attributes" }, { "include": "source.coffee" }] }, { "begin": "^(\\s*):(uglify-js)(?=\\(|$)", "beginCaptures": { "2": { "name": "constant.language.name.js.filter.pug" } }, "end": "^(?!(\\1\\s)|\\s*$)", "name": "source.js.filter.pug", "patterns": [{ "include": "#tag_attributes" }, { "include": "source.js" }] }, { "begin": "^(\\s*)((:(?=.))|(:$))", "beginCaptures": { "4": { "name": "invalid.illegal.empty.generic.filter.pug" } }, "comment": "Generic Pug filter.", "end": "^(?!(\\1\\s)|\\s*$)", "patterns": [{ "begin": "\\G(?<=:)(?=.)", "end": "$", "name": "name.generic.filter.pug", "patterns": [{ "match": "\\G\\(", "name": "invalid.illegal.name.generic.filter.pug" }, { "match": "[\\w-]", "name": "constant.language.name.generic.filter.pug" }, { "include": "#tag_attributes" }, { "match": "\\W", "name": "invalid.illegal.name.generic.filter.pug" }] }] }, { "begin": `^(\\s*)(?:(?=\\.$)|(?:(?=[\\w.#].*?\\.$)(?=(?:(?:(?:(?:(?:#[\\w-]+)|(?:\\.[\\w-]+))|(?:(?:[#!]\\{[^}]*\\})|(?:\\w(?:(?:[\\w:-]+[\\w-])|(?:[\\w-]*)))))(?:(?:#[\\w-]+)|(?:\\.[\\w-]+)|(?:\\((?:[^()\\'\\"]*(?:(?:\\'(?:[^\\']|(?:(?<!\\\\)\\\\\\'))*\\')|(?:\\"(?:[^\\"]|(?:(?<!\\\\)\\\\\\"))*\\")))*[^()]*\\))*)*)(?:(?:(?::\\s+)|(?<=\\)))(?:(?:(?:(?:#[\\w-]+)|(?:\\.[\\w-]+))|(?:(?:[#!]\\{[^}]*\\})|(?:\\w(?:(?:[\\w:-]+[\\w-])|(?:[\\w-]*)))))(?:(?:#[\\w-]+)|(?:\\.[\\w-]+)|(?:\\((?:[^()\\'\\"]*(?:(?:\\'(?:[^\\']|(?:(?<!\\\\)\\\\\\'))*\\')|(?:\\"(?:[^\\"]|(?:(?<!\\\\)\\\\\\"))*\\")))*[^()]*\\))*)*))*)\\.$)(?:(?:(#[\\w-]+)|(\\.[\\w-]+))|((?:[#!]\\{[^}]*\\})|(?:\\w(?:(?:[\\w:-]+[\\w-])|(?:[\\w-]*)))))))`, "beginCaptures": { "2": { "name": "meta.selector.css entity.other.attribute-name.id.css.pug" }, "3": { "name": "meta.selector.css entity.other.attribute-name.class.css.pug" }, "4": { "name": "meta.tag.other entity.name.tag.pug" } }, "comment": "Generated from dot_block_tag.py", "end": "^(?!(\\1\\s)|\\s*$)", "patterns": [{ "match": "\\.$", "name": "storage.type.function.pug.dot-block-dot" }, { "include": "#tag_attributes" }, { "include": "#complete_tag" }, { "begin": "^(?=.)", "end": "$", "name": "text.block.pug", "patterns": [{ "include": "#inline_pug" }, { "include": "#embedded_html" }, { "include": "#html_entity" }, { "include": "#interpolated_value" }, { "include": "#interpolated_error" }] }] }, { "begin": "^\\s*", "comment": "All constructs that generally span a single line starting with any number of white-spaces.", "end": "$", "patterns": [{ "include": "#inline_pug" }, { "include": "#blocks_and_includes" }, { "include": "#unbuffered_code" }, { "include": "#mixin_definition" }, { "include": "#mixin_call" }, { "include": "#flow_control" }, { "include": "#flow_control_each" }, { "include": "#case_conds" }, { "begin": "\\|", "comment": "Tag pipe text line.", "end": "$", "name": "text.block.pipe.pug", "patterns": [{ "include": "#inline_pug" }, { "include": "#embedded_html" }, { "include": "#html_entity" }, { "include": "#interpolated_value" }, { "include": "#interpolated_error" }] }, { "include": "#printed_expression" }, { "begin": "\\G(?=(#[^\\{\\w-])|[^\\w.#])", "comment": "Line starting with characters incompatible with tag name/id/class is standalone text.", "end": "$", "patterns": [{ "begin": "</?(?=[!#])", "end": ">|$", "patterns": [{ "include": "#inline_pug" }, { "include": "#interpolated_value" }, { "include": "#interpolated_error" }] }, { "include": "#inline_pug" }, { "include": "#embedded_html" }, { "include": "#html_entity" }, { "include": "#interpolated_value" }, { "include": "#interpolated_error" }] }, { "include": "#complete_tag" }] }], "repository": { "babel_parens": { "begin": "\\(", "end": "\\)|(({\\s*)?$)", "patterns": [{ "include": "#babel_parens" }, { "include": "source.js" }] }, "blocks_and_includes": { "captures": { "1": { "name": "storage.type.import.include.pug" }, "4": { "name": "variable.control.import.include.pug" } }, "comment": "Template blocks and includes.", "match": "(extends|include|yield|append|prepend|block( (append|prepend))?)\\s+(.*)$", "name": "meta.first-class.pug" }, "case_conds": { "begin": "(default|when)((\\s+|(?=:))|$)", "captures": { "1": { "name": "storage.type.function.pug" } }, "comment": "Pug case conditionals.", "end": "$", "name": "meta.control.flow.pug", "patterns": [{ "begin": "\\G(?!:)", "end": "(?=:\\s+)|$", "name": "js.embedded.control.flow.pug", "patterns": [{ "include": "#case_when_paren" }, { "include": "source.js" }] }, { "begin": ":\\s+", "end": "$", "name": "tag.case.control.flow.pug", "patterns": [{ "include": "#complete_tag" }] }] }, "case_when_paren": { "begin": "\\(", "end": "\\)", "name": "js.when.control.flow.pug", "patterns": [{ "include": "#case_when_paren" }, { "match": ":", "name": "invalid.illegal.name.tag.pug" }, { "include": "source.js" }] }, "complete_tag": { "begin": "(?=[\\w.#])|(:\\s*)", "end": "(\\.?$)|(?=:.)", "endCaptures": { "1": { "name": "storage.type.function.pug.dot-block-dot" } }, "patterns": [{ "include": "#blocks_and_includes" }, { "include": "#unbuffered_code" }, { "include": "#mixin_call" }, { "include": "#flow_control" }, { "include": "#flow_control_each" }, { "match": "(?<=:)\\w.*$", "name": "invalid.illegal.name.tag.pug" }, { "include": "#tag_name" }, { "include": "#tag_id" }, { "include": "#tag_classes" }, { "include": "#tag_attributes" }, { "include": "#tag_mixin_attributes" }, { "captures": { "2": { "name": "invalid.illegal.end.tag.pug" }, "4": { "name": "invalid.illegal.end.tag.pug" } }, "match": "((\\.)\\s+$)|((:)\\s*$)" }, { "include": "#printed_expression" }, { "include": "#tag_text" }] }, "embedded_html": { "begin": "(?=<[^>]*>)", "end": "$|(?=>)", "name": "html", "patterns": [{ "include": "text.html.basic" }, { "include": "#interpolated_value" }, { "include": "#interpolated_error" }] }, "flow_control": { "begin": "(for|if|else if|else|until|while|unless|case)(\\s+|$)", "captures": { "1": { "name": "storage.type.function.pug" } }, "comment": "Pug control flow.", "end": "$", "name": "meta.control.flow.pug", "patterns": [{ "begin": "", "end": "$", "name": "js.embedded.control.flow.pug", "patterns": [{ "include": "source.js" }] }] }, "flow_control_each": { "begin": "(each)(\\s+|$)", "captures": { "1": { "name": "storage.type.function.pug" } }, "end": "$", "name": "meta.control.flow.pug.each", "patterns": [{ "match": "([\\w$_]+)(?:\\s*,\\s*([\\w$_]+))?", "name": "variable.other.pug.each-var" }, { "begin": "", "end": "$", "name": "js.embedded.control.flow.pug", "patterns": [{ "include": "source.js" }] }] }, "html_entity": { "patterns": [{ "match": "(&)([a-zA-Z0-9]+|#[0-9]+|#x[0-9a-fA-F]+)(;)", "name": "constant.character.entity.html.text.pug" }, { "match": "[<>&]", "name": "invalid.illegal.html_entity.text.pug" }] }, "inline_pug": { "begin": "(?<!\\\\)(#\\[)", "captures": { "1": { "name": "entity.name.function.pug" }, "2": { "name": "entity.name.function.pug" } }, "end": "(\\])", "name": "inline.pug", "patterns": [{ "include": "#inline_pug" }, { "include": "#mixin_call" }, { "begin": "(?<!\\])(?=[\\w.#])|(:\\s*)", "end": "(?=\\]|(:.)|=|\\s)", "name": "tag.inline.pug", "patterns": [{ "include": "#tag_name" }, { "include": "#tag_id" }, { "include": "#tag_classes" }, { "include": "#tag_attributes" }, { "include": "#tag_mixin_attributes" }, { "include": "#inline_pug" }, { "match": "\\[", "name": "invalid.illegal.tag.pug" }] }, { "include": "#unbuffered_code" }, { "include": "#printed_expression" }, { "match": "\\[", "name": "invalid.illegal.tag.pug" }, { "include": "#inline_pug_text" }] }, "inline_pug_text": { "begin": "", "end": "(?=\\])", "patterns": [{ "begin": "\\[", "end": "\\]", "patterns": [{ "include": "#inline_pug_text" }] }, { "include": "#inline_pug" }, { "include": "#embedded_html" }, { "include": "#html_entity" }, { "include": "#interpolated_value" }, { "include": "#interpolated_error" }] }, "interpolated_error": { "match": "(?<!\\\\)[#!]\\{(?=[^}]*$)", "name": "invalid.illegal.tag.pug" }, "interpolated_value": { "begin": "(?<!\\\\)[#!]\\{(?=.*?\\})", "end": "\\}", "name": "string.interpolated.pug", "patterns": [{ "match": "{", "name": "invalid.illegal.tag.pug" }, { "include": "source.js" }] }, "js_braces": { "begin": "\\{", "end": "\\}", "patterns": [{ "include": "#js_braces" }, { "include": "source.js" }] }, "js_brackets": { "begin": "\\[", "end": "\\]", "patterns": [{ "include": "#js_brackets" }, { "include": "source.js" }] }, "js_parens": { "begin": "\\(", "end": "\\)", "patterns": [{ "include": "#js_parens" }, { "include": "source.js" }] }, "mixin_call": { "begin": "((?:mixin\\s+)|\\+)([\\w-]+)", "beginCaptures": { "1": { "name": "storage.type.function.pug" }, "2": { "name": "meta.tag.other entity.name.function.pug" } }, "end": "(?!\\()|$", "patterns": [{ "begin": "(?<!\\))\\(", "end": "\\)", "name": "args.mixin.pug", "patterns": [{ "include": "#js_parens" }, { "captures": { "1": { "name": "meta.tag.other entity.other.attribute-name.tag.pug" } }, "match": "([^\\s(),=/]+)\\s*=\\s*" }, { "include": "source.js" }] }, { "include": "#tag_attributes" }] }, "mixin_definition": { "captures": { "1": { "name": "storage.type.function.pug" }, "2": { "name": "meta.tag.other entity.name.function.pug" }, "3": { "name": "punctuation.definition.parameters.begin.js" }, "4": { "name": "variable.parameter.function.js" }, "5": { "name": "punctuation.definition.parameters.begin.js" } }, "match": "(mixin\\s+)([\\w-]+)(?:(\\()\\s*((?:[a-zA-Z_]\\w*\\s*)(?:,\\s*[a-zA-Z_]\\w*\\s*)*)(\\)))?$" }, "printed_expression": { "begin": "(!?\\=)\\s*", "captures": { "1": { "name": "constant" } }, "end": "(?=\\])|$", "name": "source.js", "patterns": [{ "include": "#js_brackets" }, { "include": "source.js" }] }, "tag_attribute_name": { "captures": { "1": { "name": "entity.other.attribute-name.tag.pug" } }, "match": "([^\\s(),=/!]+)\\s*" }, "tag_attribute_name_paren": { "begin": "\\(\\s*", "end": "\\)", "name": "entity.other.attribute-name.tag.pug", "patterns": [{ "include": "#tag_attribute_name_paren" }, { "include": "#tag_attribute_name" }] }, "tag_attributes": { "begin": "(\\(\\s*)", "captures": { "1": { "name": "constant.name.attribute.tag.pug" } }, "end": "(\\))", "name": "meta.tag.other", "patterns": [{ "include": "#tag_attribute_name_paren" }, { "include": "#tag_attribute_name" }, { "match": "!(?!=)", "name": "invalid.illegal.tag.pug" }, { "begin": "=\\s*", "end": "$|(?=,|(?:\\s+[^!%&*\\-+~|<>?/])|\\))", "name": "attribute_value", "patterns": [{ "include": "#js_parens" }, { "include": "#js_brackets" }, { "include": "#js_braces" }, { "include": "source.js" }] }, { "begin": "(?<=[%&*\\-+~|<>:?/])\\s+", "end": "$|(?=,|(?:\\s+[^!%&*\\-+~|<>?/])|\\))", "name": "attribute_value2", "patterns": [{ "include": "#js_parens" }, { "include": "#js_brackets" }, { "include": "#js_braces" }, { "include": "source.js" }] }] }, "tag_classes": { "captures": { "1": { "name": "invalid.illegal.tag.pug" } }, "match": "\\.([^\\w-])?[\\w-]*", "name": "meta.selector.css entity.other.attribute-name.class.css.pug" }, "tag_id": { "match": "#[\\w-]+", "name": "meta.selector.css entity.other.attribute-name.id.css.pug" }, "tag_mixin_attributes": { "begin": "(&attributes\\()", "captures": { "1": { "name": "entity.name.function.pug" } }, "end": "(\\))", "name": "meta.tag.other", "patterns": [{ "match": "attributes(?=\\))", "name": "storage.type.keyword.pug" }, { "include": "source.js" }] }, "tag_name": { "begin": "([#!]\\{(?=.*?\\}))|(\\w(([\\w:-]+[\\w-])|([\\w-]*)))", "end": "(\\G(?<!\\5[^\\w-]))|\\}|$", "name": "meta.tag.other entity.name.tag.pug", "patterns": [{ "begin": "\\G(?<=\\{)", "end": "(?=\\})", "name": "meta.tag.other entity.name.tag.pug", "patterns": [{ "match": "{", "name": "invalid.illegal.tag.pug" }, { "include": "source.js" }] }] }, "tag_text": { "begin": "(?=.)", "end": "$", "patterns": [{ "include": "#inline_pug" }, { "include": "#embedded_html" }, { "include": "#html_entity" }, { "include": "#interpolated_value" }, { "include": "#interpolated_error" }] }, "unbuffered_code": { "begin": "(-|(([a-zA-Z0-9_]+)\\s+=))", "beginCaptures": { "3": { "name": "variable.parameter.javascript.embedded.pug" } }, "comment": "name = function() {}", "end": "(?=\\])|(({\\s*)?$)", "name": "source.js", "patterns": [{ "include": "#js_brackets" }, { "include": "#babel_parens" }, { "include": "source.js" }] } }, "scopeName": "text.pug", "embeddedLangs": ["javascript", "css", "sass", "scss", "stylus", "coffee", "html"], "aliases": ["jade"] });
var pug = [
  ...javascript,
  ...css,
  ...sass,
  ...scss,
  ...stylus,
  ...coffee,
  ...html,
  lang$f
];
var lang$e = Object.freeze({ "displayName": "Less", "name": "less", "patterns": [{ "include": "#comment-block" }, { "include": "#less-namespace-accessors" }, { "include": "#less-extend" }, { "include": "#at-rules" }, { "include": "#less-variable-assignment" }, { "include": "#property-list" }, { "include": "#selector" }], "repository": { "angle-type": { "captures": { "1": { "name": "keyword.other.unit.less" } }, "match": "(?i:[-+]?(?:(?:\\d*\\.\\d+(?:[eE](?:[-+]?\\d+))*)|(?:[-+]?\\d+))(deg|grad|rad|turn))\\b", "name": "constant.numeric.less" }, "at-charset": { "begin": "\\s*((@)charset\\b)\\s*", "captures": { "1": { "name": "keyword.control.at-rule.charset.less" }, "2": { "name": "punctuation.definition.keyword.less" } }, "end": "\\s*((?=;|$))", "name": "meta.at-rule.charset.less", "patterns": [{ "include": "#literal-string" }] }, "at-counter-style": { "begin": "\\s*((@)counter-style\\b)\\s+(?:(?i:\\b(decimal|none)\\b)|(-?(?:[[_a-zA-Z][^\\x{00}-\\x{7F}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))(?:[[-\\w][^\\x{00}-\\x{7F}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))*))\\s*(?=\\{|$)", "captures": { "1": { "name": "keyword.control.at-rule.counter-style.less" }, "2": { "name": "punctuation.definition.keyword.less" }, "3": { "name": "invalid.illegal.counter-style-name.less" }, "4": { "name": "entity.other.counter-style-name.css" } }, "end": "\\s*(\\})", "endCaptures": { "1": { "name": "punctuation.definition.block.begin.less" } }, "name": "meta.at-rule.counter-style.less", "patterns": [{ "include": "#comment-block" }, { "include": "#rule-list" }] }, "at-custom-media": { "begin": "(?=\\s*@custom-media\\b)", "end": "\\s*(?=;)", "name": "meta.at-rule.custom-media.less", "patterns": [{ "captures": { "0": { "name": "punctuation.section.property-list.less" } }, "match": "\\s*;" }, { "captures": { "1": { "name": "keyword.control.at-rule.custom-media.less" }, "2": { "name": "punctuation.definition.keyword.less" }, "3": { "name": "support.constant.custom-media.less" } }, "match": "\\s*((@)custom-media)(?=.*?)" }, { "include": "#media-query-list" }] }, "at-font-face": { "begin": "\\s*((@)font-face)\\s*(?=\\{|$)", "captures": { "1": { "name": "keyword.control.at-rule.font-face.less" }, "2": { "name": "punctuation.definition.keyword.less" } }, "end": "\\s*(\\})", "endCaptures": { "1": { "name": "punctuation.definition.block.end.less" } }, "name": "meta.at-rule.font-face.less", "patterns": [{ "include": "#comment-block" }, { "include": "#rule-list" }] }, "at-import": { "begin": "\\s*((@)import\\b)\\s*", "beginCaptures": { "1": { "name": "keyword.control.at-rule.import.less" }, "2": { "name": "punctuation.definition.keyword.less" } }, "end": "\\;", "endCaptures": { "0": { "name": "punctuation.terminator.rule.less" } }, "name": "meta.at-rule.import.less", "patterns": [{ "include": "#url-function" }, { "include": "#less-variables" }, { "begin": `(?<=(["'])|(["']\\)))\\s*`, "end": "\\s*(?=\\;)", "patterns": [{ "include": "#media-query" }] }, { "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.group.less", "patterns": [{ "match": "reference|inline|less|css|once|multiple|optional", "name": "constant.language.import-directive.less" }, { "include": "#comma-delimiter" }] }, { "include": "#literal-string" }] }, "at-keyframes": { "begin": "\\s*((@)(-webkit-|-moz-|-o-)?keyframes)(?=.*?\\{)", "beginCaptures": { "1": { "name": "keyword.control.at-rule.keyframe.less" }, "2": { "name": "punctuation.definition.keyword.less" }, "3": { "name": "support.type.property-vendor.less" }, "4": { "name": "support.constant.keyframe.less" } }, "end": "\\s*(\\})", "endCaptures": { "1": { "name": "punctuation.definition.block.end.less" } }, "patterns": [{ "begin": "\\s*(\\{)", "beginCaptures": { "1": { "name": "punctuation.definition.block.begin.less" } }, "end": "(?=\\})", "patterns": [{ "captures": { "1": { "name": "keyword.other.keyframe-selector.less" }, "2": { "name": "constant.numeric.less" }, "3": { "name": "keyword.other.unit.less" } }, "match": "\\s*(?:(from|to)|((?:\\.[0-9]+|[0-9]+(?:\\.[0-9]*)?)(%)))\\s*,?\\s*" }, { "include": "$self" }] }, { "begin": "\\s*(?=[^{;])", "end": "\\s*(?=\\{)", "name": "meta.at-rule.keyframe.less", "patterns": [{ "include": "#keyframe-name" }] }] }, "at-media": { "begin": "(?=\\s*@media\\b)", "end": "\\s*(\\})", "endCaptures": { "1": { "name": "punctuation.definition.block.end.less" } }, "patterns": [{ "begin": "\\s*((@)media)", "beginCaptures": { "1": { "name": "keyword.control.at-rule.media.less" }, "2": { "name": "punctuation.definition.keyword.less" }, "3": { "name": "support.constant.media.less" } }, "end": "\\s*(?=\\{)", "name": "meta.at-rule.media.less", "patterns": [{ "include": "#media-query-list" }] }, { "begin": "\\s*(\\{)", "beginCaptures": { "1": { "name": "punctuation.definition.block.begin.less" } }, "end": "(?=\\})", "patterns": [{ "include": "#rule-list-body" }, { "include": "$self" }] }] }, "at-namespace": { "begin": "\\s*((@)namespace)\\s+", "beginCaptures": { "1": { "name": "keyword.control.at-rule.namespace.less" }, "2": { "name": "punctuation.definition.keyword.less" } }, "end": "\\;", "endCaptures": { "0": { "name": "punctuation.terminator.rule.less" } }, "name": "meta.at-rule.namespace.less", "patterns": [{ "include": "#url-function" }, { "include": "#literal-string" }, { "match": "(-?(?:[[_a-zA-Z][^\\x{00}-\\x{7F}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))(?:[[-\\w][^\\x{00}-\\x{7F}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))*)", "name": "entity.name.constant.namespace-prefix.less" }] }, "at-page": { "captures": { "1": { "name": "keyword.control.at-rule.page.less" }, "2": { "name": "punctuation.definition.keyword.less" }, "3": { "name": "punctuation.definition.entity.less" }, "4": { "name": "entity.other.attribute-name.pseudo-class.less" } }, "match": "\\s*((@)page)\\s*(?:(:)(first|left|right))?\\s*(?=\\{|$)", "name": "meta.at-rule.page.less", "patterns": [{ "include": "#comment-block" }, { "include": "#rule-list" }] }, "at-rules": { "patterns": [{ "include": "#at-charset" }, { "include": "#at-counter-style" }, { "include": "#at-custom-media" }, { "include": "#at-font-face" }, { "include": "#at-media" }, { "include": "#at-import" }, { "include": "#at-keyframes" }, { "include": "#at-namespace" }, { "include": "#at-page" }, { "include": "#at-supports" }, { "include": "#at-viewport" }] }, "at-supports": { "begin": "(?=\\s*@supports\\b)", "end": "(?=\\s*)(\\})", "endCaptures": { "1": { "name": "punctuation.definition.block.end.less" } }, "patterns": [{ "begin": "\\s*((@)supports)", "beginCaptures": { "1": { "name": "keyword.control.at-rule.supports.less" }, "2": { "name": "punctuation.definition.keyword.less" }, "3": { "name": "support.constant.supports.less" } }, "end": "\\s*(?=\\{)", "name": "meta.at-rule.supports.less", "patterns": [{ "include": "#at-supports-operators" }, { "include": "#at-supports-parens" }] }, { "begin": "\\s*(\\{)", "beginCaptures": { "1": { "name": "punctuation.section.property-list.begin.less" } }, "end": "(?=\\})", "patterns": [{ "include": "#rule-list-body" }, { "include": "$self" }] }] }, "at-supports-operators": { "match": "\\b(?:and|or|not)\\b", "name": "keyword.operator.logic.less" }, "at-supports-parens": { "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.group.less", "patterns": [{ "include": "#at-supports-operators" }, { "include": "#at-supports-parens" }, { "include": "#rule-list-body" }] }, "at-viewport": { "begin": "((@(-ms-)?)viewport)", "beginCaptures": { "1": { "name": "keyword.control.at-rule.viewport.less" }, "2": { "name": "punctuation.definition.keyword.less" }, "3": { "name": "support.type.vendor-prefix.less" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.end.less" } }, "name": "meta.at-rule.viewport.less", "patterns": [{ "begin": "\\{", "captures": { "0": { "name": "punctuation.definition.block.begin.less" } }, "end": "(?=\\})", "name": "meta.block.less", "patterns": [{ "include": "#rule-list-body" }] }] }, "attr-function": { "begin": "\\b(attr)(?=\\()", "beginCaptures": { "1": { "name": "support.function.filter.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#qualified-name" }, { "include": "#literal-string" }, { "begin": "(-?(?:[[_a-zA-Z][^\\x{00}-\\x{7F}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))(?:[[-\\w][^\\x{00}-\\x{7F}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))*)", "end": "(?=\\))", "name": "entity.other.attribute-name.less", "patterns": [{ "match": "(?x)\\b((?i:em|ex|ch|rem)|(?i:vw|vh|vmin|vmax)|(?i:cm|mm|q|in|pt|pc|px|fr)|(?i:deg|grad|rad|turn)|(?i:s|ms)|(?i:Hz|kHz)|(?i:dpi|dpcm|dppx))\\b", "name": "keyword.other.unit.less" }, { "include": "#comma-delimiter" }, { "include": "#property-value-constants" }, { "include": "#numeric-values" }] }, { "include": "#color-values" }] }] }, "builtin-functions": { "patterns": [{ "include": "#attr-function" }, { "include": "#calc-function" }, { "include": "#color-functions" }, { "include": "#counter-functions" }, { "include": "#cross-fade-function" }, { "include": "#cubic-bezier-function" }, { "include": "#filter-function" }, { "include": "#format-function" }, { "include": "#gradient-functions" }, { "include": "#grid-repeat-function" }, { "include": "#image-function" }, { "include": "#less-functions" }, { "include": "#local-function" }, { "include": "#minmax-function" }, { "include": "#regexp-function" }, { "include": "#shape-functions" }, { "include": "#steps-function" }, { "include": "#symbols-function" }, { "include": "#transform-functions" }, { "include": "#url-function" }, { "include": "#var-function" }] }, "calc-function": { "begin": "\\b(calc)(?=\\()", "beginCaptures": { "1": { "name": "support.function.calc.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#less-strings" }, { "include": "#var-function" }, { "include": "#calc-function" }, { "include": "#attr-function" }, { "include": "#less-math" }] }] }, "color-adjuster-operators": { "match": "[\\-\\+*](?=\\s+)", "name": "keyword.operator.less" }, "color-functions": { "patterns": [{ "begin": "\\b(rgba?)(?=\\()", "beginCaptures": { "1": { "name": "support.function.color.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#less-strings" }, { "include": "#less-variables" }, { "include": "#comma-delimiter" }, { "include": "#percentage-type" }, { "include": "#number-type" }] }] }, { "begin": "\\b(hs(l|v)a?|hwb)(?=\\()", "beginCaptures": { "1": { "name": "support.function.color.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#less-strings" }, { "include": "#less-variables" }, { "include": "#comma-delimiter" }, { "include": "#angle-type" }, { "include": "#percentage-type" }, { "include": "#number-type" }] }] }, { "include": "#less-color-functions" }] }, "color-values": { "patterns": [{ "include": "#color-functions" }, { "include": "#less-functions" }, { "include": "#less-variables" }, { "match": "\\b(aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow)\\b", "name": "support.constant.color.w3c-standard-color-name.less" }, { "match": "\\b(aliceblue|antiquewhite|aquamarine|azure|beige|bisque|blanchedalmond|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|gainsboro|ghostwhite|gold|goldenrod|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|limegreen|linen|magenta|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|oldlace|olivedrab|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|rebeccapurple|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|thistle|tomato|turquoise|violet|wheat|whitesmoke|yellowgreen)\\b", "name": "support.constant.color.w3c-extended-color-keywords.less" }, { "match": "\\b((?i)currentColor|transparent)\\b", "name": "support.constant.color.w3c-special-color-keyword.less" }, { "captures": { "1": { "name": "punctuation.definition.constant.less" } }, "match": "(#)(\\h{3}|\\h{4}|\\h{6}|\\h{8})\\b", "name": "constant.other.color.rgb-value.less" }] }, "comma-delimiter": { "captures": { "1": { "name": "punctuation.separator.less" } }, "match": "\\s*(,)\\s*" }, "comment-block": { "patterns": [{ "begin": "/\\*", "captures": { "0": { "name": "punctuation.definition.comment.less" } }, "end": "\\*/", "name": "comment.block.less" }, { "include": "#comment-line" }] }, "comment-line": { "captures": { "1": { "name": "punctuation.definition.comment.less" } }, "match": "(//).*$\\n?", "name": "comment.line.double-slash.less" }, "counter-functions": { "patterns": [{ "begin": "\\b(counter)(?=\\()", "beginCaptures": { "1": { "name": "support.function.filter.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#less-strings" }, { "include": "#less-variables" }, { "match": "(?:--(?:[[-\\w][^\\x{00}-\\x{7F}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))+|-?(?:[[_a-zA-Z][^\\x{00}-\\x{7F}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))(?:[[-\\w][^\\x{00}-\\x{7F}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))*)", "name": "entity.other.counter-name.less" }, { "begin": "(?=,)", "end": "(?=\\))", "patterns": [{ "include": "#comma-delimiter" }, { "match": "\\b((?xi:arabic-indic|armenian|bengali|cambodian|circle|cjk-decimal|cjk-earthly-branch|cjk-heavenly-stem|decimal-leading-zero|decimal|devanagari|disclosure-closed|disclosure-open|disc|ethiopic-numeric|georgian|gujarati|gurmukhi|hebrew|hiragana-iroha|hiragana|japanese-formal|japanese-informal|kannada|katakana-iroha|katakana|khmer|korean-hangul-formal|korean-hanja-formal|korean-hanja-informal|lao|lower-alpha|lower-armenian|lower-greek|lower-latin|lower-roman|malayalam|mongolian|myanmar|oriya|persian|simp-chinese-formal|simp-chinese-informal|square|tamil|telugu|thai|tibetan|trad-chinese-formal|trad-chinese-informal|upper-alpha|upper-armenian|upper-latin|upper-roman)|none)\\b", "name": "support.constant.property-value.counter-style.less" }] }] }] }, { "begin": "\\b(counters)(?=\\()", "beginCaptures": { "1": { "name": "support.function.filter.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "match": "(-?(?:[[_a-zA-Z][^\\x{00}-\\x{7F}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))(?:[[-\\w][^\\x{00}-\\x{7F}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))*)", "name": "entity.other.counter-name.less string.unquoted.less" }, { "begin": "(?=,)", "end": "(?=\\))", "patterns": [{ "include": "#less-strings" }, { "include": "#less-variables" }, { "include": "#literal-string" }, { "include": "#comma-delimiter" }, { "match": "\\b((?xi:arabic-indic|armenian|bengali|cambodian|circle|cjk-decimal|cjk-earthly-branch|cjk-heavenly-stem|decimal-leading-zero|decimal|devanagari|disclosure-closed|disclosure-open|disc|ethiopic-numeric|georgian|gujarati|gurmukhi|hebrew|hiragana-iroha|hiragana|japanese-formal|japanese-informal|kannada|katakana-iroha|katakana|khmer|korean-hangul-formal|korean-hanja-formal|korean-hanja-informal|lao|lower-alpha|lower-armenian|lower-greek|lower-latin|lower-roman|malayalam|mongolian|myanmar|oriya|persian|simp-chinese-formal|simp-chinese-informal|square|tamil|telugu|thai|tibetan|trad-chinese-formal|trad-chinese-informal|upper-alpha|upper-armenian|upper-latin|upper-roman)|none)\\b", "name": "support.constant.property-value.counter-style.less" }] }] }] }] }, "cross-fade-function": { "patterns": [{ "begin": "\\b(cross-fade)(?=\\()", "beginCaptures": { "1": { "name": "support.function.image.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#comma-delimiter" }, { "include": "#percentage-type" }, { "include": "#color-values" }, { "include": "#image-type" }, { "include": "#literal-string" }, { "include": "#unquoted-string" }] }] }] }, "cubic-bezier-function": { "begin": "\\b(cubic-bezier)(?=\\()", "beginCaptures": { "0": { "name": "support.function.timing.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#comma-delimiter" }, { "include": "#number-type" }] }] }, "custom-property-name": { "captures": { "1": { "name": "punctuation.definition.custom-property.less" }, "2": { "name": "support.type.custom-property.name.less" } }, "match": "\\s*(--)((?:[[-\\w][^\\x{00}-\\x{7F}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))+)", "name": "support.type.custom-property.less" }, "dimensions": { "patterns": [{ "include": "#angle-type" }, { "include": "#frequency-type" }, { "include": "#length-type" }, { "include": "#resolution-type" }, { "include": "#time-type" }] }, "filter-function": { "begin": "\\b(filter)(?=\\()", "beginCaptures": { "1": { "name": "support.function.filter.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "name": "meta.group.less", "patterns": [{ "include": "#comma-delimiter" }, { "include": "#image-type" }, { "include": "#literal-string" }, { "include": "#filter-functions" }] }] }, "filter-functions": { "patterns": [{ "include": "#less-functions" }, { "begin": "\\b(blur)(?=\\()", "beginCaptures": { "1": { "name": "support.function.filter.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#length-type" }] }] }, { "begin": "\\b(brightness|contrast|grayscale|invert|opacity|saturate|sepia)(?=\\()", "beginCaptures": { "1": { "name": "support.function.filter.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#percentage-type" }, { "include": "#number-type" }, { "include": "#less-functions" }] }] }, { "begin": "\\b(drop-shadow)(?=\\()", "beginCaptures": { "1": { "name": "support.function.filter.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#length-type" }, { "include": "#color-values" }] }] }, { "begin": "\\b(hue-rotate)(?=\\()", "beginCaptures": { "1": { "name": "support.function.filter.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#angle-type" }] }] }] }, "format-function": { "patterns": [{ "begin": "\\b(format)(?=\\()", "beginCaptures": { "0": { "name": "support.function.format.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#literal-string" }] }] }] }, "frequency-type": { "captures": { "1": { "name": "keyword.other.unit.less" } }, "match": "(?i:[-+]?(?:(?:\\d*\\.\\d+(?:[eE](?:[-+]?\\d+))*)|(?:[-+]?\\d+))(Hz|kHz))\\b", "name": "constant.numeric.less" }, "gradient-functions": { "patterns": [{ "begin": "\\b((?:repeating-)?linear-gradient)(?=\\()", "beginCaptures": { "1": { "name": "support.function.gradient.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#less-variables" }, { "include": "#angle-type" }, { "include": "#color-values" }, { "include": "#percentage-type" }, { "include": "#length-type" }, { "include": "#comma-delimiter" }, { "match": "\\bto\\b", "name": "keyword.other.less" }, { "match": "\\b(top|right|bottom|left)\\b", "name": "support.constant.property-value.less" }] }] }, { "begin": "\\b((?:repeating-)?radial-gradient)(?=\\()", "beginCaptures": { "1": { "name": "support.function.gradient.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#less-variables" }, { "include": "#color-values" }, { "include": "#percentage-type" }, { "include": "#length-type" }, { "include": "#comma-delimiter" }, { "match": "\\b(at|circle|ellipse)\\b", "name": "keyword.other.less" }, { "match": "\\b(top|right|bottom|left|center|(farthest|closest)-(corner|side))\\b", "name": "support.constant.property-value.less" }] }] }] }, "grid-repeat-function": { "begin": "\\b(repeat)(?=\\()", "beginCaptures": { "1": { "name": "support.function.grid.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#comma-delimiter" }, { "include": "#var-function" }, { "include": "#length-type" }, { "include": "#percentage-type" }, { "include": "#minmax-function" }, { "include": "#integer-type" }, { "match": "\\b(auto-(fill|fit))\\b", "name": "support.keyword.repetitions.less" }, { "match": "\\b(((max|min)-content)|auto)\\b", "name": "support.constant.property-value.less" }] }] }, "image-function": { "begin": "\\b(image)(?=\\()", "beginCaptures": { "1": { "name": "support.function.image.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#image-type" }, { "include": "#literal-string" }, { "include": "#color-values" }, { "include": "#comma-delimiter" }, { "include": "#unquoted-string" }] }] }, "image-type": { "patterns": [{ "include": "#cross-fade-function" }, { "include": "#gradient-functions" }, { "include": "#image-function" }, { "include": "#url-function" }] }, "integer-type": { "match": "(?:[-+]?\\d+)", "name": "constant.numeric.less" }, "keyframe-name": { "begin": "\\s*(-?(?:[_a-z]|[^\\x{00}-\\x{7F}]|(?:(:?\\\\[0-9a-f]{1,6}(\\r\\n|[\\s\\t\\r\\n\\f])?)|\\\\[^\\r\\n\\f0-9a-f]))(?:[_a-z0-9-]|[^\\x{00}-\\x{7F}]|(?:(:?\\\\[0-9a-f]{1,6}(\\r\\n|[\\t\\r\\n\\f])?)|\\\\[^\\r\\n\\f0-9a-f]))*)?", "beginCaptures": { "1": { "name": "variable.other.constant.animation-name.less" } }, "end": "\\s*(?:(,)|(?=[{;]))", "endCaptures": { "1": { "name": "punctuation.definition.arbitrary-repetition.less" } } }, "length-type": { "captures": { "1": { "name": "keyword.other.unit.less" } }, "match": "0|(?i:[-+]?(?:(?:\\d*\\.\\d+(?:[eE](?:[-+]?\\d+))*)|(?:[-+]?\\d+))(em|ex|ch|rem|vw|vh|vmin|vmax|(c|m)?m|q|in|pt|pc|px|fr))\\b", "name": "constant.numeric.less" }, "less-boolean-function": { "begin": "\\b(boolean)(?=\\()", "beginCaptures": { "1": { "name": "support.function.boolean.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#less-logical-comparisons" }] }] }, "less-color-blend-functions": { "patterns": [{ "begin": "\\b(multiply|screen|overlay|(soft|hard)light|difference|exclusion|negation|average)(?=\\()", "beginCaptures": { "1": { "name": "support.function.color-blend.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#less-variables" }, { "include": "#comma-delimiter" }, { "include": "#color-values" }] }] }] }, "less-color-channel-functions": { "patterns": [{ "begin": "\\b(hue|saturation|lightness|hsv(hue|saturation|value)|red|green|blue|alpha|luma|luminance)(?=\\()", "beginCaptures": { "1": { "name": "support.function.color-definition.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#color-values" }] }] }] }, "less-color-definition-functions": { "patterns": [{ "begin": "\\b(argb)(?=\\()", "beginCaptures": { "1": { "name": "support.function.color-definition.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#less-variables" }, { "include": "#color-values" }] }] }] }, "less-color-functions": { "patterns": [{ "include": "#less-color-blend-functions" }, { "include": "#less-color-channel-functions" }, { "include": "#less-color-definition-functions" }, { "include": "#less-color-operation-functions" }] }, "less-color-operation-functions": { "patterns": [{ "begin": "\\b(fade|shade|tint)(?=\\()", "beginCaptures": { "1": { "name": "support.function.color-operation.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#color-values" }, { "include": "#comma-delimiter" }, { "include": "#percentage-type" }] }] }, { "begin": "\\b(spin)(?=\\()", "beginCaptures": { "1": { "name": "support.function.color-operation.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#color-values" }, { "include": "#comma-delimiter" }, { "include": "#number-type" }] }] }, { "begin": "\\b(((de)?saturate)|((light|dark)en)|(fade(in|out)))(?=\\()", "beginCaptures": { "1": { "name": "support.function.color-operation.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#color-values" }, { "include": "#comma-delimiter" }, { "include": "#percentage-type" }, { "match": "\\brelative\\b", "name": "constant.language.relative.less" }] }] }, { "begin": "\\b(contrast)(?=\\()", "beginCaptures": { "1": { "name": "support.function.color-operation.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#color-values" }, { "include": "#comma-delimiter" }, { "include": "#percentage-type" }] }] }, { "begin": "\\b(greyscale)(?=\\()", "beginCaptures": { "1": { "name": "support.function.color-operation.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#color-values" }] }] }, { "begin": "\\b(mix)(?=\\()", "beginCaptures": { "1": { "name": "support.function.color-operation.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#color-values" }, { "include": "#comma-delimiter" }, { "include": "#less-math" }, { "include": "#percentage-type" }] }] }] }, "less-extend": { "begin": "(:)(extend)(?=\\()", "beginCaptures": { "1": { "name": "punctuation.definition.entity.less" }, "2": { "name": "entity.other.attribute-name.pseudo-class.extend.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "match": "\\ball\\b", "name": "constant.language.all.less" }, { "include": "#selectors" }] }] }, "less-functions": { "patterns": [{ "include": "#less-boolean-function" }, { "include": "#less-color-functions" }, { "include": "#less-if-function" }, { "include": "#less-list-functions" }, { "include": "#less-math-functions" }, { "include": "#less-misc-functions" }, { "include": "#less-string-functions" }, { "include": "#less-type-functions" }] }, "less-if-function": { "begin": "\\b(if)(?=\\()", "beginCaptures": { "1": { "name": "support.function.if.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#less-mixin-guards" }, { "include": "#comma-delimiter" }, { "include": "#property-values" }] }] }, "less-list-functions": { "patterns": [{ "begin": "\\b(length)(?=\\()\\b", "beginCaptures": { "1": { "name": "support.function.length.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#property-values" }, { "include": "#comma-delimiter" }] }] }, { "begin": "\\b(extract)(?=\\()\\b", "beginCaptures": { "1": { "name": "support.function.extract.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#property-values" }, { "include": "#comma-delimiter" }, { "include": "#integer-type" }] }] }, { "begin": "\\b(range)(?=\\()\\b", "beginCaptures": { "1": { "name": "support.function.range.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#property-values" }, { "include": "#comma-delimiter" }, { "include": "#integer-type" }] }] }] }, "less-logical-comparisons": { "patterns": [{ "captures": { "1": { "name": "keyword.operator.logical.less" } }, "match": "\\s*(=|((<|>)=?))\\s*" }, { "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.group.less", "patterns": [{ "include": "#less-logical-comparisons" }] }, { "match": "\\btrue|false\\b", "name": "constant.language.less" }, { "match": ",", "name": "punctuation.separator.less" }, { "include": "#property-values" }, { "include": "#selectors" }, { "include": "#unquoted-string" }] }, "less-math": { "patterns": [{ "match": "[-\\+\\*\\/]", "name": "keyword.operator.arithmetic.less" }, { "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.group.less", "patterns": [{ "include": "#less-math" }] }, { "include": "#numeric-values" }, { "include": "#less-variables" }] }, "less-math-functions": { "patterns": [{ "begin": "\\b(ceil|floor|percentage|round|sqrt|abs|a?(sin|cos|tan))(?=\\()", "beginCaptures": { "1": { "name": "support.function.math.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#less-variables" }, { "include": "#numeric-values" }] }] }, { "captures": { "2": { "name": "support.function.math.less" }, "3": { "name": "punctuation.definition.group.begin.less" }, "4": { "name": "punctuation.definition.group.end.less" } }, "match": "((pi)(\\()(\\)))", "name": "meta.function-call.less" }, { "begin": "\\b(pow|m(od|in|ax))(?=\\()", "beginCaptures": { "1": { "name": "support.function.math.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#less-variables" }, { "include": "#numeric-values" }, { "include": "#comma-delimiter" }] }] }] }, "less-misc-functions": { "patterns": [{ "begin": "\\b(color)(?=\\()", "beginCaptures": { "1": { "name": "support.function.color.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#literal-string" }] }] }, { "begin": "\\b(image-(size|width|height))(?=\\()", "beginCaptures": { "1": { "name": "support.function.image.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#literal-string" }, { "include": "#unquoted-string" }] }] }, { "begin": "\\b(convert|unit)(?=\\()", "beginCaptures": { "1": { "name": "support.function.convert.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#less-variables" }, { "include": "#dimensions" }, { "include": "#numeric-values" }, { "include": "#literal-string" }, { "include": "#comma-delimiter" }, { "match": "((c|m)?m|in|p(t|c|x)|m?s|g?rad|deg|turn|%|r?em|ex|ch)", "name": "keyword.other.unit.less" }] }] }, { "begin": "\\b(data-uri)(?=\\()", "beginCaptures": { "1": { "name": "support.function.data-uri.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#less-variables" }, { "include": "#literal-string" }, { "captures": { "1": { "name": "punctuation.separator.less" } }, "match": "\\s*(?:(,))" }] }] }, { "captures": { "2": { "name": "punctuation.definition.group.begin.less" }, "3": { "name": "punctuation.definition.group.end.less" } }, "match": "\\b(default(\\()(\\)))\\b", "name": "support.function.default.less" }, { "begin": "\\b(get-unit)(?=\\()", "beginCaptures": { "1": { "name": "support.function.get-unit.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#dimensions" }] }] }, { "begin": "\\b(svg-gradient)(?=\\()", "beginCaptures": { "1": { "name": "support.function.svg-gradient.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#angle-type" }, { "include": "#comma-delimiter" }, { "include": "#color-values" }, { "include": "#percentage-type" }, { "include": "#length-type" }, { "match": "\\bto\\b", "name": "keyword.other.less" }, { "match": "\\b(top|right|bottom|left|center)\\b", "name": "support.constant.property-value.less" }, { "match": "\\b(at|circle|ellipse)\\b", "name": "keyword.other.less" }] }] }] }, "less-mixin-guards": { "patterns": [{ "begin": "\\s*(and|not|or)?\\s*(?=\\()", "beginCaptures": { "1": { "name": "keyword.operator.logical.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "name": "meta.group.less", "patterns": [{ "include": "#less-variable-comparison" }, { "captures": { "1": { "name": "meta.group.less" }, "2": { "name": "punctuation.definition.group.begin.less" }, "3": { "name": "punctuation.definition.group.end.less" } }, "match": "default((\\()(\\)))", "name": "support.function.default.less" }, { "include": "#property-values" }, { "include": "#less-logical-comparisons" }, { "include": "$self" }] }] }] }, "less-namespace-accessors": { "patterns": [{ "begin": "(?=\\s*when\\b)", "end": "\\s*(?:(,)|(?=[{;]))", "endCaptures": { "1": { "name": "punctuation.definition.block.end.less" } }, "name": "meta.conditional.guarded-namespace.less", "patterns": [{ "captures": { "1": { "name": "keyword.control.conditional.less" }, "2": { "name": "punctuation.definition.keyword.less" } }, "match": "\\s*(when)(?=.*?)" }, { "include": "#less-mixin-guards" }, { "include": "#comma-delimiter" }, { "begin": "\\s*(\\{)", "beginCaptures": { "1": { "name": "punctuation.section.property-list.begin.less" } }, "end": "(?=\\})", "name": "meta.block.less", "patterns": [{ "include": "#rule-list-body" }] }, { "include": "#selectors" }] }, { "begin": "(\\()", "beginCaptures": { "1": { "name": "punctuation.definition.group.begin.less" } }, "end": "(\\))", "endCaptures": { "1": { "name": "punctuation.definition.group.end.less" }, "2": { "name": "punctuation.terminator.rule.less" } }, "name": "meta.group.less", "patterns": [{ "include": "#less-variable-assignment" }, { "include": "#comma-delimiter" }, { "captures": { "1": { "name": "punctuation.terminator.rule.less" } }, "match": "\\s*(;)|(?=[})])" }, { "include": "#property-values" }, { "include": "#rule-list-body" }] }] }, "less-number-units": { "patterns": [{ "match": "\\b((c|m)?m|in|p(t|c)|m?s|g?rad|deg|turn)\\b", "name": "keyword.other.unit.less" }, { "match": "\\b(r?em|ex|ch|vw|vh|vmin|vmax|cm|mm|q|in|pt|pc|px|fr|s|ms|Hz|kHz|dpi|dpcm|dppx|deg|grad|rad|turn)\\b" }] }, "less-string-functions": { "patterns": [{ "begin": "\\b(e(scape)?)(?=\\()\\b", "beginCaptures": { "1": { "name": "support.function.escape.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#less-variables" }, { "include": "#comma-delimiter" }, { "include": "#literal-string" }, { "include": "#unquoted-string" }] }] }, { "begin": "\\s*(%)(?=\\()\\s*", "beginCaptures": { "1": { "name": "support.function.format.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#less-variables" }, { "include": "#comma-delimiter" }, { "include": "#literal-string" }, { "include": "#property-values" }] }] }, { "begin": "\\b(replace)(?=\\()\\b", "beginCaptures": { "1": { "name": "support.function.replace.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#less-variables" }, { "include": "#comma-delimiter" }, { "include": "#literal-string" }, { "include": "#property-values" }] }] }] }, "less-strings": { "patterns": [{ "begin": `(~)('|")`, "beginCaptures": { "1": { "name": "constant.character.escape.less" }, "2": { "name": "punctuation.definition.string.begin.less" } }, "contentName": "markup.raw.inline.less", "end": `('|")|(\\n)`, "endCaptures": { "1": { "name": "punctuation.definition.string.end.less" }, "2": { "name": "invalid.illegal.newline.less" } }, "name": "string.quoted.other.less", "patterns": [{ "include": "#string-content" }] }] }, "less-type-functions": { "patterns": [{ "begin": "\\b(is(number|string|color|keyword|url|pixel|em|percentage|ruleset))(?=\\()", "beginCaptures": { "1": { "name": "support.function.type.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#property-values" }] }] }, { "begin": "\\b(isunit)(?=\\()", "beginCaptures": { "1": { "name": "support.function.type.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#property-values" }, { "include": "#comma-delimiter" }, { "match": "(?x)\\b((?i:em|ex|ch|rem)|(?i:vw|vh|vmin|vmax)|(?i:cm|mm|q|in|pt|pc|px|fr)|(?i:deg|grad|rad|turn)|(?i:s|ms)|(?i:Hz|kHz)|(?i:dpi|dpcm|dppx))\\b", "name": "keyword.other.unit.less" }] }] }, { "begin": "\\b(isdefined)(?=\\()", "beginCaptures": { "1": { "name": "support.function.type.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#less-variables" }] }] }] }, "less-variable-assignment": { "patterns": [{ "begin": "(@)(-?(?:[[-\\w][^\\x{00}-\\x{7F}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))(?:[[-\\w][^\\x{00}-\\x{7F}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))*)", "beginCaptures": { "0": { "name": "variable.other.readwrite.less" }, "1": { "name": "punctuation.definition.variable.less" }, "2": { "name": "support.other.variable.less" } }, "end": "\\s*(;|(\\.{3})|(?=\\)))", "endCaptures": { "1": { "name": "punctuation.terminator.rule.less" }, "2": { "name": "keyword.operator.spread.less" } }, "name": "meta.property-value.less", "patterns": [{ "captures": { "1": { "name": "punctuation.separator.key-value.less" }, "4": { "name": "meta.property-value.less" } }, "match": "(((\\+_?)?):)([\\s\\t]*)" }, { "include": "#property-values" }, { "include": "#comma-delimiter" }, { "include": "#property-list" }, { "include": "#unquoted-string" }] }] }, "less-variable-comparison": { "patterns": [{ "begin": "(@{1,2})([-]?([_a-z]|[^\\x{00}-\\x{7F}]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))(?:[[-\\w][^\\x{00}-\\x{7F}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))*)", "beginCaptures": { "0": { "name": "variable.other.readwrite.less" }, "1": { "name": "punctuation.definition.variable.less" }, "2": { "name": "support.other.variable.less" } }, "end": "\\s*(?=\\))", "endCaptures": { "1": { "name": "punctuation.terminator.rule.less" } }, "patterns": [{ "captures": { "1": { "name": "keyword.operator.logical.less" } }, "match": "\\s*(=|((<|>)=?))\\s*" }, { "match": "\\btrue\\b", "name": "constant.language.less" }, { "include": "#property-values" }, { "include": "#selectors" }, { "include": "#unquoted-string" }, { "match": ",", "name": "punctuation.separator.less" }] }] }, "less-variable-interpolation": { "captures": { "1": { "name": "punctuation.definition.variable.less" }, "2": { "name": "punctuation.definition.expression.less" }, "3": { "name": "support.other.variable.less" }, "4": { "name": "punctuation.definition.expression.less" } }, "match": "(@)(\\{)([-\\w]+)(\\})", "name": "variable.other.readwrite.less" }, "less-variables": { "captures": { "1": { "name": "punctuation.definition.variable.less" }, "2": { "name": "support.other.variable.less" } }, "match": "\\s*(@@?)([-\\w]+)", "name": "variable.other.readwrite.less" }, "literal-string": { "patterns": [{ "begin": "'", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.less" } }, "end": "(')|(\\n)", "endCaptures": { "1": { "name": "punctuation.definition.string.end.less" }, "2": { "name": "invalid.illegal.newline.less" } }, "name": "string.quoted.single.less", "patterns": [{ "include": "#string-content" }] }, { "begin": '"', "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.less" } }, "end": '(")|(\\n)', "endCaptures": { "1": { "name": "punctuation.definition.string.end.less" }, "2": { "name": "invalid.illegal.newline.less" } }, "name": "string.quoted.double.less", "patterns": [{ "include": "#string-content" }] }, { "include": "#less-strings" }] }, "local-function": { "begin": "\\b(local)(?=\\()", "beginCaptures": { "0": { "name": "support.function.font-face.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#unquoted-string" }] }] }, "media-query": { "begin": "\\s*(only|not)?\\s*(all|aural|braille|embossed|handheld|print|projection|screen|tty|tv)?", "beginCaptures": { "1": { "name": "keyword.operator.logic.media.less" }, "2": { "name": "support.constant.media.less" } }, "end": "\\s*(?:(,)|(?=[{;]))", "endCaptures": { "1": { "name": "punctuation.definition.arbitrary-repetition.less" } }, "patterns": [{ "include": "#less-variables" }, { "include": "#custom-property-name" }, { "begin": "\\s*(and)?\\s*(\\()\\s*", "beginCaptures": { "1": { "name": "keyword.operator.logic.media.less" }, "2": { "name": "punctuation.definition.group.begin.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.group.less", "patterns": [{ "begin": "((-webkit-|-o-)?((min|max)-)?(-moz-)?(((device-)?(height|width|aspect-ratio|pixel-ratio))|(color(-index)?)|monochrome|resolution))|grid|scan|orientation\\s*(?=[:)])", "beginCaptures": { "0": { "name": "support.type.property-name.media.less" }, "2": { "name": "support.type.vendor-prefix.less" }, "5": { "name": "support.type.vendor-prefix.less" } }, "end": "(((\\+_?)?):)|(?=\\))", "endCaptures": { "1": { "name": "punctuation.separator.key-value.less" } } }, { "match": "\\b(portrait|landscape|progressive|interlace)", "name": "support.constant.property-value.less" }, { "captures": { "1": { "name": "constant.numeric.less" }, "2": { "name": "keyword.operator.arithmetic.less" }, "3": { "name": "constant.numeric.less" } }, "match": "\\s*(\\d+)(/)(\\d+)" }, { "include": "#less-math" }] }] }, "media-query-list": { "begin": "\\s*(?=[^{;])", "end": "\\s*(?=[{;])", "patterns": [{ "include": "#media-query" }] }, "minmax-function": { "begin": "\\b(minmax)(?=\\()", "beginCaptures": { "1": { "name": "support.function.grid.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#less-variables" }, { "include": "#length-type" }, { "include": "#comma-delimiter" }, { "match": "\\b(max-content|min-content)\\b", "name": "support.constant.property-value.less" }] }] }, "number-type": { "match": "[-+]?(?:(?:\\d*\\.\\d+(?:[eE](?:[-+]?\\d+))*)|(?:[-+]?\\d+))", "name": "constant.numeric.less" }, "numeric-values": { "patterns": [{ "include": "#dimensions" }, { "include": "#percentage-type" }, { "include": "#number-type" }] }, "percentage-type": { "captures": { "1": { "name": "keyword.other.unit.less" } }, "match": "[-+]?(?:(?:\\d*\\.\\d+(?:[eE](?:[-+]?\\d+))*)|(?:[-+]?\\d+))(%)", "name": "constant.numeric.less" }, "property-list": { "patterns": [{ "begin": "(?=(?=[^;]*)\\{)", "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.end.less" } }, "patterns": [{ "include": "#rule-list" }] }] }, "property-value-constants": { "patterns": [{ "match": "(?x)\\b(\n    absolute|active|add\n  |all(-(petite|small)-caps|-scroll)?\n  |alpha(betic)?\n  |alternate(-reverse)?\n  |always|annotation|antialiased|at\n  |auto(hiding-scrollbar)?\n  |avoid(-column|-page|-region)?\n  |background(-color|-image|-position|-size)?\n  |backwards|balance|baseline|below|bevel|bicubic|bidi-override|blink\n  |block(-line-height)?\n  |blur\n  |bold(er)?\n  |border(-bottom|-left|-right|-top)?-(color|radius|width|style)\n  |border-(bottom|top)-(left|right)-radius\n  |border-image(-outset|-repeat|-slice|-source|-width)?\n  |border(-bottom|-left|-right|-top|-collapse|-spacing|-box)?\n  |both|bottom\n  |box(-shadow)?\n  |break-(all|word)\n  |brightness\n  |butt(on)?\n  |capitalize\n  |cent(er|ral)\n  |char(acter-variant)?\n  |cjk-ideographic|clip|clone|close-quote\n  |closest-(corner|side)\n  |col-resize|collapse\n  |color(-stop|-burn|-dodge)?\n  |column((-count|-gap|-reverse|-rule(-color|-width)?|-width)|s)?\n  |common-ligatures|condensed|consider-shifts|contain\n  |content(-box|s)?\n  |contextual|contrast|cover\n  |crisp(-e|E)dges\n  |crop\n  |cross(hair)?\n  |da(rken|shed)\n  |default|dense|diagonal-fractions|difference|disabled\n  |discretionary-ligatures|disregard-shifts\n  |distribute(-all-lines|-letter|-space)?\n  |dotted|double|drop-shadow\n  |(nwse|nesw|ns|ew|sw|se|nw|ne|w|s|e|n)-resize\n  |ease(-in-out|-in|-out)?\n  |element|ellipsis|embed|end|EndColorStr|evenodd\n  |exclu(de(-ruby)?|sion)\n  |expanded\n  |(extra|semi|ultra)-(condensed|expanded)\n  |farthest-(corner|side)?\n  |fill(-box|-opacity)?\n  |filter|fixed|flat\n  |flex((-basis|-end|-grow|-shrink|-start)|box)?\n  |flip|flood-color\n  |font(-size(-adjust)?|-stretch|-weight)?\n  |forwards\n  |from(-image)?\n  |full-width|geometricPrecision|glyphs|gradient|grayscale\n  |grid(-height)?\n  |groove|hand|hanging|hard-light|height|help|hidden|hide\n  |historical-(forms|ligatures)\n  |horizontal(-tb)?\n  |hue\n  |ideograph(-alpha|-numeric|-parenthesis|-space|ic)\n  |inactive|include-ruby|infinite|inherit|initial\n  |inline(-block|-box|-flex(box)?|-line-height|-table)?\n  |inset|inside\n  |inter(-ideograph|-word|sect)\n  |invert|isolat(e|ion)|italic\n  |jis(04|78|83|90)\n  |justify(-all)?\n  |keep-all\n  |large[r]?\n  |last|layout|left|letter-spacing\n  |light(e[nr]|ing-color)\n  |line(-edge|-height|-through)?\n  |linear(-gradient|RGB)?\n  |lining-nums|list-item|local|loose|lowercase|lr-tb|ltr\n  |lumin(osity|ance)|manual\n  |manipulation\n  |margin(-bottom|-box|-left|-right|-top)?\n  |marker(-offset|s)?\n  |mathematical\n  |max-(content|height|lines|size|width)\n  |medium|middle\n  |min-(content|height|width)\n  |miter|mixed|move|multiply|newspaper\n  |no-(change|clip|(close|open)-quote|(common|discretionary|historical)-ligatures|contextual|drop|repeat)\n  |none|nonzero|normal|not-allowed|nowrap|oblique\n  |offset(-after|-before|-end|-start)?\n  |oldstyle-nums|opacity|open-quote\n  |optimize(Legibility|Precision|Quality|Speed)\n  |order|ordinal|ornaments\n  |outline(-color|-offset|-width)?\n  |outset|outside|over(line|-edge|lay)\n  |padding(-bottom|-box|-left|-right|-top|-box)?\n  |page|painted|paused\n  |pan-(x|left|right|y|up|down)\n  |perspective-origin\n  |petite-caps|pixelated|pointer\n  |pinch-zoom\n  |pre(-line|-wrap)?\n  |preserve-3d\n  |progid:DXImageTransform.Microsoft.(Alpha|Blur|dropshadow|gradient|Shadow)\n  |progress\n  |proportional-(nums|width)\n  |radial-gradient|recto|region|relative\n  |repeat(-[xy])?\n  |repeating-(linear|radial)-gradient\n  |replaced|reset-size|reverse|ridge|right\n  |round\n  |row(-resize|-reverse)?\n  |rtl|ruby|running|saturat(e|ion)|screen\n  |scroll(-position|bar)?\n  |separate|sepia\n  |scale-down\n  |shape-(image-threshold|margin|outside)\n  |show\n  |sideways(-lr|-rl)?\n  |simplified\n  |size\n  |slashed-zero|slice\n  |small(-caps|er)?\n  |smooth|snap|solid|soft-light\n  |space(-around|-between)?\n  |span|sRGB\n  |stack(ed-fractions)?\n  |start(ColorStr)?\n  |static\n  |step-(end|start)\n  |sticky\n  |stop-(color|opacity)\n  |stretch|strict\n  |stroke(-box|-dash(array|offset)|-miterlimit|-opacity|-width)?\n  |style(set)?\n  |stylistic\n  |sub(grid|pixel-antialiased|tract)?\n  |super|swash\n  |table(-caption|-cell|(-column|-footer|-header|-row)-group|-column|-row)?\n  |tabular-nums|tb-rl\n  |text((-bottom|-(decoration|emphasis)-color|-indent|-(over|under)-edge|-shadow|-size(-adjust)?|-top)|field)?\n  |thi(ck|n)\n  |titling-ca(ps|se)\n  |to[p]?\n  |touch|traditional\n  |transform(-origin)?\n  |under(-edge|line)?\n  |unicase|unset|uppercase|upright\n  |use-(glyph-orientation|script)\n  |verso\n  |vertical(-align|-ideographic|-lr|-rl|-text)?\n  |view-box\n  |viewport-fill(-opacity)?\n  |visibility\n  |visible(Fill|Painted|Stroke)?\n  |wait|wavy|weight|whitespace|(device-)?width|word-spacing\n  |wrap(-reverse)?\n  |x{1,2}-(large|small)\n  |z-index|zero\n  |zoom(-in|-out)?\n  |((?xi:arabic-indic|armenian|bengali|cambodian|circle|cjk-decimal|cjk-earthly-branch|cjk-heavenly-stem|decimal-leading-zero|decimal|devanagari|disclosure-closed|disclosure-open|disc|ethiopic-numeric|georgian|gujarati|gurmukhi|hebrew|hiragana-iroha|hiragana|japanese-formal|japanese-informal|kannada|katakana-iroha|katakana|khmer|korean-hangul-formal|korean-hanja-formal|korean-hanja-informal|lao|lower-alpha|lower-armenian|lower-greek|lower-latin|lower-roman|malayalam|mongolian|myanmar|oriya|persian|simp-chinese-formal|simp-chinese-informal|square|tamil|telugu|thai|tibetan|trad-chinese-formal|trad-chinese-informal|upper-alpha|upper-armenian|upper-latin|upper-roman)))\\b", "name": "support.constant.property-value.less" }, { "match": "\\b(?i:sans-serif|serif|monospace|fantasy|cursive)\\b(?=\\s*[;,\\n}])", "name": "support.constant.font-name.less" }] }, "property-values": { "patterns": [{ "include": "#comment-block" }, { "include": "#vendor-prefix" }, { "include": "#builtin-functions" }, { "include": "#color-functions" }, { "include": "#less-math" }, { "include": "#less-functions" }, { "include": "#less-variables" }, { "include": "#unicode-range" }, { "include": "#numeric-values" }, { "include": "#color-values" }, { "include": "#property-value-constants" }, { "include": "#literal-string" }, { "captures": { "1": { "name": "punctuation.separator.less" } }, "match": "(\\!)\\s*important", "name": "keyword.other.important.less" }] }, "pseudo-classes": { "patterns": [{ "begin": "(:)(dir|lang)(?=\\()", "captures": { "1": { "name": "punctuation.definition.entity.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "entity.other.attribute-name.pseudo-class.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#unquoted-string" }] }] }, { "begin": "(:)(not)(?=\\()", "captures": { "1": { "name": "punctuation.definition.entity.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "entity.other.attribute-name.pseudo-class.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#selectors" }] }] }, { "begin": "(:)(nth(-last)?-(child|of-type))(?=\\()", "captures": { "1": { "name": "punctuation.definition.entity.less" }, "2": { "name": "entity.other.attribute-name.pseudo-class.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "name": "meta.group.less", "patterns": [{ "match": "\\b(even|odd)\\b", "name": "keyword.other.pseudo-class.less" }, { "captures": { "1": { "name": "keyword.other.unit.less" } }, "match": "(?:[-+]?(?:\\d+)?(n)(\\s*[-+]\\s*\\d+)?|[-+]?\\s*\\d+)", "name": "constant.numeric.less" }, { "include": "#less-math" }, { "include": "#less-strings" }, { "include": "#less-variable-interpolation" }] }] }, { "begin": "(:)(host-context)(?=\\()", "captures": { "1": { "name": "punctuation.definition.entity.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "entity.other.attribute-name.pseudo-class.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#selectors" }] }] }, { "captures": { "1": { "name": "punctuation.definition.entity.less" }, "2": { "name": "entity.other.attribute-name.pseudo-class.less" } }, "match": "(:)(active|any|checked|default|disabled|empty|enabled|first(-(child|of-type))?|fullscreen|focus|host|hover|indeterminate|in-range|invalid|last-(child|of-type)|left|link|only-(child|of-type)|optional|out-of-range|read-(only|write)|required|right|root|scope|target|valid|visited)", "name": "meta.function-call.less" }] }, "pseudo-elements": { "patterns": [{ "begin": "(::)(slotted)(?=\\()", "captures": { "1": { "name": "punctuation.definition.entity.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "entity.other.attribute-name.pseudo-class.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#selectors" }] }] }, { "captures": { "1": { "name": "punctuation.definition.entity.less" }, "2": { "name": "punctuation.definition.entity.less" }, "3": { "name": "support.type.vendor-prefix.less" } }, "match": "(?:(:{1,2})(?:before|after|first-line|first-letter)|(::)(-(?:moz|ms|webkit)-)?(?:(-?(?:[[-\\w][^\\x{00}-\\x{7F}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))(?:[[-\\w][^\\x{00}-\\x{7F}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))*)))\\b", "name": "entity.other.attribute-name.pseudo-element.less" }] }, "qualified-name": { "captures": { "1": { "name": "entity.name.constant.less" }, "2": { "name": "entity.name.namespace.wildcard.less" }, "3": { "name": "punctuation.separator.namespace.less" } }, "match": "(?:(-?(?:[[-\\w][^\\x{00}-\\x{7F}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))(?:[[_a-zA-Z][^\\x{00}-\\x{7F}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))*)|(\\*))?([|])(?!=)" }, "regexp-function": { "begin": "\\b(regexp)(?=\\()", "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "support.function.regexp.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "name": "meta.function-call.less", "patterns": [{ "include": "#literal-string" }] }] }, "resolution-type": { "captures": { "1": { "name": "keyword.other.unit.less" } }, "match": "(?i:[-+]?(?:(?:\\d*\\.\\d+(?:[eE](?:[-+]?\\d+))*)|(?:[-+]?\\d+))(dpi|dpcm|dppx))\\b", "name": "constant.numeric.less" }, "rule-list": { "patterns": [{ "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.block.begin.less" } }, "end": "(?=\\s*\\})", "name": "meta.property-list.less", "patterns": [{ "captures": { "1": { "name": "punctuation.terminator.rule.less" } }, "match": "\\s*(;)|(?=[})])" }, { "include": "#rule-list-body" }, { "include": "#less-extend" }] }] }, "rule-list-body": { "patterns": [{ "include": "#comment-block" }, { "include": "#comment-line" }, { "include": "#at-rules" }, { "include": "#less-variable-assignment" }, { "include": "#less-variable-interpolation" }, { "begin": "(?=[-a-z])", "end": "$|(?![-a-z])", "patterns": [{ "include": "#vendor-prefix" }, { "include": "#custom-property-name" }, { "include": "#filter-function" }, { "captures": { "1": { "name": "keyword.other.custom-property.prefix.less" }, "2": { "name": "support.type.custom-property.name.less" } }, "match": "\\b(var-)(-?(?:[[-\\w][^\\x{00}-\\x{9f}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))(?:[[_a-zA-Z][^\\x{00}-\\x{9f}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))*)(?=\\s)", "name": "invalid.deprecated.custom-property.less" }, { "begin": "\\bfont(-family)?(?!-)\\b", "beginCaptures": { "0": { "name": "support.type.property-name.less" } }, "end": "\\s*(;)|(?=[})])", "endCaptures": { "1": { "name": "punctuation.terminator.rule.less" } }, "name": "meta.property-name.less", "patterns": [{ "captures": { "1": { "name": "punctuation.separator.key-value.less" }, "4": { "name": "meta.property-value.less" } }, "match": "(((\\+_?)?):)([\\s\\t]*)" }, { "include": "#property-values" }, { "match": "-?(?:[[_a-zA-Z][^\\x{00}-\\x{9f}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))(?:[[-\\w][^\\x{00}-\\x{9f}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))*(\\s+-?(?:[[_a-zA-Z][^\\x{00}-\\x{9f}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))(?:[[-\\w][^\\x{00}-\\x{9f}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))*)*", "name": "string.unquoted.less" }, { "match": ",", "name": "punctuation.separator.less" }] }, { "begin": "\\banimation(-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function))?\\b", "beginCaptures": { "0": { "name": "support.type.property-name.less" } }, "end": "\\s*(;)|(?=[})])", "endCaptures": { "1": { "name": "punctuation.terminator.rule.less" } }, "patterns": [{ "begin": "(((\\+_?)?):)(?=[\\s\\t]*)", "beginCaptures": { "1": { "name": "punctuation.separator.key-value.less" } }, "captures": { "1": { "name": "punctuation.definition.arbitrary-repetition.less" } }, "contentName": "meta.property-value.less", "end": "(?=\\s*(;)|(?=[})]))", "patterns": [{ "match": "\\b(linear|ease(-in)?(-out)?|step-(start|end)|none|forwards|backwards|both|normal|alternate(-reverse)?|reverse|running|paused)\\b", "name": "support.constant.property-value.less" }, { "include": "#cubic-bezier-function" }, { "include": "#steps-function" }, { "include": "#time-type" }, { "include": "#number-type" }, { "match": "-?(?:[_a-zA-Z]|[^\\x{00}-\\x{7F}]|(?:(:?\\\\[0-9a-f]{1,6}(\\r\\n|[\\s\\t\\r\\n\\f])?)|\\\\[^\\r\\n\\f0-9a-f]))(?:[-_a-zA-Z0-9]|[^\\x{00}-\\x{7F}]|(?:(:?\\\\[0-9a-f]{1,6}(\\r\\n|[\\t\\r\\n\\f])?)|\\\\[^\\r\\n\\f0-9a-f]))*", "name": "variable.other.constant.animation-name.less" }, { "include": "#literal-string" }, { "include": "#property-values" }, { "match": "\\s*(?:(,))" }] }] }, { "begin": "\\b(transition(-(property|duration|delay|timing-function))?)\\b", "beginCaptures": { "0": { "name": "meta.property-name.less" }, "1": { "name": "support.type.property-name.less" } }, "end": "\\s*(;)|(?=[})])", "endCaptures": { "1": { "name": "punctuation.terminator.rule.less" } }, "patterns": [{ "captures": { "1": { "name": "punctuation.separator.key-value.less" }, "4": { "name": "meta.property-value.less" } }, "match": "(((\\+_?)?):)([\\s\\t]*)" }, { "include": "#time-type" }, { "include": "#property-values" }, { "include": "#cubic-bezier-function" }, { "include": "#steps-function" }, { "captures": { "1": { "name": "punctuation.definition.arbitrary-repetition.less" } }, "match": "\\s*(?:(,))" }] }, { "begin": "\\bfilter\\b", "beginCaptures": { "0": { "name": "support.type.property-name.less" } }, "end": "\\s*(;)|(?=[})])", "endCaptures": { "1": { "name": "punctuation.terminator.rule.less" } }, "name": "meta.property-name.less", "patterns": [{ "captures": { "1": { "name": "punctuation.separator.key-value.less" }, "4": { "name": "meta.property-value.less" } }, "match": "(((\\+_?)?):)([\\s\\t]*)" }, { "match": "\\b(inherit|initial|unset|none)\\b", "name": "meta.property-value.less" }, { "include": "#filter-functions" }] }, { "begin": "\\bwill-change\\b", "beginCaptures": { "0": { "name": "support.type.property-name.less" } }, "end": "\\s*(;)|(?=[})])", "endCaptures": { "1": { "name": "punctuation.terminator.rule.less" } }, "name": "meta.property-name.less", "patterns": [{ "captures": { "1": { "name": "punctuation.separator.key-value.less" }, "4": { "name": "meta.property-value.less" } }, "match": "(((\\+_?)?):)([\\s\\t]*)" }, { "match": "unset|initial|inherit|will-change|auto|scroll-position|contents", "name": "invalid.illegal.property-value.less" }, { "match": "-?(?:[[-\\w][^\\x{00}-\\x{9f}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))(?:[[_a-zA-Z][^\\x{00}-\\x{9f}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))*", "name": "support.constant.property-value.less" }, { "captures": { "1": { "name": "punctuation.definition.arbitrary-repetition.less" } }, "match": "\\s*(?:(,))" }] }, { "begin": "\\bcounter-(increment|(re)?set)\\b", "beginCaptures": { "0": { "name": "support.type.property-name.less" } }, "end": "\\s*(;)|(?=[})])", "endCaptures": { "1": { "name": "punctuation.terminator.rule.less" } }, "name": "meta.property-name.less", "patterns": [{ "captures": { "1": { "name": "punctuation.separator.key-value.less" }, "4": { "name": "meta.property-value.less" } }, "match": "(((\\+_?)?):)([\\s\\t]*)" }, { "match": "-?(?:[[-\\w][^\\x{00}-\\x{9f}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))(?:[[_a-zA-Z][^\\x{00}-\\x{9f}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))*", "name": "entity.name.constant.counter-name.less" }, { "include": "#integer-type" }, { "match": "unset|initial|inherit|auto", "name": "invalid.illegal.property-value.less" }] }, { "match": "(?x)\\b( accent-height | align-content | align-items | align-self | alignment-baseline | all | animation-timing-function | animation-play-state | animation-name | animation-iteration-count | animation-fill-mode | animation-duration | animation-direction | animation-delay | animation | appearance | ascent | azimuth | backface-visibility | background-size | background-repeat-y | background-repeat-x | background-repeat | background-position-y | background-position-x | background-position | background-origin | background-image | background-color | background-clip | background-blend-mode | background-attachment | background | baseline-shift | begin | bias | blend-mode | border-((top|right|bottom|left)-)?(width|style|color) | border-(top|bottom)-(right|left)-radius | border-image-(width|source|slice|repeat|outset) | border-(top|right|bottom|left|collapse|image|radius|spacing) | border | bottom | box-(align|decoration-break|direction|flex|ordinal-group|orient|pack|shadow|sizing) | break-(after|before|inside) | caption-side | clear | clip-path | clip-rule | clip | color(-(interpolation(-filters)?|profile|rendering))? | columns | column-(break-before|count|fill|gap|(rule(-(color|style|width))?)|span|width) | contain | content | counter-(increment|reset) | cursor | (c|d|f)(x|y) | direction | display | divisor | dominant-baseline | dur | elevation | empty-cells | enable-background | end | fallback | fill(-(opacity|rule))? | filter | flex(-(align|basis|direction|flow|grow|item-align|line-pack|negative|order|pack|positive|preferred-size|shrink|wrap))? | float | flood-(color|opacity) | font-display | font-family | font-feature-settings | font-kerning | font-language-override | font-size(-adjust)? | font-smoothing | font-stretch | font-style | font-synthesis | font-variant(-(alternates|caps|east-asian|ligatures|numeric|position))? | font-weight | font | fr | glyph-orientation-(horizontal|vertical) | grid-(area|gap) | grid-auto-(columns|flow|rows) | grid-(column|row)(-(end|gap|start))? | grid-template(-(areas|columns|rows))? | height | hyphens | image-(orientation|rendering|resolution) | isolation | justify-content | kerning | left | letter-spacing | lighting-color | line-(box-contain|break|clamp|height) | list-style(-(image|position|type))? | margin(-(bottom|left|right|top))? | marker(-(end|mid|start))? | mask(-(clip||composite|image|origin|position|repeat|size|type))? | (max|min)-(height|width) | mix-blend-mode | nbsp-mode | negative | object-(fit|position) | opacity | operator | order | orphans | outline(-(color|offset|style|width))? | overflow(-(scrolling|wrap|x|y))? | pad(ding(-(bottom|left|right|top))?)? | page(-break-(after|before|inside))? | paint-order | pause(-(after|before))? | perspective(-origin(-(x|y))?)? | pitch(-range)? | pointer-events | position | prefix | quotes | range | resize | right | rotate | scale | scroll-behavior | shape-(image-threshold|margin|outside|rendering) | size | speak(-as)? | src | stop-(color|opacity) | stroke(-(dash(array|offset)|line(cap|join)|miterlimit|opacity|width))? | suffix | symbols | system | tab-size | table-layout | tap-highlight-color | text-align(-last)? | text-decoration(-(color|line|style))? | text-emphasis(-(color|position|style))? | text-(anchor|fill-color|height|indent|justify|orientation|overflow|rendering|shadow|transform|underline-position) | top | touch-action | transform(-origin(-(x|y))?) | transform(-style)? | transition(-(delay|duration|property|timing-function))? | translate | unicode-(bidi|range) | user-(drag|select) | vertical-align | visibility | white-space | widows | width | will-change | word-(break|spacing|wrap) | writing-mode | z-index | zoom )\\b", "name": "support.type.property-name.less" }, { "include": "$self" }] }, { "begin": "\\b(((\\+_?)?):)([\\s\\t]*)", "captures": { "1": { "name": "punctuation.separator.key-value.less" }, "4": { "name": "meta.property-value.less" } }, "contentName": "meta.property-value.less", "end": "\\s*(;)|(?=[})])", "endCaptures": { "1": { "name": "punctuation.terminator.rule.less" } }, "patterns": [{ "include": "#property-values" }] }, { "include": "$self" }] }, "selector": { "patterns": [{ "begin": "(?=[>~+/\\.*#a-zA-Z\\[&]|(\\:{1,2}[^\\s])|@\\{)", "contentName": "meta.selector.less", "end": "(?=@(?!\\{)|[{;])", "patterns": [{ "include": "#comment-line" }, { "include": "#selectors" }, { "include": "#less-namespace-accessors" }, { "include": "#less-variable-interpolation" }, { "captures": { "1": { "name": "punctuation.separator.less" } }, "match": "(\\!)\\s*important", "name": "keyword.other.important.less" }] }] }, "selectors": { "patterns": [{ "match": "\\b([a-z](?:(?:[-_a-z0-9\\x{00B7}]|\\\\\\.|[[\\x{00C0}-\\x{00D6}][\\x{00D8}-\\x{00F6}][\\x{00F8}-\\x{02FF}][\\x{0300}-\\x{037D}][\\x{037F}-\\x{1FFF}][\\x{200C}-\\x{200D}][\\x{203F}-\\x{2040}][\\x{2070}-\\x{218F}][\\x{2C00}-\\x{2FEF}][\\x{3001}-\\x{D7FF}][\\x{F900}-\\x{FDCF}][\\x{FDF0}-\\x{FFFD}][\\x{10000}-\\x{EFFFF}]]))*-(?:(?:[-_a-z0-9\\x{00B7}]|\\\\\\.|[[\\x{00C0}-\\x{00D6}][\\x{00D8}-\\x{00F6}][\\x{00F8}-\\x{02FF}][\\x{0300}-\\x{037D}][\\x{037F}-\\x{1FFF}][\\x{200C}-\\x{200D}][\\x{203F}-\\x{2040}][\\x{2070}-\\x{218F}][\\x{2C00}-\\x{2FEF}][\\x{3001}-\\x{D7FF}][\\x{F900}-\\x{FDCF}][\\x{FDF0}-\\x{FFFD}][\\x{10000}-\\x{EFFFF}]]))*)\\b", "name": "entity.name.tag.custom.less" }, { "match": "(?x)\\b( a | abbr | acronym | address | applet | area | article | aside | audio | b | base | basefont | bdi | bdo | big | blockquote | body | br | button | canvas | caption | circle | cite | clipPath | code | col | colgroup | content | data | dataList | dd | defs | del | details | dfn | dialog | dir | div | dl | dt | element | ellipse | em | embed | eventsource | fieldset | figcaption | figure | filter | footer | foreignObject | form | frame | frameset | g | glyph | glyphRef | h1 | h2 | h3 | h4 | h5 | h6 | head | header | hgroup | hr | html | i | iframe | image | img | input | ins | isindex | kbd | keygen | label | legend | li | line | linearGradient | link | main | map | mark | marker | mask | menu | meta | meter | nav | noframes | noscript | object | ol | optgroup | option | output | p | param | path | pattern | picture | polygon | polyline | pre | progress | q | radialGradient | rect | rp | ruby | rt | rtc | s | samp | script | section | select | shadow | small | source | span | stop | strike | strong | style | sub | summary | sup | svg | switch | symbol | table | tbody | td | template | textarea | textPath | tfoot | th | thead | time | title | tr | track | tref | tspan | tt | u | ul | use | var | video | wbr | xmp )\\b", "name": "entity.name.tag.less" }, { "begin": "(\\.)", "beginCaptures": { "1": { "name": "punctuation.definition.entity.less" } }, "end": "(?![-\\w]|[^\\x{00}-\\x{9f}]|\\\\([A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9])|(\\@(?=\\{)))", "name": "entity.other.attribute-name.class.less", "patterns": [{ "include": "#less-variable-interpolation" }] }, { "begin": "(#)", "beginCaptures": { "1": { "name": "punctuation.definition.entity.less" } }, "end": "(?![-\\w]|[^\\x{00}-\\x{9f}]|\\\\([A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9])|(\\@(?=\\{)))", "name": "entity.other.attribute-name.id.less", "patterns": [{ "include": "#less-variable-interpolation" }] }, { "begin": "(&)", "beginCaptures": { "1": { "name": "punctuation.definition.entity.less" } }, "contentName": "entity.other.attribute-name.parent.less", "end": "(?![-\\w]|[^\\x{00}-\\x{9f}]|\\\\([A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9])|(\\@(?=\\{)))", "name": "entity.other.attribute-name.parent.less", "patterns": [{ "include": "#less-variable-interpolation" }, { "include": "#selectors" }] }, { "include": "#pseudo-elements" }, { "include": "#pseudo-classes" }, { "include": "#less-extend" }, { "match": "(?!\\+_?:)(?:>{1,3}|[~+])(?![>~+;}])", "name": "punctuation.separator.combinator.less" }, { "match": "((?:>{1,3}|[~+])){2,}", "name": "invalid.illegal.combinator.less" }, { "match": "\\/deep\\/", "name": "invalid.illegal.combinator.less" }, { "begin": "\\[", "captures": { "0": { "name": "punctuation.definition.entity.less" } }, "end": "\\]", "name": "meta.attribute-selector.less", "patterns": [{ "include": "#less-variable-interpolation" }, { "include": "#qualified-name" }, { "match": "(-?(?:[[_a-zA-Z][^\\x{00}-\\x{7F}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))(?:[[-\\w][^\\x{00}-\\x{7F}]]|(?:\\\\\\h{1,6}[\\s\\t\\n\\f]?|\\\\[^\\n\\f\\h]))*)", "name": "entity.other.attribute-name.less" }, { "begin": "\\s*([~*|^$]?=)\\s*", "captures": { "1": { "name": "keyword.operator.attribute-selector.less" } }, "end": "(?=(\\s|\\]))", "patterns": [{ "include": "#less-variable-interpolation" }, { "match": `[^\\s\\]\\['"]`, "name": "string.unquoted.less" }, { "include": "#literal-string" }, { "captures": { "1": { "name": "keyword.other.less" } }, "match": "(?:\\s+([iI]))?" }, { "match": "\\]", "name": "punctuation.definition.entity.less" }] }] }, { "captures": { "1": { "name": "punctuation.definition.arbitrary-repetition.less" } }, "match": "\\s*(?:(,))" }, { "match": "\\*", "name": "entity.name.tag.wildcard.less" }] }, "shape-functions": { "patterns": [{ "begin": "\\b(rect)(?=\\()", "beginCaptures": { "0": { "name": "support.function.shape.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "match": "\\bauto\\b", "name": "support.constant.property-value.less" }, { "include": "#length-type" }, { "include": "#comma-delimiter" }] }] }, { "begin": "\\b(inset)(?=\\()", "beginCaptures": { "0": { "name": "support.function.shape.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "match": "\\bround\\b", "name": "keyword.other.less" }, { "include": "#length-type" }, { "include": "#percentage-type" }] }] }, { "begin": "\\b(circle|ellipse)(?=\\()", "beginCaptures": { "0": { "name": "support.function.shape.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "match": "\\bat\\b", "name": "keyword.other.less" }, { "match": "\\b(top|right|bottom|left|center|closest-side|farthest-side)\\b", "name": "support.constant.property-value.less" }, { "include": "#length-type" }, { "include": "#percentage-type" }] }] }, { "begin": "\\b(polygon)(?=\\()", "beginCaptures": { "0": { "name": "support.function.shape.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "match": "\\b(nonzero|evenodd)\\b", "name": "support.constant.property-value.less" }, { "include": "#length-type" }, { "include": "#percentage-type" }] }] }] }, "steps-function": { "begin": "\\b(steps)(?=\\()", "beginCaptures": { "0": { "name": "support.function.timing.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#comma-delimiter" }, { "include": "#integer-type" }, { "match": "(end|middle|start)", "name": "support.keyword.timing-direction.less" }] }] }, "string-content": { "patterns": [{ "include": "#less-variable-interpolation" }, { "match": "\\\\\\s*\\n", "name": "constant.character.escape.newline.less" }, { "match": "\\\\(\\h{1,6}|.)", "name": "constant.character.escape.less" }] }, "symbols-function": { "begin": "\\b(symbols)(?=\\()", "beginCaptures": { "1": { "name": "support.function.counter.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "match": "\\b(cyclic|numeric|alphabetic|symbolic|fixed)\\b", "name": "support.constant.symbol-type.less" }, { "include": "#comma-delimiter" }, { "include": "#literal-string" }, { "include": "#image-type" }] }] }, "time-type": { "captures": { "1": { "name": "keyword.other.unit.less" } }, "match": "(?i:[-+]?(?:(?:\\d*\\.\\d+(?:[eE](?:[-+]?\\d+))*)|(?:[-+]?\\d+))(s|ms))\\b", "name": "constant.numeric.less" }, "transform-functions": { "patterns": [{ "begin": "\\b(matrix3d|scale3d|matrix|scale)(?=\\()", "beginCaptures": { "0": { "name": "support.function.transform.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#comma-delimiter" }, { "include": "#number-type" }, { "include": "#less-variables" }, { "include": "#var-function" }] }] }, { "begin": "\\b(translate(3d)?)(?=\\()", "beginCaptures": { "0": { "name": "support.function.transform.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#comma-delimiter" }, { "include": "#percentage-type" }, { "include": "#length-type" }, { "include": "#number-type" }, { "include": "#less-variables" }, { "include": "#var-function" }] }] }, { "begin": "\\b(translate[XY])(?=\\()", "beginCaptures": { "0": { "name": "support.function.transform.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#percentage-type" }, { "include": "#length-type" }, { "include": "#number-type" }, { "include": "#less-variables" }, { "include": "#var-function" }] }] }, { "begin": "\\b(rotate[XYZ]?|skew[XY])(?=\\()", "beginCaptures": { "0": { "name": "support.function.transform.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#angle-type" }, { "include": "#less-variables" }, { "include": "#calc-function" }, { "include": "#var-function" }] }] }, { "begin": "\\b(skew)(?=\\()", "beginCaptures": { "0": { "name": "support.function.transform.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#comma-delimiter" }, { "include": "#angle-type" }, { "include": "#less-variables" }, { "include": "#calc-function" }, { "include": "#var-function" }] }] }, { "begin": "\\b(translateZ|perspective)(?=\\()", "beginCaptures": { "0": { "name": "support.function.transform.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#length-type" }, { "include": "#less-variables" }, { "include": "#calc-function" }, { "include": "#var-function" }] }] }, { "begin": "\\b(rotate3d)(?=\\()", "beginCaptures": { "0": { "name": "support.function.transform.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#comma-delimiter" }, { "include": "#angle-type" }, { "include": "#number-type" }, { "include": "#less-variables" }, { "include": "#calc-function" }, { "include": "#var-function" }] }] }, { "begin": "\\b(scale[XYZ])(?=\\()", "beginCaptures": { "0": { "name": "support.function.transform.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#comma-delimiter" }, { "include": "#number-type" }, { "include": "#less-variables" }, { "include": "#calc-function" }, { "include": "#var-function" }] }] }] }, "unicode-range": { "captures": { "1": { "name": "support.constant.unicode-range.prefix.less" }, "2": { "name": "constant.codepoint-range.less" }, "3": { "name": "punctuation.section.range.less" } }, "match": "(?i)(u\\+)([0-9a-f?]{1,6}(?:(-)[0-9a-f]{1,6})?)", "name": "support.unicode-range.less" }, "unquoted-string": { "match": `[^\\s'"]`, "name": "string.unquoted.less" }, "url-function": { "begin": "\\b(url)(?=\\()", "beginCaptures": { "1": { "name": "support.function.url.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#less-variables" }, { "include": "#literal-string" }, { "include": "#unquoted-string" }, { "include": "#var-function" }] }] }, "var-function": { "patterns": [{ "begin": "\\b(var)(?=\\()", "beginCaptures": { "1": { "name": "support.function.var.less" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.end.less" } }, "name": "meta.function-call.less", "patterns": [{ "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.group.begin.less" } }, "end": "(?=\\))", "patterns": [{ "include": "#comma-delimiter" }, { "include": "#custom-property-name" }, { "include": "#less-variables" }] }] }] }, "vendor-prefix": { "match": "-(?:webkit|moz(-osx)?|ms|o)-", "name": "support.type.vendor-prefix.less" } }, "scopeName": "source.css.less" });
var less = [
  lang$e
];
var lang$d = Object.freeze({ "displayName": "TypeScript", "name": "typescript", "patterns": [{ "include": "#directives" }, { "include": "#statements" }, { "include": "#shebang" }], "repository": { "access-modifier": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(abstract|declare|override|public|protected|private|readonly|static)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "storage.modifier.ts" }, "after-operator-block-as-object-literal": { "begin": "(?<!\\+\\+|--)(?<=[:=(,\\[?+!>]|^await|[^\\._$[:alnum:]]await|^return|[^\\._$[:alnum:]]return|^yield|[^\\._$[:alnum:]]yield|^throw|[^\\._$[:alnum:]]throw|^in|[^\\._$[:alnum:]]in|^of|[^\\._$[:alnum:]]of|^typeof|[^\\._$[:alnum:]]typeof|&&|\\|\\||\\*)\\s*(\\{)", "beginCaptures": { "1": { "name": "punctuation.definition.block.ts" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.ts" } }, "name": "meta.objectliteral.ts", "patterns": [{ "include": "#object-member" }] }, "array-binding-pattern": { "begin": "(?:(\\.\\.\\.)\\s*)?(\\[)", "beginCaptures": { "1": { "name": "keyword.operator.rest.ts" }, "2": { "name": "punctuation.definition.binding-pattern.array.ts" } }, "end": "\\]", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.array.ts" } }, "patterns": [{ "include": "#binding-element" }, { "include": "#punctuation-comma" }] }, "array-binding-pattern-const": { "begin": "(?:(\\.\\.\\.)\\s*)?(\\[)", "beginCaptures": { "1": { "name": "keyword.operator.rest.ts" }, "2": { "name": "punctuation.definition.binding-pattern.array.ts" } }, "end": "\\]", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.array.ts" } }, "patterns": [{ "include": "#binding-element-const" }, { "include": "#punctuation-comma" }] }, "array-literal": { "begin": "\\s*(\\[)", "beginCaptures": { "1": { "name": "meta.brace.square.ts" } }, "end": "\\]", "endCaptures": { "0": { "name": "meta.brace.square.ts" } }, "name": "meta.array.literal.ts", "patterns": [{ "include": "#expression" }, { "include": "#punctuation-comma" }] }, "arrow-function": { "patterns": [{ "captures": { "1": { "name": "storage.modifier.async.ts" }, "2": { "name": "variable.parameter.ts" } }, "match": "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(\\basync)\\s+)?([_$[:alpha:]][_$[:alnum:]]*)\\s*(?==>)", "name": "meta.arrow.ts" }, { "begin": "(?x) (?:\n  (?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(\\basync)\n)? ((?<![})!\\]])\\s*\n  (?=\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  )\n)", "beginCaptures": { "1": { "name": "storage.modifier.async.ts" } }, "end": "(?==>|\\{|(^\\s*(export|function|class|interface|let|var|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|const|import|enum|namespace|module|type|abstract|declare)\\s+))", "name": "meta.arrow.ts", "patterns": [{ "include": "#comment" }, { "include": "#type-parameters" }, { "include": "#function-parameters" }, { "include": "#arrow-return-type" }, { "include": "#possibly-arrow-return-type" }] }, { "begin": "=>", "beginCaptures": { "0": { "name": "storage.type.function.arrow.ts" } }, "end": "((?<=\\}|\\S)(?<!=>)|((?!\\{)(?=\\S)))(?!\\/[\\/\\*])", "name": "meta.arrow.ts", "patterns": [{ "include": "#single-line-comment-consuming-line-ending" }, { "include": "#decl-block" }, { "include": "#expression" }] }] }, "arrow-return-type": { "begin": "(?<=\\))\\s*(:)", "beginCaptures": { "1": { "name": "keyword.operator.type.annotation.ts" } }, "end": "(?==>|\\{|(^\\s*(export|function|class|interface|let|var|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|const|import|enum|namespace|module|type|abstract|declare)\\s+))", "name": "meta.return.type.arrow.ts", "patterns": [{ "include": "#arrow-return-type-body" }] }, "arrow-return-type-body": { "patterns": [{ "begin": "(?<=[:])(?=\\s*\\{)", "end": "(?<=\\})", "patterns": [{ "include": "#type-object" }] }, { "include": "#type-predicate-operator" }, { "include": "#type" }] }, "async-modifier": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(async)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "storage.modifier.async.ts" }, "binding-element": { "patterns": [{ "include": "#comment" }, { "include": "#string" }, { "include": "#numeric-literal" }, { "include": "#regex" }, { "include": "#object-binding-pattern" }, { "include": "#array-binding-pattern" }, { "include": "#destructuring-variable-rest" }, { "include": "#variable-initializer" }] }, "binding-element-const": { "patterns": [{ "include": "#comment" }, { "include": "#string" }, { "include": "#numeric-literal" }, { "include": "#regex" }, { "include": "#object-binding-pattern-const" }, { "include": "#array-binding-pattern-const" }, { "include": "#destructuring-variable-rest-const" }, { "include": "#variable-initializer" }] }, "boolean-literal": { "patterns": [{ "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))true(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "constant.language.boolean.true.ts" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))false(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "constant.language.boolean.false.ts" }] }, "brackets": { "patterns": [{ "begin": "{", "end": "}|(?=\\*/)", "patterns": [{ "include": "#brackets" }] }, { "begin": "\\[", "end": "\\]|(?=\\*/)", "patterns": [{ "include": "#brackets" }] }] }, "cast": { "patterns": [{ "captures": { "1": { "name": "meta.brace.angle.ts" }, "2": { "name": "storage.modifier.ts" }, "3": { "name": "meta.brace.angle.ts" } }, "match": "\\s*(<)\\s*(const)\\s*(>)", "name": "cast.expr.ts" }, { "begin": "(?:(?<!\\+\\+|--)(?<=^return|[^\\._$[:alnum:]]return|^throw|[^\\._$[:alnum:]]throw|^yield|[^\\._$[:alnum:]]yield|^await|[^\\._$[:alnum:]]await|^default|[^\\._$[:alnum:]]default|[=(,:>*?\\&\\|\\^]|[^_$[:alnum:]](?:\\+\\+|\\-\\-)|[^\\+]\\+|[^\\-]\\-))\\s*(<)(?!<?\\=)(?!\\s*$)", "beginCaptures": { "1": { "name": "meta.brace.angle.ts" } }, "end": "(\\>)", "endCaptures": { "1": { "name": "meta.brace.angle.ts" } }, "name": "cast.expr.ts", "patterns": [{ "include": "#type" }] }, { "begin": "(?:(?<=^))\\s*(<)(?=[_$[:alpha:]][_$[:alnum:]]*\\s*>)", "beginCaptures": { "1": { "name": "meta.brace.angle.ts" } }, "end": "(\\>)", "endCaptures": { "1": { "name": "meta.brace.angle.ts" } }, "name": "cast.expr.ts", "patterns": [{ "include": "#type" }] }] }, "class-declaration": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(?:(abstract)\\s+)?\\b(class)\\b(?=\\s+|/[/*])", "beginCaptures": { "1": { "name": "keyword.control.export.ts" }, "2": { "name": "storage.modifier.ts" }, "3": { "name": "storage.modifier.ts" }, "4": { "name": "storage.type.class.ts" } }, "end": "(?<=\\})", "name": "meta.class.ts", "patterns": [{ "include": "#class-declaration-or-expression-patterns" }] }, "class-declaration-or-expression-patterns": { "patterns": [{ "include": "#comment" }, { "include": "#class-or-interface-heritage" }, { "captures": { "0": { "name": "entity.name.type.class.ts" } }, "match": "[_$[:alpha:]][_$[:alnum:]]*" }, { "include": "#type-parameters" }, { "include": "#class-or-interface-body" }] }, "class-expression": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(abstract)\\s+)?(class)\\b(?=\\s+|[<{]|\\/[\\/*])", "beginCaptures": { "1": { "name": "storage.modifier.ts" }, "2": { "name": "storage.type.class.ts" } }, "end": "(?<=\\})", "name": "meta.class.ts", "patterns": [{ "include": "#class-declaration-or-expression-patterns" }] }, "class-or-interface-body": { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.block.ts" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.ts" } }, "patterns": [{ "include": "#comment" }, { "include": "#decorator" }, { "begin": "(?<=:)\\s*", "end": "(?=\\s|[;),}\\]:\\-\\+]|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "patterns": [{ "include": "#expression" }] }, { "include": "#method-declaration" }, { "include": "#indexer-declaration" }, { "include": "#field-declaration" }, { "include": "#string" }, { "include": "#type-annotation" }, { "include": "#variable-initializer" }, { "include": "#access-modifier" }, { "include": "#property-accessor" }, { "include": "#async-modifier" }, { "include": "#after-operator-block-as-object-literal" }, { "include": "#decl-block" }, { "include": "#expression" }, { "include": "#punctuation-comma" }, { "include": "#punctuation-semicolon" }] }, "class-or-interface-heritage": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(extends|implements)\\b)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "1": { "name": "storage.modifier.ts" } }, "end": "(?=\\{)", "patterns": [{ "include": "#comment" }, { "include": "#class-or-interface-heritage" }, { "include": "#type-parameters" }, { "include": "#expressionWithoutIdentifiers" }, { "captures": { "1": { "name": "entity.name.type.module.ts" }, "2": { "name": "punctuation.accessor.ts" }, "3": { "name": "punctuation.accessor.optional.ts" } }, "match": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))(?=\\s*[_$[:alpha:]][_$[:alnum:]]*(\\s*\\??\\.\\s*[_$[:alpha:]][_$[:alnum:]]*)*\\s*)" }, { "captures": { "1": { "name": "entity.other.inherited-class.ts" } }, "match": "([_$[:alpha:]][_$[:alnum:]]*)" }, { "include": "#expressionPunctuations" }] }, "comment": { "patterns": [{ "begin": "/\\*\\*(?!/)", "beginCaptures": { "0": { "name": "punctuation.definition.comment.ts" } }, "end": "\\*/", "endCaptures": { "0": { "name": "punctuation.definition.comment.ts" } }, "name": "comment.block.documentation.ts", "patterns": [{ "include": "#docblock" }] }, { "begin": "(/\\*)(?:\\s*((@)internal)(?=\\s|(\\*/)))?", "beginCaptures": { "1": { "name": "punctuation.definition.comment.ts" }, "2": { "name": "storage.type.internaldeclaration.ts" }, "3": { "name": "punctuation.decorator.internaldeclaration.ts" } }, "end": "\\*/", "endCaptures": { "0": { "name": "punctuation.definition.comment.ts" } }, "name": "comment.block.ts" }, { "begin": "(^[ \\t]+)?((//)(?:\\s*((@)internal)(?=\\s|$))?)", "beginCaptures": { "1": { "name": "punctuation.whitespace.comment.leading.ts" }, "2": { "name": "comment.line.double-slash.ts" }, "3": { "name": "punctuation.definition.comment.ts" }, "4": { "name": "storage.type.internaldeclaration.ts" }, "5": { "name": "punctuation.decorator.internaldeclaration.ts" } }, "contentName": "comment.line.double-slash.ts", "end": "(?=$)" }] }, "control-statement": { "patterns": [{ "include": "#switch-statement" }, { "include": "#for-loop" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(catch|finally|throw|try)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.control.trycatch.ts" }, { "captures": { "1": { "name": "keyword.control.loop.ts" }, "2": { "name": "entity.name.label.ts" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(break|continue|goto)\\s+([_$[:alpha:]][_$[:alnum:]]*)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(break|continue|do|goto|while)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.control.loop.ts" }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(return)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "0": { "name": "keyword.control.flow.ts" } }, "end": "(?=[;}]|$|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "patterns": [{ "include": "#expression" }] }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(case|default|switch)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.control.switch.ts" }, { "include": "#if-statement" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(else|if)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.control.conditional.ts" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(with)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.control.with.ts" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(package)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.control.ts" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(debugger)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.other.debugger.ts" }] }, "decl-block": { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.block.ts" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.ts" } }, "name": "meta.block.ts", "patterns": [{ "include": "#statements" }] }, "declaration": { "patterns": [{ "include": "#decorator" }, { "include": "#var-expr" }, { "include": "#function-declaration" }, { "include": "#class-declaration" }, { "include": "#interface-declaration" }, { "include": "#enum-declaration" }, { "include": "#namespace-declaration" }, { "include": "#type-alias-declaration" }, { "include": "#import-equals-declaration" }, { "include": "#import-declaration" }, { "include": "#export-declaration" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(declare|export)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "storage.modifier.ts" }] }, "decorator": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))\\@", "beginCaptures": { "0": { "name": "punctuation.decorator.ts" } }, "end": "(?=\\s)", "name": "meta.decorator.ts", "patterns": [{ "include": "#expression" }] }, "destructuring-const": { "patterns": [{ "begin": "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\{)", "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))", "name": "meta.object-binding-pattern-variable.ts", "patterns": [{ "include": "#object-binding-pattern-const" }, { "include": "#type-annotation" }, { "include": "#comment" }] }, { "begin": "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\[)", "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))", "name": "meta.array-binding-pattern-variable.ts", "patterns": [{ "include": "#array-binding-pattern-const" }, { "include": "#type-annotation" }, { "include": "#comment" }] }] }, "destructuring-parameter": { "patterns": [{ "begin": "(?<!=|:)\\s*(?:(\\.\\.\\.)\\s*)?(\\{)", "beginCaptures": { "1": { "name": "keyword.operator.rest.ts" }, "2": { "name": "punctuation.definition.binding-pattern.object.ts" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.object.ts" } }, "name": "meta.parameter.object-binding-pattern.ts", "patterns": [{ "include": "#parameter-object-binding-element" }] }, { "begin": "(?<!=|:)\\s*(?:(\\.\\.\\.)\\s*)?(\\[)", "beginCaptures": { "1": { "name": "keyword.operator.rest.ts" }, "2": { "name": "punctuation.definition.binding-pattern.array.ts" } }, "end": "\\]", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.array.ts" } }, "name": "meta.paramter.array-binding-pattern.ts", "patterns": [{ "include": "#parameter-binding-element" }, { "include": "#punctuation-comma" }] }] }, "destructuring-parameter-rest": { "captures": { "1": { "name": "keyword.operator.rest.ts" }, "2": { "name": "variable.parameter.ts" } }, "match": "(?:(\\.\\.\\.)\\s*)?([_$[:alpha:]][_$[:alnum:]]*)" }, "destructuring-variable": { "patterns": [{ "begin": "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\{)", "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))", "name": "meta.object-binding-pattern-variable.ts", "patterns": [{ "include": "#object-binding-pattern" }, { "include": "#type-annotation" }, { "include": "#comment" }] }, { "begin": "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\[)", "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))", "name": "meta.array-binding-pattern-variable.ts", "patterns": [{ "include": "#array-binding-pattern" }, { "include": "#type-annotation" }, { "include": "#comment" }] }] }, "destructuring-variable-rest": { "captures": { "1": { "name": "keyword.operator.rest.ts" }, "2": { "name": "meta.definition.variable.ts variable.other.readwrite.ts" } }, "match": "(?:(\\.\\.\\.)\\s*)?([_$[:alpha:]][_$[:alnum:]]*)" }, "destructuring-variable-rest-const": { "captures": { "1": { "name": "keyword.operator.rest.ts" }, "2": { "name": "meta.definition.variable.ts variable.other.constant.ts" } }, "match": "(?:(\\.\\.\\.)\\s*)?([_$[:alpha:]][_$[:alnum:]]*)" }, "directives": { "begin": "^(///)\\s*(?=<(reference|amd-dependency|amd-module)(\\s+(path|types|no-default-lib|lib|name|resolution-mode)\\s*=\\s*((\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)))+\\s*/>\\s*$)", "beginCaptures": { "1": { "name": "punctuation.definition.comment.ts" } }, "end": "(?=$)", "name": "comment.line.triple-slash.directive.ts", "patterns": [{ "begin": "(<)(reference|amd-dependency|amd-module)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.directive.ts" }, "2": { "name": "entity.name.tag.directive.ts" } }, "end": "/>", "endCaptures": { "0": { "name": "punctuation.definition.tag.directive.ts" } }, "name": "meta.tag.ts", "patterns": [{ "match": "path|types|no-default-lib|lib|name|resolution-mode", "name": "entity.other.attribute-name.directive.ts" }, { "match": "=", "name": "keyword.operator.assignment.ts" }, { "include": "#string" }] }] }, "docblock": { "patterns": [{ "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "constant.language.access-type.jsdoc" } }, "match": "(?x)\n((@)(?:access|api))\n\\s+\n(private|protected|public)\n\\b" }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "entity.name.type.instance.jsdoc" }, "4": { "name": "punctuation.definition.bracket.angle.begin.jsdoc" }, "5": { "name": "constant.other.email.link.underline.jsdoc" }, "6": { "name": "punctuation.definition.bracket.angle.end.jsdoc" } }, "match": "(?x)\n((@)author)\n\\s+\n(\n  [^@\\s<>*/]\n  (?:[^@<>*/]|\\*[^/])*\n)\n(?:\n  \\s*\n  (<)\n  ([^>\\s]+)\n  (>)\n)?" }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "entity.name.type.instance.jsdoc" }, "4": { "name": "keyword.operator.control.jsdoc" }, "5": { "name": "entity.name.type.instance.jsdoc" } }, "match": "(?x)\n((@)borrows) \\s+\n((?:[^@\\s*/]|\\*[^/])+)    # <that namepath>\n\\s+ (as) \\s+              # as\n((?:[^@\\s*/]|\\*[^/])+)    # <this namepath>" }, { "begin": "((@)example)\\s+", "beginCaptures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" } }, "end": "(?=@|\\*/)", "name": "meta.example.jsdoc", "patterns": [{ "match": "^\\s\\*\\s+" }, { "begin": "\\G(<)caption(>)", "beginCaptures": { "0": { "name": "entity.name.tag.inline.jsdoc" }, "1": { "name": "punctuation.definition.bracket.angle.begin.jsdoc" }, "2": { "name": "punctuation.definition.bracket.angle.end.jsdoc" } }, "contentName": "constant.other.description.jsdoc", "end": "(</)caption(>)|(?=\\*/)", "endCaptures": { "0": { "name": "entity.name.tag.inline.jsdoc" }, "1": { "name": "punctuation.definition.bracket.angle.begin.jsdoc" }, "2": { "name": "punctuation.definition.bracket.angle.end.jsdoc" } } }, { "captures": { "0": { "name": "source.embedded.ts" } }, "match": "[^\\s@*](?:[^*]|\\*[^/])*" }] }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "constant.language.symbol-type.jsdoc" } }, "match": "(?x) ((@)kind) \\s+ (class|constant|event|external|file|function|member|mixin|module|namespace|typedef) \\b" }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "variable.other.link.underline.jsdoc" }, "4": { "name": "entity.name.type.instance.jsdoc" } }, "match": "(?x)\n((@)see)\n\\s+\n(?:\n  # URL\n  (\n    (?=https?://)\n    (?:[^\\s*]|\\*[^/])+\n  )\n  |\n  # JSDoc namepath\n  (\n    (?!\n      # Avoid matching bare URIs (also acceptable as links)\n      https?://\n      |\n      # Avoid matching {@inline tags}; we match those below\n      (?:\\[[^\\[\\]]*\\])? # Possible description [preceding]{@tag}\n      {@(?:link|linkcode|linkplain|tutorial)\\b\n    )\n    # Matched namepath\n    (?:[^@\\s*/]|\\*[^/])+\n  )\n)" }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "variable.other.jsdoc" } }, "match": "(?x)\n((@)template)\n\\s+\n# One or more valid identifiers\n(\n  [A-Za-z_$]         # First character: non-numeric word character\n  [\\w$.\\[\\]]*        # Rest of identifier\n  (?:                # Possible list of additional identifiers\n    \\s* , \\s*\n    [A-Za-z_$]\n    [\\w$.\\[\\]]*\n  )*\n)" }, { "begin": "(?x)((@)template)\\s+(?={)", "beginCaptures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" } }, "end": "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])", "patterns": [{ "include": "#jsdoctype" }, { "match": "([A-Za-z_$][\\w$.\\[\\]]*)", "name": "variable.other.jsdoc" }] }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "variable.other.jsdoc" } }, "match": "(?x)\n(\n  (@)\n  (?:arg|argument|const|constant|member|namespace|param|var)\n)\n\\s+\n(\n  [A-Za-z_$]\n  [\\w$.\\[\\]]*\n)" }, { "begin": "((@)typedef)\\s+(?={)", "beginCaptures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" } }, "end": "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])", "patterns": [{ "include": "#jsdoctype" }, { "match": "(?:[^@\\s*/]|\\*[^/])+", "name": "entity.name.type.instance.jsdoc" }] }, { "begin": "((@)(?:arg|argument|const|constant|member|namespace|param|prop|property|var))\\s+(?={)", "beginCaptures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" } }, "end": "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])", "patterns": [{ "include": "#jsdoctype" }, { "match": "([A-Za-z_$][\\w$.\\[\\]]*)", "name": "variable.other.jsdoc" }, { "captures": { "1": { "name": "punctuation.definition.optional-value.begin.bracket.square.jsdoc" }, "2": { "name": "keyword.operator.assignment.jsdoc" }, "3": { "name": "source.embedded.ts" }, "4": { "name": "punctuation.definition.optional-value.end.bracket.square.jsdoc" }, "5": { "name": "invalid.illegal.syntax.jsdoc" } }, "match": `(?x)
(\\[)\\s*
[\\w$]+
(?:
  (?:\\[\\])?                                        # Foo[ ].bar properties within an array
  \\.                                                # Foo.Bar namespaced parameter
  [\\w$]+
)*
(?:
  \\s*
  (=)                                                # [foo=bar] Default parameter value
  \\s*
  (
    # The inner regexes are to stop the match early at */ and to not stop at escaped quotes
    (?>
      "(?:(?:\\*(?!/))|(?:\\\\(?!"))|[^*\\\\])*?" |                      # [foo="bar"] Double-quoted
      '(?:(?:\\*(?!/))|(?:\\\\(?!'))|[^*\\\\])*?' |                      # [foo='bar'] Single-quoted
      \\[ (?:(?:\\*(?!/))|[^*])*? \\] |                                # [foo=[1,2]] Array literal
      (?:(?:\\*(?!/))|\\s(?!\\s*\\])|\\[.*?(?:\\]|(?=\\*/))|[^*\\s\\[\\]])*   # Everything else
    )*
  )
)?
\\s*(?:(\\])((?:[^*\\s]|\\*[^\\s/])+)?|(?=\\*/))`, "name": "variable.other.jsdoc" }] }, { "begin": "(?x)\n(\n  (@)\n  (?:define|enum|exception|export|extends|lends|implements|modifies\n  |namespace|private|protected|returns?|satisfies|suppress|this|throws|type\n  |yields?)\n)\n\\s+(?={)", "beginCaptures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" } }, "end": "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])", "patterns": [{ "include": "#jsdoctype" }] }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "entity.name.type.instance.jsdoc" } }, "match": "(?x)\n(\n  (@)\n  (?:alias|augments|callback|constructs|emits|event|fires|exports?\n  |extends|external|function|func|host|lends|listens|interface|memberof!?\n  |method|module|mixes|mixin|name|requires|see|this|typedef|uses)\n)\n\\s+\n(\n  (?:\n    [^{}@\\s*] | \\*[^/]\n  )+\n)" }, { "begin": `((@)(?:default(?:value)?|license|version))\\s+(([''"]))`, "beginCaptures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "variable.other.jsdoc" }, "4": { "name": "punctuation.definition.string.begin.jsdoc" } }, "contentName": "variable.other.jsdoc", "end": "(\\3)|(?=$|\\*/)", "endCaptures": { "0": { "name": "variable.other.jsdoc" }, "1": { "name": "punctuation.definition.string.end.jsdoc" } } }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "variable.other.jsdoc" } }, "match": "((@)(?:default(?:value)?|license|tutorial|variation|version))\\s+([^\\s*]+)" }, { "captures": { "1": { "name": "punctuation.definition.block.tag.jsdoc" } }, "match": "(?x) (@) (?:abstract|access|alias|api|arg|argument|async|attribute|augments|author|beta|borrows|bubbles |callback|chainable|class|classdesc|code|config|const|constant|constructor|constructs|copyright |default|defaultvalue|define|deprecated|desc|description|dict|emits|enum|event|example|exception |exports?|extends|extension(?:_?for)?|external|externs|file|fileoverview|final|fires|for|func |function|generator|global|hideconstructor|host|ignore|implements|implicitCast|inherit[Dd]oc |inner|instance|interface|internal|kind|lends|license|listens|main|member|memberof!?|method |mixes|mixins?|modifies|module|name|namespace|noalias|nocollapse|nocompile|nosideeffects |override|overview|package|param|polymer(?:Behavior)?|preserve|private|prop|property|protected |public|read[Oo]nly|record|require[ds]|returns?|see|since|static|struct|submodule|summary |suppress|template|this|throws|todo|tutorial|type|typedef|unrestricted|uses|var|variation |version|virtual|writeOnce|yields?) \\b", "name": "storage.type.class.jsdoc" }, { "include": "#inline-tags" }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" } }, "match": "((@)(?:[_$[:alpha:]][_$[:alnum:]]*))(?=\\s+)" }] }, "enum-declaration": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?(?:\\b(const)\\s+)?\\b(enum)\\s+([_$[:alpha:]][_$[:alnum:]]*)", "beginCaptures": { "1": { "name": "keyword.control.export.ts" }, "2": { "name": "storage.modifier.ts" }, "3": { "name": "storage.modifier.ts" }, "4": { "name": "storage.type.enum.ts" }, "5": { "name": "entity.name.type.enum.ts" } }, "end": "(?<=\\})", "name": "meta.enum.declaration.ts", "patterns": [{ "include": "#comment" }, { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.block.ts" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.ts" } }, "patterns": [{ "include": "#comment" }, { "begin": "([_$[:alpha:]][_$[:alnum:]]*)", "beginCaptures": { "0": { "name": "variable.other.enummember.ts" } }, "end": "(?=,|\\}|$)", "patterns": [{ "include": "#comment" }, { "include": "#variable-initializer" }] }, { "begin": "(?=((\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\])))", "end": "(?=,|\\}|$)", "patterns": [{ "include": "#string" }, { "include": "#array-literal" }, { "include": "#comment" }, { "include": "#variable-initializer" }] }, { "include": "#punctuation-comma" }] }] }, "export-declaration": { "patterns": [{ "captures": { "1": { "name": "keyword.control.export.ts" }, "2": { "name": "keyword.control.as.ts" }, "3": { "name": "storage.type.namespace.ts" }, "4": { "name": "entity.name.type.module.ts" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(export)\\s+(as)\\s+(namespace)\\s+([_$[:alpha:]][_$[:alnum:]]*)" }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(export)(?:\\s+(type))?(?:(?:\\s*(=))|(?:\\s+(default)(?=\\s+)))", "beginCaptures": { "1": { "name": "keyword.control.export.ts" }, "2": { "name": "keyword.control.type.ts" }, "3": { "name": "keyword.operator.assignment.ts" }, "4": { "name": "keyword.control.default.ts" } }, "end": "(?=$|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "name": "meta.export.default.ts", "patterns": [{ "include": "#interface-declaration" }, { "include": "#expression" }] }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(export)(?:\\s+(type))?\\b(?!(\\$)|(\\s*:))((?=\\s*[\\{*])|((?=\\s*[_$[:alpha:]][_$[:alnum:]]*(\\s|,))(?!\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b)))", "beginCaptures": { "1": { "name": "keyword.control.export.ts" }, "2": { "name": "keyword.control.type.ts" } }, "end": "(?=$|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "name": "meta.export.ts", "patterns": [{ "include": "#import-export-declaration" }] }] }, "expression": { "patterns": [{ "include": "#expressionWithoutIdentifiers" }, { "include": "#identifiers" }, { "include": "#expressionPunctuations" }] }, "expression-inside-possibly-arrow-parens": { "patterns": [{ "include": "#expressionWithoutIdentifiers" }, { "include": "#comment" }, { "include": "#string" }, { "include": "#decorator" }, { "include": "#destructuring-parameter" }, { "captures": { "1": { "name": "storage.modifier.ts" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|protected|private|readonly)\\s+(?=(override|public|protected|private|readonly)\\s+)" }, { "captures": { "1": { "name": "storage.modifier.ts" }, "2": { "name": "keyword.operator.rest.ts" }, "3": { "name": "entity.name.function.ts variable.language.this.ts" }, "4": { "name": "entity.name.function.ts" }, "5": { "name": "keyword.operator.optional.ts" } }, "match": "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))" }, { "captures": { "1": { "name": "storage.modifier.ts" }, "2": { "name": "keyword.operator.rest.ts" }, "3": { "name": "variable.parameter.ts variable.language.this.ts" }, "4": { "name": "variable.parameter.ts" }, "5": { "name": "keyword.operator.optional.ts" } }, "match": "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)(?=\\s*[:,]|$)" }, { "include": "#type-annotation" }, { "include": "#variable-initializer" }, { "match": ",", "name": "punctuation.separator.parameter.ts" }, { "include": "#identifiers" }, { "include": "#expressionPunctuations" }] }, "expression-operators": { "patterns": [{ "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(await)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.control.flow.ts" }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(yield)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?=\\s*\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*\\*)", "beginCaptures": { "1": { "name": "keyword.control.flow.ts" } }, "end": "\\*", "endCaptures": { "0": { "name": "keyword.generator.asterisk.ts" } }, "patterns": [{ "include": "#comment" }] }, { "captures": { "1": { "name": "keyword.control.flow.ts" }, "2": { "name": "keyword.generator.asterisk.ts" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(yield)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?:\\s*(\\*))?" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))delete(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.operator.expression.delete.ts" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))in(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?!\\()", "name": "keyword.operator.expression.in.ts" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))of(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?!\\()", "name": "keyword.operator.expression.of.ts" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))instanceof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.operator.expression.instanceof.ts" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))new(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.operator.new.ts" }, { "include": "#typeof-operator" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))void(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.operator.expression.void.ts" }, { "captures": { "1": { "name": "keyword.control.as.ts" }, "2": { "name": "storage.modifier.ts" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+(const)(?=\\s*($|[;,:})\\]]))" }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(as)|(satisfies))\\s+", "beginCaptures": { "1": { "name": "keyword.control.as.ts" }, "2": { "name": "keyword.control.satisfies.ts" } }, "end": "(?=^|[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as|satisfies)\\s+)|(\\s+\\<))", "patterns": [{ "include": "#type" }] }, { "match": "\\.\\.\\.", "name": "keyword.operator.spread.ts" }, { "match": "\\*=|(?<!\\()/=|%=|\\+=|\\-=", "name": "keyword.operator.assignment.compound.ts" }, { "match": "\\&=|\\^=|<<=|>>=|>>>=|\\|=", "name": "keyword.operator.assignment.compound.bitwise.ts" }, { "match": "<<|>>>|>>", "name": "keyword.operator.bitwise.shift.ts" }, { "match": "===|!==|==|!=", "name": "keyword.operator.comparison.ts" }, { "match": "<=|>=|<>|<|>", "name": "keyword.operator.relational.ts" }, { "captures": { "1": { "name": "keyword.operator.logical.ts" }, "2": { "name": "keyword.operator.assignment.compound.ts" }, "3": { "name": "keyword.operator.arithmetic.ts" } }, "match": "(?<=[_$[:alnum:]])(\\!)\\s*(?:(/=)|(?:(/)(?![/*])))" }, { "match": "\\!|&&|\\|\\||\\?\\?", "name": "keyword.operator.logical.ts" }, { "match": "\\&|~|\\^|\\|", "name": "keyword.operator.bitwise.ts" }, { "match": "\\=", "name": "keyword.operator.assignment.ts" }, { "match": "--", "name": "keyword.operator.decrement.ts" }, { "match": "\\+\\+", "name": "keyword.operator.increment.ts" }, { "match": "%|\\*|/|-|\\+", "name": "keyword.operator.arithmetic.ts" }, { "begin": "(?<=[_$[:alnum:])\\]])\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)+(?:(/=)|(?:(/)(?![/*]))))", "end": "(?:(/=)|(?:(/)(?!\\*([^\\*]|(\\*[^\\/]))*\\*\\/)))", "endCaptures": { "1": { "name": "keyword.operator.assignment.compound.ts" }, "2": { "name": "keyword.operator.arithmetic.ts" } }, "patterns": [{ "include": "#comment" }] }, { "captures": { "1": { "name": "keyword.operator.assignment.compound.ts" }, "2": { "name": "keyword.operator.arithmetic.ts" } }, "match": "(?<=[_$[:alnum:])\\]])\\s*(?:(/=)|(?:(/)(?![/*])))" }] }, "expressionPunctuations": { "patterns": [{ "include": "#punctuation-comma" }, { "include": "#punctuation-accessor" }] }, "expressionWithoutIdentifiers": { "patterns": [{ "include": "#string" }, { "include": "#regex" }, { "include": "#comment" }, { "include": "#function-expression" }, { "include": "#class-expression" }, { "include": "#arrow-function" }, { "include": "#paren-expression-possibly-arrow" }, { "include": "#cast" }, { "include": "#ternary-expression" }, { "include": "#new-expr" }, { "include": "#instanceof-expr" }, { "include": "#object-literal" }, { "include": "#expression-operators" }, { "include": "#function-call" }, { "include": "#literal" }, { "include": "#support-objects" }, { "include": "#paren-expression" }] }, "field-declaration": { "begin": "(?x)(?<!\\()(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(readonly)\\s+)?(?=\\s*((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|(\\#?[_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(?:(?:(\\?)|(\\!))\\s*)?(=|:|;|,|\\}|$))", "beginCaptures": { "1": { "name": "storage.modifier.ts" } }, "end": "(?x)(?=\\}|;|,|$|(^(?!\\s*((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|(\\#?[_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(?:(?:(\\?)|(\\!))\\s*)?(=|:|;|,|$))))|(?<=\\})", "name": "meta.field.declaration.ts", "patterns": [{ "include": "#variable-initializer" }, { "include": "#type-annotation" }, { "include": "#string" }, { "include": "#array-literal" }, { "include": "#numeric-literal" }, { "include": "#comment" }, { "captures": { "1": { "name": "meta.definition.property.ts entity.name.function.ts" }, "2": { "name": "keyword.operator.optional.ts" }, "3": { "name": "keyword.operator.definiteassignment.ts" } }, "match": "(?x)(\\#?[_$[:alpha:]][_$[:alnum:]]*)(?:(\\?)|(\\!))?(?=\\s*\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))" }, { "match": "\\#?[_$[:alpha:]][_$[:alnum:]]*", "name": "meta.definition.property.ts variable.object.property.ts" }, { "match": "\\?", "name": "keyword.operator.optional.ts" }, { "match": "\\!", "name": "keyword.operator.definiteassignment.ts" }] }, "for-loop": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))for(?=((\\s+|(\\s*\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*))await)?\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)?(\\())", "beginCaptures": { "0": { "name": "keyword.control.loop.ts" } }, "end": "(?<=\\))", "patterns": [{ "include": "#comment" }, { "match": "await", "name": "keyword.control.loop.ts" }, { "begin": "\\(", "beginCaptures": { "0": { "name": "meta.brace.round.ts" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.ts" } }, "patterns": [{ "include": "#var-expr" }, { "include": "#expression" }, { "include": "#punctuation-semicolon" }] }] }, "function-body": { "patterns": [{ "include": "#comment" }, { "include": "#type-parameters" }, { "include": "#function-parameters" }, { "include": "#return-type" }, { "include": "#type-function-return-type" }, { "include": "#decl-block" }, { "match": "\\*", "name": "keyword.generator.asterisk.ts" }] }, "function-call": { "patterns": [{ "begin": "(?=(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))\\s*(?:(\\?\\.\\s*)|(\\!))?((<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?\\())", "end": "(?<=\\))(?!(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))\\s*(?:(\\?\\.\\s*)|(\\!))?((<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?\\())", "patterns": [{ "begin": "(?=(([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))", "end": "(?=\\s*(?:(\\?\\.\\s*)|(\\!))?((<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?\\())", "name": "meta.function-call.ts", "patterns": [{ "include": "#function-call-target" }] }, { "include": "#comment" }, { "include": "#function-call-optionals" }, { "include": "#type-arguments" }, { "include": "#paren-expression" }] }, { "begin": "(?=(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))(<\\s*[\\{\\[\\(]\\s*$))", "end": "(?<=\\>)(?!(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))(<\\s*[\\{\\[\\(]\\s*$))", "patterns": [{ "begin": "(?=(([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))", "end": "(?=(<\\s*[\\{\\[\\(]\\s*$))", "name": "meta.function-call.ts", "patterns": [{ "include": "#function-call-target" }] }, { "include": "#comment" }, { "include": "#function-call-optionals" }, { "include": "#type-arguments" }] }] }, "function-call-optionals": { "patterns": [{ "match": "\\?\\.", "name": "meta.function-call.ts punctuation.accessor.optional.ts" }, { "match": "\\!", "name": "meta.function-call.ts keyword.operator.definiteassignment.ts" }] }, "function-call-target": { "patterns": [{ "include": "#support-function-call-identifiers" }, { "match": "(\\#?[_$[:alpha:]][_$[:alnum:]]*)", "name": "entity.name.function.ts" }] }, "function-declaration": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?(?:(async)\\s+)?(function\\b)(?:\\s*(\\*))?(?:(?:\\s+|(?<=\\*))([_$[:alpha:]][_$[:alnum:]]*))?\\s*", "beginCaptures": { "1": { "name": "keyword.control.export.ts" }, "2": { "name": "storage.modifier.ts" }, "3": { "name": "storage.modifier.async.ts" }, "4": { "name": "storage.type.function.ts" }, "5": { "name": "keyword.generator.asterisk.ts" }, "6": { "name": "meta.definition.function.ts entity.name.function.ts" } }, "end": "(?=;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))|(?<=\\})", "name": "meta.function.ts", "patterns": [{ "include": "#function-name" }, { "include": "#function-body" }] }, "function-expression": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(async)\\s+)?(function\\b)(?:\\s*(\\*))?(?:(?:\\s+|(?<=\\*))([_$[:alpha:]][_$[:alnum:]]*))?\\s*", "beginCaptures": { "1": { "name": "storage.modifier.async.ts" }, "2": { "name": "storage.type.function.ts" }, "3": { "name": "keyword.generator.asterisk.ts" }, "4": { "name": "meta.definition.function.ts entity.name.function.ts" } }, "end": "(?=;)|(?<=\\})", "name": "meta.function.expression.ts", "patterns": [{ "include": "#function-name" }, { "include": "#single-line-comment-consuming-line-ending" }, { "include": "#function-body" }] }, "function-name": { "match": "[_$[:alpha:]][_$[:alnum:]]*", "name": "meta.definition.function.ts entity.name.function.ts" }, "function-parameters": { "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.parameters.begin.ts" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.parameters.end.ts" } }, "name": "meta.parameters.ts", "patterns": [{ "include": "#function-parameters-body" }] }, "function-parameters-body": { "patterns": [{ "include": "#comment" }, { "include": "#string" }, { "include": "#decorator" }, { "include": "#destructuring-parameter" }, { "include": "#parameter-name" }, { "include": "#parameter-type-annotation" }, { "include": "#variable-initializer" }, { "match": ",", "name": "punctuation.separator.parameter.ts" }] }, "identifiers": { "patterns": [{ "include": "#object-identifiers" }, { "captures": { "1": { "name": "punctuation.accessor.ts" }, "2": { "name": "punctuation.accessor.optional.ts" }, "3": { "name": "entity.name.function.ts" } }, "match": "(?x)(?:(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*)?([_$[:alpha:]][_$[:alnum:]]*)(?=\\s*=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n))" }, { "captures": { "1": { "name": "punctuation.accessor.ts" }, "2": { "name": "punctuation.accessor.optional.ts" }, "3": { "name": "variable.other.constant.property.ts" } }, "match": "(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(\\#?[[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])" }, { "captures": { "1": { "name": "punctuation.accessor.ts" }, "2": { "name": "punctuation.accessor.optional.ts" }, "3": { "name": "variable.other.property.ts" } }, "match": "(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*)" }, { "match": "([[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])", "name": "variable.other.constant.ts" }, { "match": "[_$[:alpha:]][_$[:alnum:]]*", "name": "variable.other.readwrite.ts" }] }, "if-statement": { "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?=\\bif\\s*(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))\\s*(?!\\{))", "end": "(?=;|$|\\})", "patterns": [{ "include": "#comment" }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(if)\\s*(\\()", "beginCaptures": { "1": { "name": "keyword.control.conditional.ts" }, "2": { "name": "meta.brace.round.ts" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.ts" } }, "patterns": [{ "include": "#expression" }] }, { "begin": "(?<=\\))\\s*\\/(?![\\/*])(?=(?:[^\\/\\\\\\[]|\\\\.|\\[([^\\]\\\\]|\\\\.)*\\])+\\/([dgimsuy]+|(?![\\/\\*])|(?=\\/\\*))(?!\\s*[a-zA-Z0-9_$]))", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.ts" } }, "end": "(/)([dgimsuy]*)", "endCaptures": { "1": { "name": "punctuation.definition.string.end.ts" }, "2": { "name": "keyword.other.ts" } }, "name": "string.regexp.ts", "patterns": [{ "include": "#regexp" }] }, { "include": "#statements" }] }] }, "import-declaration": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(import)(?:\\s+(type)(?!\\s+from))?(?!\\s*[:\\(])(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "1": { "name": "keyword.control.export.ts" }, "2": { "name": "storage.modifier.ts" }, "3": { "name": "keyword.control.import.ts" }, "4": { "name": "keyword.control.type.ts" } }, "end": "(?<!^import|[^\\._$[:alnum:]]import)(?=;|$|^)", "name": "meta.import.ts", "patterns": [{ "include": "#single-line-comment-consuming-line-ending" }, { "include": "#comment" }, { "include": "#string" }, { "begin": `(?<=^import|[^\\._$[:alnum:]]import)(?!\\s*["'])`, "end": "\\bfrom\\b", "endCaptures": { "0": { "name": "keyword.control.from.ts" } }, "patterns": [{ "include": "#import-export-declaration" }] }, { "include": "#import-export-declaration" }] }, "import-equals-declaration": { "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(import)(?:\\s+(type))?\\s+([_$[:alpha:]][_$[:alnum:]]*)\\s*(=)\\s*(require)\\s*(\\()", "beginCaptures": { "1": { "name": "keyword.control.export.ts" }, "2": { "name": "storage.modifier.ts" }, "3": { "name": "keyword.control.import.ts" }, "4": { "name": "keyword.control.type.ts" }, "5": { "name": "variable.other.readwrite.alias.ts" }, "6": { "name": "keyword.operator.assignment.ts" }, "7": { "name": "keyword.control.require.ts" }, "8": { "name": "meta.brace.round.ts" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.ts" } }, "name": "meta.import-equals.external.ts", "patterns": [{ "include": "#comment" }, { "include": "#string" }] }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(import)(?:\\s+(type))?\\s+([_$[:alpha:]][_$[:alnum:]]*)\\s*(=)\\s*(?!require\\b)", "beginCaptures": { "1": { "name": "keyword.control.export.ts" }, "2": { "name": "storage.modifier.ts" }, "3": { "name": "keyword.control.import.ts" }, "4": { "name": "keyword.control.type.ts" }, "5": { "name": "variable.other.readwrite.alias.ts" }, "6": { "name": "keyword.operator.assignment.ts" } }, "end": "(?=;|$|^)", "name": "meta.import-equals.internal.ts", "patterns": [{ "include": "#single-line-comment-consuming-line-ending" }, { "include": "#comment" }, { "captures": { "1": { "name": "entity.name.type.module.ts" }, "2": { "name": "punctuation.accessor.ts" }, "3": { "name": "punctuation.accessor.optional.ts" } }, "match": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))" }, { "match": "([_$[:alpha:]][_$[:alnum:]]*)", "name": "variable.other.readwrite.ts" }] }] }, "import-export-assert-clause": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(assert)\\s*(\\{)", "beginCaptures": { "1": { "name": "keyword.control.assert.ts" }, "2": { "name": "punctuation.definition.block.ts" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.ts" } }, "patterns": [{ "include": "#comment" }, { "include": "#string" }, { "match": "(?:[_$[:alpha:]][_$[:alnum:]]*)\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*:)", "name": "meta.object-literal.key.ts" }, { "match": ":", "name": "punctuation.separator.key-value.ts" }] }, "import-export-block": { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.block.ts" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.ts" } }, "name": "meta.block.ts", "patterns": [{ "include": "#import-export-clause" }] }, "import-export-clause": { "patterns": [{ "include": "#comment" }, { "captures": { "1": { "name": "keyword.control.type.ts" }, "2": { "name": "keyword.control.default.ts" }, "3": { "name": "constant.language.import-export-all.ts" }, "4": { "name": "variable.other.readwrite.ts" }, "5": { "name": "keyword.control.as.ts" }, "6": { "name": "keyword.control.default.ts" }, "7": { "name": "variable.other.readwrite.alias.ts" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(?:(\\btype)\\s+)?(?:(\\bdefault)|(\\*)|(\\b[_$[:alpha:]][_$[:alnum:]]*)))\\s+(as)\\s+(?:(default(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|([_$[:alpha:]][_$[:alnum:]]*))" }, { "include": "#punctuation-comma" }, { "match": "\\*", "name": "constant.language.import-export-all.ts" }, { "match": "\\b(default)\\b", "name": "keyword.control.default.ts" }, { "captures": { "1": { "name": "keyword.control.type.ts" }, "2": { "name": "variable.other.readwrite.alias.ts" } }, "match": "(?:(\\btype)\\s+)?([_$[:alpha:]][_$[:alnum:]]*)" }] }, "import-export-declaration": { "patterns": [{ "include": "#comment" }, { "include": "#string" }, { "include": "#import-export-block" }, { "match": "\\bfrom\\b", "name": "keyword.control.from.ts" }, { "include": "#import-export-assert-clause" }, { "include": "#import-export-clause" }] }, "indexer-declaration": { "begin": "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(readonly)\\s*)?\\s*(\\[)\\s*([_$[:alpha:]][_$[:alnum:]]*)\\s*(?=:)", "beginCaptures": { "1": { "name": "storage.modifier.ts" }, "2": { "name": "meta.brace.square.ts" }, "3": { "name": "variable.parameter.ts" } }, "end": "(\\])\\s*(\\?\\s*)?|$", "endCaptures": { "1": { "name": "meta.brace.square.ts" }, "2": { "name": "keyword.operator.optional.ts" } }, "name": "meta.indexer.declaration.ts", "patterns": [{ "include": "#type-annotation" }] }, "indexer-mapped-type-declaration": { "begin": "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))([+-])?(readonly)\\s*)?\\s*(\\[)\\s*([_$[:alpha:]][_$[:alnum:]]*)\\s+(in)\\s+", "beginCaptures": { "1": { "name": "keyword.operator.type.modifier.ts" }, "2": { "name": "storage.modifier.ts" }, "3": { "name": "meta.brace.square.ts" }, "4": { "name": "entity.name.type.ts" }, "5": { "name": "keyword.operator.expression.in.ts" } }, "end": "(\\])([+-])?\\s*(\\?\\s*)?|$", "endCaptures": { "1": { "name": "meta.brace.square.ts" }, "2": { "name": "keyword.operator.type.modifier.ts" }, "3": { "name": "keyword.operator.optional.ts" } }, "name": "meta.indexer.mappedtype.declaration.ts", "patterns": [{ "captures": { "1": { "name": "keyword.control.as.ts" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+" }, { "include": "#type" }] }, "inline-tags": { "patterns": [{ "captures": { "1": { "name": "punctuation.definition.bracket.square.begin.jsdoc" }, "2": { "name": "punctuation.definition.bracket.square.end.jsdoc" } }, "match": "(\\[)[^\\]]+(\\])(?={@(?:link|linkcode|linkplain|tutorial))", "name": "constant.other.description.jsdoc" }, { "begin": "({)((@)(?:link(?:code|plain)?|tutorial))\\s*", "beginCaptures": { "1": { "name": "punctuation.definition.bracket.curly.begin.jsdoc" }, "2": { "name": "storage.type.class.jsdoc" }, "3": { "name": "punctuation.definition.inline.tag.jsdoc" } }, "end": "}|(?=\\*/)", "endCaptures": { "0": { "name": "punctuation.definition.bracket.curly.end.jsdoc" } }, "name": "entity.name.type.instance.jsdoc", "patterns": [{ "captures": { "1": { "name": "variable.other.link.underline.jsdoc" }, "2": { "name": "punctuation.separator.pipe.jsdoc" } }, "match": "\\G((?=https?://)(?:[^|}\\s*]|\\*[/])+)(\\|)?" }, { "captures": { "1": { "name": "variable.other.description.jsdoc" }, "2": { "name": "punctuation.separator.pipe.jsdoc" } }, "match": "\\G((?:[^{}@\\s|*]|\\*[^/])+)(\\|)?" }] }] }, "instanceof-expr": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(instanceof)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "1": { "name": "keyword.operator.expression.instanceof.ts" } }, "end": "(?<=\\))|(?=[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|(===|!==|==|!=)|(([\\&\\~\\^\\|]\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s+instanceof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))function((\\s+[_$[:alpha:]][_$[:alnum:]]*)|(\\s*[\\(]))))", "patterns": [{ "include": "#type" }] }, "interface-declaration": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(?:(abstract)\\s+)?\\b(interface)\\b(?=\\s+|/[/*])", "beginCaptures": { "1": { "name": "keyword.control.export.ts" }, "2": { "name": "storage.modifier.ts" }, "3": { "name": "storage.modifier.ts" }, "4": { "name": "storage.type.interface.ts" } }, "end": "(?<=\\})", "name": "meta.interface.ts", "patterns": [{ "include": "#comment" }, { "include": "#class-or-interface-heritage" }, { "captures": { "0": { "name": "entity.name.type.interface.ts" } }, "match": "[_$[:alpha:]][_$[:alnum:]]*" }, { "include": "#type-parameters" }, { "include": "#class-or-interface-body" }] }, "jsdoctype": { "patterns": [{ "begin": "\\G({)", "beginCaptures": { "0": { "name": "entity.name.type.instance.jsdoc" }, "1": { "name": "punctuation.definition.bracket.curly.begin.jsdoc" } }, "contentName": "entity.name.type.instance.jsdoc", "end": "((}))\\s*|(?=\\*/)", "endCaptures": { "1": { "name": "entity.name.type.instance.jsdoc" }, "2": { "name": "punctuation.definition.bracket.curly.end.jsdoc" } }, "patterns": [{ "include": "#brackets" }] }] }, "label": { "patterns": [{ "begin": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(:)(?=\\s*\\{)", "beginCaptures": { "1": { "name": "entity.name.label.ts" }, "2": { "name": "punctuation.separator.label.ts" } }, "end": "(?<=\\})", "patterns": [{ "include": "#decl-block" }] }, { "captures": { "1": { "name": "entity.name.label.ts" }, "2": { "name": "punctuation.separator.label.ts" } }, "match": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(:)" }] }, "literal": { "patterns": [{ "include": "#numeric-literal" }, { "include": "#boolean-literal" }, { "include": "#null-literal" }, { "include": "#undefined-literal" }, { "include": "#numericConstant-literal" }, { "include": "#array-literal" }, { "include": "#this-literal" }, { "include": "#super-literal" }] }, "method-declaration": { "patterns": [{ "begin": "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(override)\\s+)?(?:\\b(public|private|protected)\\s+)?(?:\\b(abstract)\\s+)?(?:\\b(async)\\s+)?\\s*\\b(constructor)\\b(?!:)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "1": { "name": "storage.modifier.ts" }, "2": { "name": "storage.modifier.ts" }, "3": { "name": "storage.modifier.ts" }, "4": { "name": "storage.modifier.async.ts" }, "5": { "name": "storage.type.ts" } }, "end": "(?=\\}|;|,|$)|(?<=\\})", "name": "meta.method.declaration.ts", "patterns": [{ "include": "#method-declaration-name" }, { "include": "#function-body" }] }, { "begin": "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(override)\\s+)?(?:\\b(public|private|protected)\\s+)?(?:\\b(abstract)\\s+)?(?:\\b(async)\\s+)?(?:(?:\\s*\\b(new)\\b(?!:)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|(?:(\\*)\\s*)?)(?=\\s*((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])", "beginCaptures": { "1": { "name": "storage.modifier.ts" }, "2": { "name": "storage.modifier.ts" }, "3": { "name": "storage.modifier.ts" }, "4": { "name": "storage.modifier.async.ts" }, "5": { "name": "keyword.operator.new.ts" }, "6": { "name": "keyword.generator.asterisk.ts" } }, "end": "(?=\\}|;|,|$)|(?<=\\})", "name": "meta.method.declaration.ts", "patterns": [{ "include": "#method-declaration-name" }, { "include": "#function-body" }] }, { "begin": "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(override)\\s+)?(?:\\b(public|private|protected)\\s+)?(?:\\b(abstract)\\s+)?(?:\\b(async)\\s+)?(?:\\b(get|set)\\s+)?(?:(\\*)\\s*)?(?=\\s*(((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??))\\s*((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])", "beginCaptures": { "1": { "name": "storage.modifier.ts" }, "2": { "name": "storage.modifier.ts" }, "3": { "name": "storage.modifier.ts" }, "4": { "name": "storage.modifier.async.ts" }, "5": { "name": "storage.type.property.ts" }, "6": { "name": "keyword.generator.asterisk.ts" } }, "end": "(?=\\}|;|,|$)|(?<=\\})", "name": "meta.method.declaration.ts", "patterns": [{ "include": "#method-declaration-name" }, { "include": "#function-body" }] }] }, "method-declaration-name": { "begin": "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??)\\s*[\\(\\<])", "end": "(?=\\(|\\<)", "patterns": [{ "include": "#string" }, { "include": "#array-literal" }, { "include": "#numeric-literal" }, { "match": "[_$[:alpha:]][_$[:alnum:]]*", "name": "meta.definition.method.ts entity.name.function.ts" }, { "match": "\\?", "name": "keyword.operator.optional.ts" }] }, "namespace-declaration": { "begin": "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(namespace|module)\\s+(?=[_$[:alpha:]\"'`]))", "beginCaptures": { "1": { "name": "keyword.control.export.ts" }, "2": { "name": "storage.modifier.ts" }, "3": { "name": "storage.type.namespace.ts" } }, "end": "(?<=\\})|(?=;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "name": "meta.namespace.declaration.ts", "patterns": [{ "include": "#comment" }, { "include": "#string" }, { "match": "([_$[:alpha:]][_$[:alnum:]]*)", "name": "entity.name.type.module.ts" }, { "include": "#punctuation-accessor" }, { "include": "#decl-block" }] }, "new-expr": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(new)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "1": { "name": "keyword.operator.new.ts" } }, "end": "(?<=\\))|(?=[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))new(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))function((\\s+[_$[:alpha:]][_$[:alnum:]]*)|(\\s*[\\(]))))", "name": "new.expr.ts", "patterns": [{ "include": "#expression" }] }, "null-literal": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))null(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "constant.language.null.ts" }, "numeric-literal": { "patterns": [{ "captures": { "1": { "name": "storage.type.numeric.bigint.ts" } }, "match": "\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$)", "name": "constant.numeric.hex.ts" }, { "captures": { "1": { "name": "storage.type.numeric.bigint.ts" } }, "match": "\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$)", "name": "constant.numeric.binary.ts" }, { "captures": { "1": { "name": "storage.type.numeric.bigint.ts" } }, "match": "\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$)", "name": "constant.numeric.octal.ts" }, { "captures": { "0": { "name": "constant.numeric.decimal.ts" }, "1": { "name": "meta.delimiter.decimal.period.ts" }, "2": { "name": "storage.type.numeric.bigint.ts" }, "3": { "name": "meta.delimiter.decimal.period.ts" }, "4": { "name": "storage.type.numeric.bigint.ts" }, "5": { "name": "meta.delimiter.decimal.period.ts" }, "6": { "name": "storage.type.numeric.bigint.ts" }, "7": { "name": "storage.type.numeric.bigint.ts" }, "8": { "name": "meta.delimiter.decimal.period.ts" }, "9": { "name": "storage.type.numeric.bigint.ts" }, "10": { "name": "meta.delimiter.decimal.period.ts" }, "11": { "name": "storage.type.numeric.bigint.ts" }, "12": { "name": "meta.delimiter.decimal.period.ts" }, "13": { "name": "storage.type.numeric.bigint.ts" }, "14": { "name": "storage.type.numeric.bigint.ts" } }, "match": "(?x)\n(?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$)" }] }, "numericConstant-literal": { "patterns": [{ "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))NaN(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "constant.language.nan.ts" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Infinity(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "constant.language.infinity.ts" }] }, "object-binding-element": { "patterns": [{ "include": "#comment" }, { "begin": "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))", "end": "(?=,|\\})", "patterns": [{ "include": "#object-binding-element-propertyName" }, { "include": "#binding-element" }] }, { "include": "#object-binding-pattern" }, { "include": "#destructuring-variable-rest" }, { "include": "#variable-initializer" }, { "include": "#punctuation-comma" }] }, "object-binding-element-const": { "patterns": [{ "include": "#comment" }, { "begin": "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))", "end": "(?=,|\\})", "patterns": [{ "include": "#object-binding-element-propertyName" }, { "include": "#binding-element-const" }] }, { "include": "#object-binding-pattern-const" }, { "include": "#destructuring-variable-rest-const" }, { "include": "#variable-initializer" }, { "include": "#punctuation-comma" }] }, "object-binding-element-propertyName": { "begin": "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))", "end": "(:)", "endCaptures": { "0": { "name": "punctuation.destructuring.ts" } }, "patterns": [{ "include": "#string" }, { "include": "#array-literal" }, { "include": "#numeric-literal" }, { "match": "([_$[:alpha:]][_$[:alnum:]]*)", "name": "variable.object.property.ts" }] }, "object-binding-pattern": { "begin": "(?:(\\.\\.\\.)\\s*)?(\\{)", "beginCaptures": { "1": { "name": "keyword.operator.rest.ts" }, "2": { "name": "punctuation.definition.binding-pattern.object.ts" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.object.ts" } }, "patterns": [{ "include": "#object-binding-element" }] }, "object-binding-pattern-const": { "begin": "(?:(\\.\\.\\.)\\s*)?(\\{)", "beginCaptures": { "1": { "name": "keyword.operator.rest.ts" }, "2": { "name": "punctuation.definition.binding-pattern.object.ts" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.object.ts" } }, "patterns": [{ "include": "#object-binding-element-const" }] }, "object-identifiers": { "patterns": [{ "match": "([_$[:alpha:]][_$[:alnum:]]*)(?=\\s*\\??\\.\\s*prototype\\b(?!\\$))", "name": "support.class.ts" }, { "captures": { "1": { "name": "punctuation.accessor.ts" }, "2": { "name": "punctuation.accessor.optional.ts" }, "3": { "name": "variable.other.constant.object.property.ts" }, "4": { "name": "variable.other.object.property.ts" } }, "match": "(?x)(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(?:\n  (\\#?[[:upper:]][_$[:digit:][:upper:]]*) |\n  (\\#?[_$[:alpha:]][_$[:alnum:]]*)\n)(?=\\s*\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*)" }, { "captures": { "1": { "name": "variable.other.constant.object.ts" }, "2": { "name": "variable.other.object.ts" } }, "match": "(?x)(?:\n  ([[:upper:]][_$[:digit:][:upper:]]*) |\n  ([_$[:alpha:]][_$[:alnum:]]*)\n)(?=\\s*\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*)" }] }, "object-literal": { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.block.ts" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.ts" } }, "name": "meta.objectliteral.ts", "patterns": [{ "include": "#object-member" }] }, "object-literal-method-declaration": { "begin": "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(async)\\s+)?(?:\\b(get|set)\\s+)?(?:(\\*)\\s*)?(?=\\s*(((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??))\\s*((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])", "beginCaptures": { "1": { "name": "storage.modifier.async.ts" }, "2": { "name": "storage.type.property.ts" }, "3": { "name": "keyword.generator.asterisk.ts" } }, "end": "(?=\\}|;|,)|(?<=\\})", "name": "meta.method.declaration.ts", "patterns": [{ "include": "#method-declaration-name" }, { "include": "#function-body" }, { "begin": "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(async)\\s+)?(?:\\b(get|set)\\s+)?(?:(\\*)\\s*)?(?=\\s*(((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??))\\s*((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])", "beginCaptures": { "1": { "name": "storage.modifier.async.ts" }, "2": { "name": "storage.type.property.ts" }, "3": { "name": "keyword.generator.asterisk.ts" } }, "end": "(?=\\(|\\<)", "patterns": [{ "include": "#method-declaration-name" }] }] }, "object-member": { "patterns": [{ "include": "#comment" }, { "include": "#object-literal-method-declaration" }, { "begin": "(?=\\[)", "end": "(?=:)|((?<=[\\]])(?=\\s*[\\(\\<]))", "name": "meta.object.member.ts meta.object-literal.key.ts", "patterns": [{ "include": "#comment" }, { "include": "#array-literal" }] }, { "begin": "(?=[\\'\\\"\\`])", "end": "(?=:)|((?<=[\\'\\\"\\`])(?=((\\s*[\\(\\<,}])|(\\s+(as|satisifies)\\s+))))", "name": "meta.object.member.ts meta.object-literal.key.ts", "patterns": [{ "include": "#comment" }, { "include": "#string" }] }, { "begin": "(?x)(?=(\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$)))", "end": "(?=:)|(?=\\s*([\\(\\<,}])|(\\s+as|satisifies\\s+))", "name": "meta.object.member.ts meta.object-literal.key.ts", "patterns": [{ "include": "#comment" }, { "include": "#numeric-literal" }] }, { "begin": "(?<=[\\]\\'\\\"\\`])(?=\\s*[\\(\\<])", "end": "(?=\\}|;|,)|(?<=\\})", "name": "meta.method.declaration.ts", "patterns": [{ "include": "#function-body" }] }, { "captures": { "0": { "name": "meta.object-literal.key.ts" }, "1": { "name": "constant.numeric.decimal.ts" } }, "match": "(?![_$[:alpha:]])([[:digit:]]+)\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*:)", "name": "meta.object.member.ts" }, { "captures": { "0": { "name": "meta.object-literal.key.ts" }, "1": { "name": "entity.name.function.ts" } }, "match": "(?x)(?:([_$[:alpha:]][_$[:alnum:]]*)\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*:(\\s*\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/)*\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))", "name": "meta.object.member.ts" }, { "captures": { "0": { "name": "meta.object-literal.key.ts" } }, "match": "(?:[_$[:alpha:]][_$[:alnum:]]*)\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*:)", "name": "meta.object.member.ts" }, { "begin": "\\.\\.\\.", "beginCaptures": { "0": { "name": "keyword.operator.spread.ts" } }, "end": "(?=,|\\})", "name": "meta.object.member.ts", "patterns": [{ "include": "#expression" }] }, { "captures": { "1": { "name": "variable.other.readwrite.ts" } }, "match": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?=,|\\}|$|\\/\\/|\\/\\*)", "name": "meta.object.member.ts" }, { "captures": { "1": { "name": "keyword.control.as.ts" }, "2": { "name": "storage.modifier.ts" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+(const)(?=\\s*([,}]|$))", "name": "meta.object.member.ts" }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(as)|(satisfies))\\s+", "beginCaptures": { "1": { "name": "keyword.control.as.ts" }, "2": { "name": "keyword.control.satisfies.ts" } }, "end": "(?=[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|^|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as|satisifies)\\s+))", "name": "meta.object.member.ts", "patterns": [{ "include": "#type" }] }, { "begin": "(?=[_$[:alpha:]][_$[:alnum:]]*\\s*=)", "end": "(?=,|\\}|$|\\/\\/|\\/\\*)", "name": "meta.object.member.ts", "patterns": [{ "include": "#expression" }] }, { "begin": ":", "beginCaptures": { "0": { "name": "meta.object-literal.key.ts punctuation.separator.key-value.ts" } }, "end": "(?=,|\\})", "name": "meta.object.member.ts", "patterns": [{ "begin": "(?<=:)\\s*(async)?(?=\\s*(<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)\\(\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))", "beginCaptures": { "1": { "name": "storage.modifier.async.ts" } }, "end": "(?<=\\))", "patterns": [{ "include": "#type-parameters" }, { "begin": "\\(", "beginCaptures": { "0": { "name": "meta.brace.round.ts" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.ts" } }, "patterns": [{ "include": "#expression-inside-possibly-arrow-parens" }] }] }, { "begin": "(?<=:)\\s*(async)?\\s*(\\()(?=\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))", "beginCaptures": { "1": { "name": "storage.modifier.async.ts" }, "2": { "name": "meta.brace.round.ts" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.ts" } }, "patterns": [{ "include": "#expression-inside-possibly-arrow-parens" }] }, { "begin": "(?<=:)\\s*(async)?\\s*(?=\\<\\s*$)", "beginCaptures": { "1": { "name": "storage.modifier.async.ts" } }, "end": "(?<=\\>)", "patterns": [{ "include": "#type-parameters" }] }, { "begin": "(?<=\\>)\\s*(\\()(?=\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))", "beginCaptures": { "1": { "name": "meta.brace.round.ts" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.ts" } }, "patterns": [{ "include": "#expression-inside-possibly-arrow-parens" }] }, { "include": "#possibly-arrow-return-type" }, { "include": "#expression" }] }, { "include": "#punctuation-comma" }, { "include": "#decl-block" }] }, "parameter-array-binding-pattern": { "begin": "(?:(\\.\\.\\.)\\s*)?(\\[)", "beginCaptures": { "1": { "name": "keyword.operator.rest.ts" }, "2": { "name": "punctuation.definition.binding-pattern.array.ts" } }, "end": "\\]", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.array.ts" } }, "patterns": [{ "include": "#parameter-binding-element" }, { "include": "#punctuation-comma" }] }, "parameter-binding-element": { "patterns": [{ "include": "#comment" }, { "include": "#string" }, { "include": "#numeric-literal" }, { "include": "#regex" }, { "include": "#parameter-object-binding-pattern" }, { "include": "#parameter-array-binding-pattern" }, { "include": "#destructuring-parameter-rest" }, { "include": "#variable-initializer" }] }, "parameter-name": { "patterns": [{ "captures": { "1": { "name": "storage.modifier.ts" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|protected|private|readonly)\\s+(?=(override|public|protected|private|readonly)\\s+)" }, { "captures": { "1": { "name": "storage.modifier.ts" }, "2": { "name": "keyword.operator.rest.ts" }, "3": { "name": "entity.name.function.ts variable.language.this.ts" }, "4": { "name": "entity.name.function.ts" }, "5": { "name": "keyword.operator.optional.ts" } }, "match": "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))" }, { "captures": { "1": { "name": "storage.modifier.ts" }, "2": { "name": "keyword.operator.rest.ts" }, "3": { "name": "variable.parameter.ts variable.language.this.ts" }, "4": { "name": "variable.parameter.ts" }, "5": { "name": "keyword.operator.optional.ts" } }, "match": "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)" }] }, "parameter-object-binding-element": { "patterns": [{ "include": "#comment" }, { "begin": "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))", "end": "(?=,|\\})", "patterns": [{ "include": "#object-binding-element-propertyName" }, { "include": "#parameter-binding-element" }, { "include": "#paren-expression" }] }, { "include": "#parameter-object-binding-pattern" }, { "include": "#destructuring-parameter-rest" }, { "include": "#variable-initializer" }, { "include": "#punctuation-comma" }] }, "parameter-object-binding-pattern": { "begin": "(?:(\\.\\.\\.)\\s*)?(\\{)", "beginCaptures": { "1": { "name": "keyword.operator.rest.ts" }, "2": { "name": "punctuation.definition.binding-pattern.object.ts" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.object.ts" } }, "patterns": [{ "include": "#parameter-object-binding-element" }] }, "parameter-type-annotation": { "patterns": [{ "begin": "(:)", "beginCaptures": { "1": { "name": "keyword.operator.type.annotation.ts" } }, "end": "(?=[,)])|(?==[^>])", "name": "meta.type.annotation.ts", "patterns": [{ "include": "#type" }] }] }, "paren-expression": { "begin": "\\(", "beginCaptures": { "0": { "name": "meta.brace.round.ts" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.ts" } }, "patterns": [{ "include": "#expression" }] }, "paren-expression-possibly-arrow": { "patterns": [{ "begin": "(?<=[(=,])\\s*(async)?(?=\\s*((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?\\(\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))", "beginCaptures": { "1": { "name": "storage.modifier.async.ts" } }, "end": "(?<=\\))", "patterns": [{ "include": "#paren-expression-possibly-arrow-with-typeparameters" }] }, { "begin": "(?<=[(=,]|=>|^return|[^\\._$[:alnum:]]return)\\s*(async)?(?=\\s*((((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?\\()|(<)|((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)))\\s*$)", "beginCaptures": { "1": { "name": "storage.modifier.async.ts" } }, "end": "(?<=\\))", "patterns": [{ "include": "#paren-expression-possibly-arrow-with-typeparameters" }] }, { "include": "#possibly-arrow-return-type" }] }, "paren-expression-possibly-arrow-with-typeparameters": { "patterns": [{ "include": "#type-parameters" }, { "begin": "\\(", "beginCaptures": { "0": { "name": "meta.brace.round.ts" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.ts" } }, "patterns": [{ "include": "#expression-inside-possibly-arrow-parens" }] }] }, "possibly-arrow-return-type": { "begin": "(?<=\\)|^)\\s*(:)(?=\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*=>)", "beginCaptures": { "1": { "name": "meta.arrow.ts meta.return.type.arrow.ts keyword.operator.type.annotation.ts" } }, "contentName": "meta.arrow.ts meta.return.type.arrow.ts", "end": "(?==>|\\{|(^\\s*(export|function|class|interface|let|var|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|const|import|enum|namespace|module|type|abstract|declare)\\s+))", "patterns": [{ "include": "#arrow-return-type-body" }] }, "property-accessor": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(accessor|get|set)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "storage.type.property.ts" }, "punctuation-accessor": { "captures": { "1": { "name": "punctuation.accessor.ts" }, "2": { "name": "punctuation.accessor.optional.ts" } }, "match": "(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))" }, "punctuation-comma": { "match": ",", "name": "punctuation.separator.comma.ts" }, "punctuation-semicolon": { "match": ";", "name": "punctuation.terminator.statement.ts" }, "qstring-double": { "begin": '"', "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.ts" } }, "end": '(")|((?:[^\\\\\\n])$)', "endCaptures": { "1": { "name": "punctuation.definition.string.end.ts" }, "2": { "name": "invalid.illegal.newline.ts" } }, "name": "string.quoted.double.ts", "patterns": [{ "include": "#string-character-escape" }] }, "qstring-single": { "begin": "'", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.ts" } }, "end": "(\\')|((?:[^\\\\\\n])$)", "endCaptures": { "1": { "name": "punctuation.definition.string.end.ts" }, "2": { "name": "invalid.illegal.newline.ts" } }, "name": "string.quoted.single.ts", "patterns": [{ "include": "#string-character-escape" }] }, "regex": { "patterns": [{ "begin": "(?<!\\+\\+|--|})(?<=[=(:,\\[?+!]|^return|[^\\._$[:alnum:]]return|^case|[^\\._$[:alnum:]]case|=>|&&|\\|\\||\\*\\/)\\s*(\\/)(?![\\/*])(?=(?:[^\\/\\\\\\[\\()]|\\\\.|\\[([^\\]\\\\]|\\\\.)+\\]|\\(([^\\)\\\\]|\\\\.)+\\))+\\/([dgimsuy]+|(?![\\/\\*])|(?=\\/\\*))(?!\\s*[a-zA-Z0-9_$]))", "beginCaptures": { "1": { "name": "punctuation.definition.string.begin.ts" } }, "end": "(/)([dgimsuy]*)", "endCaptures": { "1": { "name": "punctuation.definition.string.end.ts" }, "2": { "name": "keyword.other.ts" } }, "name": "string.regexp.ts", "patterns": [{ "include": "#regexp" }] }, { "begin": "((?<![_$[:alnum:])\\]]|\\+\\+|--|}|\\*\\/)|((?<=^return|[^\\._$[:alnum:]]return|^case|[^\\._$[:alnum:]]case))\\s*)\\/(?![\\/*])(?=(?:[^\\/\\\\\\[]|\\\\.|\\[([^\\]\\\\]|\\\\.)*\\])+\\/([dgimsuy]+|(?![\\/\\*])|(?=\\/\\*))(?!\\s*[a-zA-Z0-9_$]))", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.ts" } }, "end": "(/)([dgimsuy]*)", "endCaptures": { "1": { "name": "punctuation.definition.string.end.ts" }, "2": { "name": "keyword.other.ts" } }, "name": "string.regexp.ts", "patterns": [{ "include": "#regexp" }] }] }, "regex-character-class": { "patterns": [{ "match": "\\\\[wWsSdDtrnvf]|\\.", "name": "constant.other.character-class.regexp" }, { "match": "\\\\([0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4})", "name": "constant.character.numeric.regexp" }, { "match": "\\\\c[A-Z]", "name": "constant.character.control.regexp" }, { "match": "\\\\.", "name": "constant.character.escape.backslash.regexp" }] }, "regexp": { "patterns": [{ "match": "\\\\[bB]|\\^|\\$", "name": "keyword.control.anchor.regexp" }, { "captures": { "0": { "name": "keyword.other.back-reference.regexp" }, "1": { "name": "variable.other.regexp" } }, "match": "\\\\[1-9]\\d*|\\\\k<([a-zA-Z_$][\\w$]*)>" }, { "match": "[?+*]|\\{(\\d+,\\d+|\\d+,|,\\d+|\\d+)\\}\\??", "name": "keyword.operator.quantifier.regexp" }, { "match": "\\|", "name": "keyword.operator.or.regexp" }, { "begin": "(\\()((\\?=)|(\\?!)|(\\?<=)|(\\?<!))", "beginCaptures": { "1": { "name": "punctuation.definition.group.regexp" }, "2": { "name": "punctuation.definition.group.assertion.regexp" }, "3": { "name": "meta.assertion.look-ahead.regexp" }, "4": { "name": "meta.assertion.negative-look-ahead.regexp" }, "5": { "name": "meta.assertion.look-behind.regexp" }, "6": { "name": "meta.assertion.negative-look-behind.regexp" } }, "end": "(\\))", "endCaptures": { "1": { "name": "punctuation.definition.group.regexp" } }, "name": "meta.group.assertion.regexp", "patterns": [{ "include": "#regexp" }] }, { "begin": "\\((?:(\\?:)|(?:\\?<([a-zA-Z_$][\\w$]*)>))?", "beginCaptures": { "0": { "name": "punctuation.definition.group.regexp" }, "1": { "name": "punctuation.definition.group.no-capture.regexp" }, "2": { "name": "variable.other.regexp" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.regexp" } }, "name": "meta.group.regexp", "patterns": [{ "include": "#regexp" }] }, { "begin": "(\\[)(\\^)?", "beginCaptures": { "1": { "name": "punctuation.definition.character-class.regexp" }, "2": { "name": "keyword.operator.negation.regexp" } }, "end": "(\\])", "endCaptures": { "1": { "name": "punctuation.definition.character-class.regexp" } }, "name": "constant.other.character-class.set.regexp", "patterns": [{ "captures": { "1": { "name": "constant.character.numeric.regexp" }, "2": { "name": "constant.character.control.regexp" }, "3": { "name": "constant.character.escape.backslash.regexp" }, "4": { "name": "constant.character.numeric.regexp" }, "5": { "name": "constant.character.control.regexp" }, "6": { "name": "constant.character.escape.backslash.regexp" } }, "match": "(?:.|(\\\\(?:[0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}))|(\\\\c[A-Z])|(\\\\.))\\-(?:[^\\]\\\\]|(\\\\(?:[0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}))|(\\\\c[A-Z])|(\\\\.))", "name": "constant.other.character-class.range.regexp" }, { "include": "#regex-character-class" }] }, { "include": "#regex-character-class" }] }, "return-type": { "patterns": [{ "begin": "(?<=\\))\\s*(:)(?=\\s*\\S)", "beginCaptures": { "1": { "name": "keyword.operator.type.annotation.ts" } }, "end": "(?<![:|&])(?=$|^|[{};,]|//)", "name": "meta.return.type.ts", "patterns": [{ "include": "#return-type-core" }] }, { "begin": "(?<=\\))\\s*(:)", "beginCaptures": { "1": { "name": "keyword.operator.type.annotation.ts" } }, "end": "(?<![:|&])((?=[{};,]|//|^\\s*$)|((?<=\\S)(?=\\s*$)))", "name": "meta.return.type.ts", "patterns": [{ "include": "#return-type-core" }] }] }, "return-type-core": { "patterns": [{ "include": "#comment" }, { "begin": "(?<=[:|&])(?=\\s*\\{)", "end": "(?<=\\})", "patterns": [{ "include": "#type-object" }] }, { "include": "#type-predicate-operator" }, { "include": "#type" }] }, "shebang": { "captures": { "1": { "name": "punctuation.definition.comment.ts" } }, "match": "\\A(#!).*(?=$)", "name": "comment.line.shebang.ts" }, "single-line-comment-consuming-line-ending": { "begin": "(^[ \\t]+)?((//)(?:\\s*((@)internal)(?=\\s|$))?)", "beginCaptures": { "1": { "name": "punctuation.whitespace.comment.leading.ts" }, "2": { "name": "comment.line.double-slash.ts" }, "3": { "name": "punctuation.definition.comment.ts" }, "4": { "name": "storage.type.internaldeclaration.ts" }, "5": { "name": "punctuation.decorator.internaldeclaration.ts" } }, "contentName": "comment.line.double-slash.ts", "end": "(?=^)" }, "statements": { "patterns": [{ "include": "#declaration" }, { "include": "#control-statement" }, { "include": "#after-operator-block-as-object-literal" }, { "include": "#decl-block" }, { "include": "#label" }, { "include": "#expression" }, { "include": "#punctuation-semicolon" }, { "include": "#string" }, { "include": "#comment" }] }, "string": { "patterns": [{ "include": "#qstring-single" }, { "include": "#qstring-double" }, { "include": "#template" }] }, "string-character-escape": { "match": "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|u\\{[0-9A-Fa-f]+\\}|[0-2][0-7]{0,2}|3[0-6][0-7]?|37[0-7]?|[4-7][0-7]?|.|$)", "name": "constant.character.escape.ts" }, "super-literal": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))super\\b(?!\\$)", "name": "variable.language.super.ts" }, "support-function-call-identifiers": { "patterns": [{ "include": "#literal" }, { "include": "#support-objects" }, { "include": "#object-identifiers" }, { "include": "#punctuation-accessor" }, { "match": "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))import(?=\\s*[\\(]\\s*[\\\"\\'\\`]))", "name": "keyword.operator.expression.import.ts" }] }, "support-objects": { "patterns": [{ "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(arguments)\\b(?!\\$)", "name": "variable.language.arguments.ts" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(Promise)\\b(?!\\$)", "name": "support.class.promise.ts" }, { "captures": { "1": { "name": "keyword.control.import.ts" }, "2": { "name": "punctuation.accessor.ts" }, "3": { "name": "punctuation.accessor.optional.ts" }, "4": { "name": "support.variable.property.importmeta.ts" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(import)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(meta)\\b(?!\\$)" }, { "captures": { "1": { "name": "keyword.operator.new.ts" }, "2": { "name": "punctuation.accessor.ts" }, "3": { "name": "punctuation.accessor.optional.ts" }, "4": { "name": "support.variable.property.target.ts" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(new)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(target)\\b(?!\\$)" }, { "captures": { "1": { "name": "punctuation.accessor.ts" }, "2": { "name": "punctuation.accessor.optional.ts" }, "3": { "name": "support.variable.property.ts" }, "4": { "name": "support.constant.ts" } }, "match": "(?x) (?:(\\.)|(\\?\\.(?!\\s*[[:digit:]]))) \\s* (?:\n  (?:(constructor|length|prototype|__proto__)\\b(?!\\$|\\s*(<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\\())\n  |\n  (?:(EPSILON|MAX_SAFE_INTEGER|MAX_VALUE|MIN_SAFE_INTEGER|MIN_VALUE|NEGATIVE_INFINITY|POSITIVE_INFINITY)\\b(?!\\$)))" }, { "captures": { "1": { "name": "support.type.object.module.ts" }, "2": { "name": "support.type.object.module.ts" }, "3": { "name": "punctuation.accessor.ts" }, "4": { "name": "punctuation.accessor.optional.ts" }, "5": { "name": "support.type.object.module.ts" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(exports)|(module)(?:(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))(exports|id|filename|loaded|parent|children))?)\\b(?!\\$)" }] }, "switch-statement": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?=\\bswitch\\s*\\()", "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.ts" } }, "name": "switch-statement.expr.ts", "patterns": [{ "include": "#comment" }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(switch)\\s*(\\()", "beginCaptures": { "1": { "name": "keyword.control.switch.ts" }, "2": { "name": "meta.brace.round.ts" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.ts" } }, "name": "switch-expression.expr.ts", "patterns": [{ "include": "#expression" }] }, { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.block.ts" } }, "end": "(?=\\})", "name": "switch-block.expr.ts", "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(case|default(?=:))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "1": { "name": "keyword.control.switch.ts" } }, "end": "(?=:)", "name": "case-clause.expr.ts", "patterns": [{ "include": "#expression" }] }, { "begin": "(:)\\s*(\\{)", "beginCaptures": { "1": { "name": "case-clause.expr.ts punctuation.definition.section.case-statement.ts" }, "2": { "name": "meta.block.ts punctuation.definition.block.ts" } }, "contentName": "meta.block.ts", "end": "\\}", "endCaptures": { "0": { "name": "meta.block.ts punctuation.definition.block.ts" } }, "patterns": [{ "include": "#statements" }] }, { "captures": { "0": { "name": "case-clause.expr.ts punctuation.definition.section.case-statement.ts" } }, "match": "(:)" }, { "include": "#statements" }] }] }, "template": { "patterns": [{ "include": "#template-call" }, { "begin": "([_$[:alpha:]][_$[:alnum:]]*)?(`)", "beginCaptures": { "1": { "name": "entity.name.function.tagged-template.ts" }, "2": { "name": "string.template.ts punctuation.definition.string.template.begin.ts" } }, "contentName": "string.template.ts", "end": "`", "endCaptures": { "0": { "name": "string.template.ts punctuation.definition.string.template.end.ts" } }, "patterns": [{ "include": "#template-substitution-element" }, { "include": "#string-character-escape" }] }] }, "template-call": { "patterns": [{ "begin": "(?=(([_$[:alpha:]][_$[:alnum:]]*\\s*\\??\\.\\s*)*|(\\??\\.\\s*)?)([_$[:alpha:]][_$[:alnum:]]*)(<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?`)", "end": "(?=`)", "patterns": [{ "begin": "(?=(([_$[:alpha:]][_$[:alnum:]]*\\s*\\??\\.\\s*)*|(\\??\\.\\s*)?)([_$[:alpha:]][_$[:alnum:]]*))", "end": "(?=(<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?`)", "patterns": [{ "include": "#support-function-call-identifiers" }, { "match": "([_$[:alpha:]][_$[:alnum:]]*)", "name": "entity.name.function.tagged-template.ts" }] }, { "include": "#type-arguments" }] }, { "begin": "([_$[:alpha:]][_$[:alnum:]]*)?\\s*(?=(<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)`)", "beginCaptures": { "1": { "name": "entity.name.function.tagged-template.ts" } }, "end": "(?=`)", "patterns": [{ "include": "#type-arguments" }] }] }, "template-substitution-element": { "begin": "\\$\\{", "beginCaptures": { "0": { "name": "punctuation.definition.template-expression.begin.ts" } }, "contentName": "meta.embedded.line.ts", "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.template-expression.end.ts" } }, "name": "meta.template.expression.ts", "patterns": [{ "include": "#expression" }] }, "template-type": { "patterns": [{ "include": "#template-call" }, { "begin": "([_$[:alpha:]][_$[:alnum:]]*)?(`)", "beginCaptures": { "1": { "name": "entity.name.function.tagged-template.ts" }, "2": { "name": "string.template.ts punctuation.definition.string.template.begin.ts" } }, "contentName": "string.template.ts", "end": "`", "endCaptures": { "0": { "name": "string.template.ts punctuation.definition.string.template.end.ts" } }, "patterns": [{ "include": "#template-type-substitution-element" }, { "include": "#string-character-escape" }] }] }, "template-type-substitution-element": { "begin": "\\$\\{", "beginCaptures": { "0": { "name": "punctuation.definition.template-expression.begin.ts" } }, "contentName": "meta.embedded.line.ts", "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.template-expression.end.ts" } }, "name": "meta.template.expression.ts", "patterns": [{ "include": "#type" }] }, "ternary-expression": { "begin": "(?!\\?\\.\\s*[^[:digit:]])(\\?)(?!\\?)", "beginCaptures": { "1": { "name": "keyword.operator.ternary.ts" } }, "end": "\\s*(:)", "endCaptures": { "1": { "name": "keyword.operator.ternary.ts" } }, "patterns": [{ "include": "#expression" }] }, "this-literal": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))this\\b(?!\\$)", "name": "variable.language.this.ts" }, "type": { "patterns": [{ "include": "#comment" }, { "include": "#type-string" }, { "include": "#numeric-literal" }, { "include": "#type-primitive" }, { "include": "#type-builtin-literals" }, { "include": "#type-parameters" }, { "include": "#type-tuple" }, { "include": "#type-object" }, { "include": "#type-operators" }, { "include": "#type-conditional" }, { "include": "#type-fn-type-parameters" }, { "include": "#type-paren-or-function-parameters" }, { "include": "#type-function-return-type" }, { "captures": { "1": { "name": "storage.modifier.ts" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(readonly)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*" }, { "include": "#type-name" }] }, "type-alias-declaration": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(type)\\b\\s+([_$[:alpha:]][_$[:alnum:]]*)\\s*", "beginCaptures": { "1": { "name": "keyword.control.export.ts" }, "2": { "name": "storage.modifier.ts" }, "3": { "name": "storage.type.type.ts" }, "4": { "name": "entity.name.type.alias.ts" } }, "end": "(?=\\}|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "name": "meta.type.declaration.ts", "patterns": [{ "include": "#comment" }, { "include": "#type-parameters" }, { "begin": "(=)\\s*(intrinsic)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "1": { "name": "keyword.operator.assignment.ts" }, "2": { "name": "keyword.control.intrinsic.ts" } }, "end": "(?=\\}|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "patterns": [{ "include": "#type" }] }, { "begin": "(=)\\s*", "beginCaptures": { "1": { "name": "keyword.operator.assignment.ts" } }, "end": "(?=\\}|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "patterns": [{ "include": "#type" }] }] }, "type-annotation": { "patterns": [{ "begin": "(:)(?=\\s*\\S)", "beginCaptures": { "1": { "name": "keyword.operator.type.annotation.ts" } }, "end": "(?<![:|&])(?!\\s*[|&]\\s+)((?=^|[,);\\}\\]]|//)|(?==[^>])|((?<=[\\}>\\]\\)]|[_$[:alpha:]])\\s*(?=\\{)))", "name": "meta.type.annotation.ts", "patterns": [{ "include": "#type" }] }, { "begin": "(:)", "beginCaptures": { "1": { "name": "keyword.operator.type.annotation.ts" } }, "end": "(?<![:|&])((?=[,);\\}\\]]|\\/\\/)|(?==[^>])|(?=^\\s*$)|((?<=[\\}>\\]\\)]|[_$[:alpha:]])\\s*(?=\\{)))", "name": "meta.type.annotation.ts", "patterns": [{ "include": "#type" }] }] }, "type-arguments": { "begin": "\\<", "beginCaptures": { "0": { "name": "punctuation.definition.typeparameters.begin.ts" } }, "end": "\\>", "endCaptures": { "0": { "name": "punctuation.definition.typeparameters.end.ts" } }, "name": "meta.type.parameters.ts", "patterns": [{ "include": "#type-arguments-body" }] }, "type-arguments-body": { "patterns": [{ "captures": { "0": { "name": "keyword.operator.type.ts" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(_)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))" }, { "include": "#type" }, { "include": "#punctuation-comma" }] }, "type-builtin-literals": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(this|true|false|undefined|null|object)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "support.type.builtin.ts" }, "type-conditional": { "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(extends)\\s+", "beginCaptures": { "1": { "name": "storage.modifier.ts" } }, "end": "(?<=:)", "patterns": [{ "begin": "\\?", "beginCaptures": { "0": { "name": "keyword.operator.ternary.ts" } }, "end": ":", "endCaptures": { "0": { "name": "keyword.operator.ternary.ts" } }, "patterns": [{ "include": "#type" }] }, { "include": "#type" }] }] }, "type-fn-type-parameters": { "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(abstract)\\s+)?(new)\\b(?=\\s*\\<)", "beginCaptures": { "1": { "name": "meta.type.constructor.ts storage.modifier.ts" }, "2": { "name": "meta.type.constructor.ts keyword.control.new.ts" } }, "end": "(?<=>)", "patterns": [{ "include": "#comment" }, { "include": "#type-parameters" }] }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(abstract)\\s+)?(new)\\b\\s*(?=\\()", "beginCaptures": { "1": { "name": "storage.modifier.ts" }, "2": { "name": "keyword.control.new.ts" } }, "end": "(?<=\\))", "name": "meta.type.constructor.ts", "patterns": [{ "include": "#function-parameters" }] }, { "begin": "(?x)(\n  (?=\n    [(]\\s*(\n      ([)]) |\n      (\\.\\.\\.) |\n      ([_$[:alnum:]]+\\s*(\n        ([:,?=])|\n        ([)]\\s*=>)\n      ))\n    )\n  )\n)", "end": "(?<=\\))", "name": "meta.type.function.ts", "patterns": [{ "include": "#function-parameters" }] }] }, "type-function-return-type": { "patterns": [{ "begin": "(=>)(?=\\s*\\S)", "beginCaptures": { "1": { "name": "storage.type.function.arrow.ts" } }, "end": "(?<!=>)(?<![|&])(?=[,\\]\\)\\{\\}=;>:\\?]|//|$)", "name": "meta.type.function.return.ts", "patterns": [{ "include": "#type-function-return-type-core" }] }, { "begin": "=>", "beginCaptures": { "0": { "name": "storage.type.function.arrow.ts" } }, "end": "(?<!=>)(?<![|&])((?=[,\\]\\)\\{\\}=;:\\?>]|//|^\\s*$)|((?<=\\S)(?=\\s*$)))", "name": "meta.type.function.return.ts", "patterns": [{ "include": "#type-function-return-type-core" }] }] }, "type-function-return-type-core": { "patterns": [{ "include": "#comment" }, { "begin": "(?<==>)(?=\\s*\\{)", "end": "(?<=\\})", "patterns": [{ "include": "#type-object" }] }, { "include": "#type-predicate-operator" }, { "include": "#type" }] }, "type-infer": { "patterns": [{ "captures": { "1": { "name": "keyword.operator.expression.infer.ts" }, "2": { "name": "entity.name.type.ts" }, "3": { "name": "keyword.operator.expression.extends.ts" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(infer)\\s+([_$[:alpha:]][_$[:alnum:]]*)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?:\\s+(extends)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))?", "name": "meta.type.infer.ts" }] }, "type-name": { "patterns": [{ "begin": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(<)", "captures": { "1": { "name": "entity.name.type.module.ts" }, "2": { "name": "punctuation.accessor.ts" }, "3": { "name": "punctuation.accessor.optional.ts" }, "4": { "name": "meta.type.parameters.ts punctuation.definition.typeparameters.begin.ts" } }, "contentName": "meta.type.parameters.ts", "end": "(>)", "endCaptures": { "1": { "name": "meta.type.parameters.ts punctuation.definition.typeparameters.end.ts" } }, "patterns": [{ "include": "#type-arguments-body" }] }, { "begin": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(<)", "beginCaptures": { "1": { "name": "entity.name.type.ts" }, "2": { "name": "meta.type.parameters.ts punctuation.definition.typeparameters.begin.ts" } }, "contentName": "meta.type.parameters.ts", "end": "(>)", "endCaptures": { "1": { "name": "meta.type.parameters.ts punctuation.definition.typeparameters.end.ts" } }, "patterns": [{ "include": "#type-arguments-body" }] }, { "captures": { "1": { "name": "entity.name.type.module.ts" }, "2": { "name": "punctuation.accessor.ts" }, "3": { "name": "punctuation.accessor.optional.ts" } }, "match": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))" }, { "match": "[_$[:alpha:]][_$[:alnum:]]*", "name": "entity.name.type.ts" }] }, "type-object": { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.block.ts" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.ts" } }, "name": "meta.object.type.ts", "patterns": [{ "include": "#comment" }, { "include": "#method-declaration" }, { "include": "#indexer-declaration" }, { "include": "#indexer-mapped-type-declaration" }, { "include": "#field-declaration" }, { "include": "#type-annotation" }, { "begin": "\\.\\.\\.", "beginCaptures": { "0": { "name": "keyword.operator.spread.ts" } }, "end": "(?=\\}|;|,|$)|(?<=\\})", "patterns": [{ "include": "#type" }] }, { "include": "#punctuation-comma" }, { "include": "#punctuation-semicolon" }, { "include": "#type" }] }, "type-operators": { "patterns": [{ "include": "#typeof-operator" }, { "include": "#type-infer" }, { "begin": "([&|])(?=\\s*\\{)", "beginCaptures": { "0": { "name": "keyword.operator.type.ts" } }, "end": "(?<=\\})", "patterns": [{ "include": "#type-object" }] }, { "begin": "[&|]", "beginCaptures": { "0": { "name": "keyword.operator.type.ts" } }, "end": "(?=\\S)" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))keyof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.operator.expression.keyof.ts" }, { "match": "(\\?|\\:)", "name": "keyword.operator.ternary.ts" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))import(?=\\s*\\()", "name": "keyword.operator.expression.import.ts" }] }, "type-parameters": { "begin": "(<)", "beginCaptures": { "1": { "name": "punctuation.definition.typeparameters.begin.ts" } }, "end": "(>)", "endCaptures": { "1": { "name": "punctuation.definition.typeparameters.end.ts" } }, "name": "meta.type.parameters.ts", "patterns": [{ "include": "#comment" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(extends|in|out|const)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "storage.modifier.ts" }, { "include": "#type" }, { "include": "#punctuation-comma" }, { "match": "(=)(?!>)", "name": "keyword.operator.assignment.ts" }] }, "type-paren-or-function-parameters": { "begin": "\\(", "beginCaptures": { "0": { "name": "meta.brace.round.ts" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.ts" } }, "name": "meta.type.paren.cover.ts", "patterns": [{ "captures": { "1": { "name": "storage.modifier.ts" }, "2": { "name": "keyword.operator.rest.ts" }, "3": { "name": "entity.name.function.ts variable.language.this.ts" }, "4": { "name": "entity.name.function.ts" }, "5": { "name": "keyword.operator.optional.ts" } }, "match": "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))\\s*(\\??)(?=\\s*(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))))" }, { "captures": { "1": { "name": "storage.modifier.ts" }, "2": { "name": "keyword.operator.rest.ts" }, "3": { "name": "variable.parameter.ts variable.language.this.ts" }, "4": { "name": "variable.parameter.ts" }, "5": { "name": "keyword.operator.optional.ts" } }, "match": "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))\\s*(\\??)(?=:)" }, { "include": "#type-annotation" }, { "match": ",", "name": "punctuation.separator.parameter.ts" }, { "include": "#type" }] }, "type-predicate-operator": { "patterns": [{ "captures": { "1": { "name": "keyword.operator.type.asserts.ts" }, "2": { "name": "variable.parameter.ts variable.language.this.ts" }, "3": { "name": "variable.parameter.ts" }, "4": { "name": "keyword.operator.expression.is.ts" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(asserts)\\s+)?(?!asserts)(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))\\s(is)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))" }, { "captures": { "1": { "name": "keyword.operator.type.asserts.ts" }, "2": { "name": "variable.parameter.ts variable.language.this.ts" }, "3": { "name": "variable.parameter.ts" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(asserts)\\s+(?!is)(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))asserts(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.operator.type.asserts.ts" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))is(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.operator.expression.is.ts" }] }, "type-primitive": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(string|number|bigint|boolean|symbol|any|void|never|unknown)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "support.type.primitive.ts" }, "type-string": { "patterns": [{ "include": "#qstring-single" }, { "include": "#qstring-double" }, { "include": "#template-type" }] }, "type-tuple": { "begin": "\\[", "beginCaptures": { "0": { "name": "meta.brace.square.ts" } }, "end": "\\]", "endCaptures": { "0": { "name": "meta.brace.square.ts" } }, "name": "meta.type.tuple.ts", "patterns": [{ "match": "\\.\\.\\.", "name": "keyword.operator.rest.ts" }, { "captures": { "1": { "name": "entity.name.label.ts" }, "2": { "name": "keyword.operator.optional.ts" }, "3": { "name": "punctuation.separator.label.ts" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))([_$[:alpha:]][_$[:alnum:]]*)\\s*(\\?)?\\s*(:)" }, { "include": "#type" }, { "include": "#punctuation-comma" }] }, "typeof-operator": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))typeof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "0": { "name": "keyword.operator.expression.typeof.ts" } }, "end": "(?=[,);}\\]=>:&|{\\?]|(extends\\s+)|$|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "patterns": [{ "include": "#type-arguments" }, { "include": "#expression" }] }, "undefined-literal": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))undefined(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "constant.language.undefined.ts" }, "var-expr": { "patterns": [{ "begin": "(?=(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(var|let)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))", "end": "(?!(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(var|let)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))((?=^|;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))|((?<!^let|[^\\._$[:alnum:]]let|^var|[^\\._$[:alnum:]]var)(?=\\s*$)))", "name": "meta.var.expr.ts", "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(var|let)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*", "beginCaptures": { "1": { "name": "keyword.control.export.ts" }, "2": { "name": "storage.modifier.ts" }, "3": { "name": "storage.type.ts" } }, "end": "(?=\\S)" }, { "include": "#destructuring-variable" }, { "include": "#var-single-variable" }, { "include": "#variable-initializer" }, { "include": "#comment" }, { "begin": "(,)\\s*(?=$|\\/\\/)", "beginCaptures": { "1": { "name": "punctuation.separator.comma.ts" } }, "end": "(?<!,)(((?==|;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|^\\s*$))|((?<=\\S)(?=\\s*$)))", "patterns": [{ "include": "#single-line-comment-consuming-line-ending" }, { "include": "#comment" }, { "include": "#destructuring-variable" }, { "include": "#var-single-variable" }, { "include": "#punctuation-comma" }] }, { "include": "#punctuation-comma" }] }, { "begin": "(?=(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(const(?!\\s+enum\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))", "beginCaptures": { "1": { "name": "keyword.control.export.ts" }, "2": { "name": "storage.modifier.ts" }, "3": { "name": "storage.type.ts" } }, "end": "(?!(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(const(?!\\s+enum\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))((?=^|;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))|((?<!^const|[^\\._$[:alnum:]]const)(?=\\s*$)))", "name": "meta.var.expr.ts", "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(const(?!\\s+enum\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*", "beginCaptures": { "1": { "name": "keyword.control.export.ts" }, "2": { "name": "storage.modifier.ts" }, "3": { "name": "storage.type.ts" } }, "end": "(?=\\S)" }, { "include": "#destructuring-const" }, { "include": "#var-single-const" }, { "include": "#variable-initializer" }, { "include": "#comment" }, { "begin": "(,)\\s*(?=$|\\/\\/)", "beginCaptures": { "1": { "name": "punctuation.separator.comma.ts" } }, "end": "(?<!,)(((?==|;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|^\\s*$))|((?<=\\S)(?=\\s*$)))", "patterns": [{ "include": "#single-line-comment-consuming-line-ending" }, { "include": "#comment" }, { "include": "#destructuring-const" }, { "include": "#var-single-const" }, { "include": "#punctuation-comma" }] }, { "include": "#punctuation-comma" }] }, { "begin": "(?=(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b((?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))", "beginCaptures": { "1": { "name": "keyword.control.export.ts" }, "2": { "name": "storage.modifier.ts" }, "3": { "name": "storage.type.ts" } }, "end": "(?!(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b((?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))((?=;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))|((?<!^using|[^\\._$[:alnum:]]using|^await\\s+using|[^\\._$[:alnum:]]await\\s+using)(?=\\s*$)))", "name": "meta.var.expr.ts", "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b((?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*", "beginCaptures": { "1": { "name": "keyword.control.export.ts" }, "2": { "name": "storage.modifier.ts" }, "3": { "name": "storage.type.ts" } }, "end": "(?=\\S)" }, { "include": "#var-single-const" }, { "include": "#variable-initializer" }, { "include": "#comment" }, { "begin": "(,)\\s*((?!\\S)|(?=\\/\\/))", "beginCaptures": { "1": { "name": "punctuation.separator.comma.ts" } }, "end": "(?<!,)(((?==|;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|^\\s*$))|((?<=\\S)(?=\\s*$)))", "patterns": [{ "include": "#single-line-comment-consuming-line-ending" }, { "include": "#comment" }, { "include": "#var-single-const" }, { "include": "#punctuation-comma" }] }, { "include": "#punctuation-comma" }] }] }, "var-single-const": { "patterns": [{ "begin": "(?x)([_$[:alpha:]][_$[:alnum:]]*)(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))", "beginCaptures": { "1": { "name": "meta.definition.variable.ts variable.other.constant.ts entity.name.function.ts" } }, "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|(;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b)))", "name": "meta.var-single-variable.expr.ts", "patterns": [{ "include": "#var-single-variable-type-annotation" }] }, { "begin": "([_$[:alpha:]][_$[:alnum:]]*)", "beginCaptures": { "1": { "name": "meta.definition.variable.ts variable.other.constant.ts" } }, "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|(;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b)))", "name": "meta.var-single-variable.expr.ts", "patterns": [{ "include": "#var-single-variable-type-annotation" }] }] }, "var-single-variable": { "patterns": [{ "begin": "(?x)([_$[:alpha:]][_$[:alnum:]]*)(\\!)?(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))", "beginCaptures": { "1": { "name": "meta.definition.variable.ts entity.name.function.ts" }, "2": { "name": "keyword.operator.definiteassignment.ts" } }, "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|(;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b)))", "name": "meta.var-single-variable.expr.ts", "patterns": [{ "include": "#var-single-variable-type-annotation" }] }, { "begin": "([[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])(\\!)?", "beginCaptures": { "1": { "name": "meta.definition.variable.ts variable.other.constant.ts" }, "2": { "name": "keyword.operator.definiteassignment.ts" } }, "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|(;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b)))", "name": "meta.var-single-variable.expr.ts", "patterns": [{ "include": "#var-single-variable-type-annotation" }] }, { "begin": "([_$[:alpha:]][_$[:alnum:]]*)(\\!)?", "beginCaptures": { "1": { "name": "meta.definition.variable.ts variable.other.readwrite.ts" }, "2": { "name": "keyword.operator.definiteassignment.ts" } }, "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|(;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b)))", "name": "meta.var-single-variable.expr.ts", "patterns": [{ "include": "#var-single-variable-type-annotation" }] }] }, "var-single-variable-type-annotation": { "patterns": [{ "include": "#type-annotation" }, { "include": "#string" }, { "include": "#comment" }] }, "variable-initializer": { "patterns": [{ "begin": "(?<!=|!)(=)(?!=)(?=\\s*\\S)(?!\\s*.*=>\\s*$)", "beginCaptures": { "1": { "name": "keyword.operator.assignment.ts" } }, "end": "(?=$|^|[,);}\\]]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))", "patterns": [{ "include": "#expression" }] }, { "begin": "(?<!=|!)(=)(?!=)", "beginCaptures": { "1": { "name": "keyword.operator.assignment.ts" } }, "end": "(?=[,);}\\]]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))|(?=^\\s*$)|(?<![\\|\\&\\+\\-\\*\\/])(?<=\\S)(?<!=)(?=\\s*$)", "patterns": [{ "include": "#expression" }] }] } }, "scopeName": "source.ts", "aliases": ["ts"] });
var typescript = [
  lang$d
];
var lang$c = Object.freeze({ "displayName": "JSX", "name": "jsx", "patterns": [{ "include": "#directives" }, { "include": "#statements" }, { "include": "#shebang" }], "repository": { "access-modifier": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(abstract|declare|override|public|protected|private|readonly|static)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "storage.modifier.js.jsx" }, "after-operator-block-as-object-literal": { "begin": "(?<!\\+\\+|--)(?<=[:=(,\\[?+!>]|^await|[^\\._$[:alnum:]]await|^return|[^\\._$[:alnum:]]return|^yield|[^\\._$[:alnum:]]yield|^throw|[^\\._$[:alnum:]]throw|^in|[^\\._$[:alnum:]]in|^of|[^\\._$[:alnum:]]of|^typeof|[^\\._$[:alnum:]]typeof|&&|\\|\\||\\*)\\s*(\\{)", "beginCaptures": { "1": { "name": "punctuation.definition.block.js.jsx" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.js.jsx" } }, "name": "meta.objectliteral.js.jsx", "patterns": [{ "include": "#object-member" }] }, "array-binding-pattern": { "begin": "(?:(\\.\\.\\.)\\s*)?(\\[)", "beginCaptures": { "1": { "name": "keyword.operator.rest.js.jsx" }, "2": { "name": "punctuation.definition.binding-pattern.array.js.jsx" } }, "end": "\\]", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.array.js.jsx" } }, "patterns": [{ "include": "#binding-element" }, { "include": "#punctuation-comma" }] }, "array-binding-pattern-const": { "begin": "(?:(\\.\\.\\.)\\s*)?(\\[)", "beginCaptures": { "1": { "name": "keyword.operator.rest.js.jsx" }, "2": { "name": "punctuation.definition.binding-pattern.array.js.jsx" } }, "end": "\\]", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.array.js.jsx" } }, "patterns": [{ "include": "#binding-element-const" }, { "include": "#punctuation-comma" }] }, "array-literal": { "begin": "\\s*(\\[)", "beginCaptures": { "1": { "name": "meta.brace.square.js.jsx" } }, "end": "\\]", "endCaptures": { "0": { "name": "meta.brace.square.js.jsx" } }, "name": "meta.array.literal.js.jsx", "patterns": [{ "include": "#expression" }, { "include": "#punctuation-comma" }] }, "arrow-function": { "patterns": [{ "captures": { "1": { "name": "storage.modifier.async.js.jsx" }, "2": { "name": "variable.parameter.js.jsx" } }, "match": "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(\\basync)\\s+)?([_$[:alpha:]][_$[:alnum:]]*)\\s*(?==>)", "name": "meta.arrow.js.jsx" }, { "begin": "(?x) (?:\n  (?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(\\basync)\n)? ((?<![})!\\]])\\s*\n  (?=\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  )\n)", "beginCaptures": { "1": { "name": "storage.modifier.async.js.jsx" } }, "end": "(?==>|\\{|(^\\s*(export|function|class|interface|let|var|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|const|import|enum|namespace|module|type|abstract|declare)\\s+))", "name": "meta.arrow.js.jsx", "patterns": [{ "include": "#comment" }, { "include": "#type-parameters" }, { "include": "#function-parameters" }, { "include": "#arrow-return-type" }, { "include": "#possibly-arrow-return-type" }] }, { "begin": "=>", "beginCaptures": { "0": { "name": "storage.type.function.arrow.js.jsx" } }, "end": "((?<=\\}|\\S)(?<!=>)|((?!\\{)(?=\\S)))(?!\\/[\\/\\*])", "name": "meta.arrow.js.jsx", "patterns": [{ "include": "#single-line-comment-consuming-line-ending" }, { "include": "#decl-block" }, { "include": "#expression" }] }] }, "arrow-return-type": { "begin": "(?<=\\))\\s*(:)", "beginCaptures": { "1": { "name": "keyword.operator.type.annotation.js.jsx" } }, "end": "(?==>|\\{|(^\\s*(export|function|class|interface|let|var|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|const|import|enum|namespace|module|type|abstract|declare)\\s+))", "name": "meta.return.type.arrow.js.jsx", "patterns": [{ "include": "#arrow-return-type-body" }] }, "arrow-return-type-body": { "patterns": [{ "begin": "(?<=[:])(?=\\s*\\{)", "end": "(?<=\\})", "patterns": [{ "include": "#type-object" }] }, { "include": "#type-predicate-operator" }, { "include": "#type" }] }, "async-modifier": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(async)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "storage.modifier.async.js.jsx" }, "binding-element": { "patterns": [{ "include": "#comment" }, { "include": "#string" }, { "include": "#numeric-literal" }, { "include": "#regex" }, { "include": "#object-binding-pattern" }, { "include": "#array-binding-pattern" }, { "include": "#destructuring-variable-rest" }, { "include": "#variable-initializer" }] }, "binding-element-const": { "patterns": [{ "include": "#comment" }, { "include": "#string" }, { "include": "#numeric-literal" }, { "include": "#regex" }, { "include": "#object-binding-pattern-const" }, { "include": "#array-binding-pattern-const" }, { "include": "#destructuring-variable-rest-const" }, { "include": "#variable-initializer" }] }, "boolean-literal": { "patterns": [{ "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))true(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "constant.language.boolean.true.js.jsx" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))false(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "constant.language.boolean.false.js.jsx" }] }, "brackets": { "patterns": [{ "begin": "{", "end": "}|(?=\\*/)", "patterns": [{ "include": "#brackets" }] }, { "begin": "\\[", "end": "\\]|(?=\\*/)", "patterns": [{ "include": "#brackets" }] }] }, "cast": { "patterns": [{ "include": "#jsx" }] }, "class-declaration": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(?:(abstract)\\s+)?\\b(class)\\b(?=\\s+|/[/*])", "beginCaptures": { "1": { "name": "keyword.control.export.js.jsx" }, "2": { "name": "storage.modifier.js.jsx" }, "3": { "name": "storage.modifier.js.jsx" }, "4": { "name": "storage.type.class.js.jsx" } }, "end": "(?<=\\})", "name": "meta.class.js.jsx", "patterns": [{ "include": "#class-declaration-or-expression-patterns" }] }, "class-declaration-or-expression-patterns": { "patterns": [{ "include": "#comment" }, { "include": "#class-or-interface-heritage" }, { "captures": { "0": { "name": "entity.name.type.class.js.jsx" } }, "match": "[_$[:alpha:]][_$[:alnum:]]*" }, { "include": "#type-parameters" }, { "include": "#class-or-interface-body" }] }, "class-expression": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(abstract)\\s+)?(class)\\b(?=\\s+|[<{]|\\/[\\/*])", "beginCaptures": { "1": { "name": "storage.modifier.js.jsx" }, "2": { "name": "storage.type.class.js.jsx" } }, "end": "(?<=\\})", "name": "meta.class.js.jsx", "patterns": [{ "include": "#class-declaration-or-expression-patterns" }] }, "class-or-interface-body": { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.block.js.jsx" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.js.jsx" } }, "patterns": [{ "include": "#comment" }, { "include": "#decorator" }, { "begin": "(?<=:)\\s*", "end": "(?=\\s|[;),}\\]:\\-\\+]|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "patterns": [{ "include": "#expression" }] }, { "include": "#method-declaration" }, { "include": "#indexer-declaration" }, { "include": "#field-declaration" }, { "include": "#string" }, { "include": "#type-annotation" }, { "include": "#variable-initializer" }, { "include": "#access-modifier" }, { "include": "#property-accessor" }, { "include": "#async-modifier" }, { "include": "#after-operator-block-as-object-literal" }, { "include": "#decl-block" }, { "include": "#expression" }, { "include": "#punctuation-comma" }, { "include": "#punctuation-semicolon" }] }, "class-or-interface-heritage": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(extends|implements)\\b)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "1": { "name": "storage.modifier.js.jsx" } }, "end": "(?=\\{)", "patterns": [{ "include": "#comment" }, { "include": "#class-or-interface-heritage" }, { "include": "#type-parameters" }, { "include": "#expressionWithoutIdentifiers" }, { "captures": { "1": { "name": "entity.name.type.module.js.jsx" }, "2": { "name": "punctuation.accessor.js.jsx" }, "3": { "name": "punctuation.accessor.optional.js.jsx" } }, "match": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))(?=\\s*[_$[:alpha:]][_$[:alnum:]]*(\\s*\\??\\.\\s*[_$[:alpha:]][_$[:alnum:]]*)*\\s*)" }, { "captures": { "1": { "name": "entity.other.inherited-class.js.jsx" } }, "match": "([_$[:alpha:]][_$[:alnum:]]*)" }, { "include": "#expressionPunctuations" }] }, "comment": { "patterns": [{ "begin": "/\\*\\*(?!/)", "beginCaptures": { "0": { "name": "punctuation.definition.comment.js.jsx" } }, "end": "\\*/", "endCaptures": { "0": { "name": "punctuation.definition.comment.js.jsx" } }, "name": "comment.block.documentation.js.jsx", "patterns": [{ "include": "#docblock" }] }, { "begin": "(/\\*)(?:\\s*((@)internal)(?=\\s|(\\*/)))?", "beginCaptures": { "1": { "name": "punctuation.definition.comment.js.jsx" }, "2": { "name": "storage.type.internaldeclaration.js.jsx" }, "3": { "name": "punctuation.decorator.internaldeclaration.js.jsx" } }, "end": "\\*/", "endCaptures": { "0": { "name": "punctuation.definition.comment.js.jsx" } }, "name": "comment.block.js.jsx" }, { "begin": "(^[ \\t]+)?((//)(?:\\s*((@)internal)(?=\\s|$))?)", "beginCaptures": { "1": { "name": "punctuation.whitespace.comment.leading.js.jsx" }, "2": { "name": "comment.line.double-slash.js.jsx" }, "3": { "name": "punctuation.definition.comment.js.jsx" }, "4": { "name": "storage.type.internaldeclaration.js.jsx" }, "5": { "name": "punctuation.decorator.internaldeclaration.js.jsx" } }, "contentName": "comment.line.double-slash.js.jsx", "end": "(?=$)" }] }, "control-statement": { "patterns": [{ "include": "#switch-statement" }, { "include": "#for-loop" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(catch|finally|throw|try)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.control.trycatch.js.jsx" }, { "captures": { "1": { "name": "keyword.control.loop.js.jsx" }, "2": { "name": "entity.name.label.js.jsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(break|continue|goto)\\s+([_$[:alpha:]][_$[:alnum:]]*)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(break|continue|do|goto|while)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.control.loop.js.jsx" }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(return)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "0": { "name": "keyword.control.flow.js.jsx" } }, "end": "(?=[;}]|$|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "patterns": [{ "include": "#expression" }] }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(case|default|switch)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.control.switch.js.jsx" }, { "include": "#if-statement" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(else|if)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.control.conditional.js.jsx" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(with)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.control.with.js.jsx" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(package)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.control.js.jsx" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(debugger)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.other.debugger.js.jsx" }] }, "decl-block": { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.block.js.jsx" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.js.jsx" } }, "name": "meta.block.js.jsx", "patterns": [{ "include": "#statements" }] }, "declaration": { "patterns": [{ "include": "#decorator" }, { "include": "#var-expr" }, { "include": "#function-declaration" }, { "include": "#class-declaration" }, { "include": "#interface-declaration" }, { "include": "#enum-declaration" }, { "include": "#namespace-declaration" }, { "include": "#type-alias-declaration" }, { "include": "#import-equals-declaration" }, { "include": "#import-declaration" }, { "include": "#export-declaration" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(declare|export)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "storage.modifier.js.jsx" }] }, "decorator": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))\\@", "beginCaptures": { "0": { "name": "punctuation.decorator.js.jsx" } }, "end": "(?=\\s)", "name": "meta.decorator.js.jsx", "patterns": [{ "include": "#expression" }] }, "destructuring-const": { "patterns": [{ "begin": "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\{)", "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))", "name": "meta.object-binding-pattern-variable.js.jsx", "patterns": [{ "include": "#object-binding-pattern-const" }, { "include": "#type-annotation" }, { "include": "#comment" }] }, { "begin": "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\[)", "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))", "name": "meta.array-binding-pattern-variable.js.jsx", "patterns": [{ "include": "#array-binding-pattern-const" }, { "include": "#type-annotation" }, { "include": "#comment" }] }] }, "destructuring-parameter": { "patterns": [{ "begin": "(?<!=|:)\\s*(?:(\\.\\.\\.)\\s*)?(\\{)", "beginCaptures": { "1": { "name": "keyword.operator.rest.js.jsx" }, "2": { "name": "punctuation.definition.binding-pattern.object.js.jsx" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.object.js.jsx" } }, "name": "meta.parameter.object-binding-pattern.js.jsx", "patterns": [{ "include": "#parameter-object-binding-element" }] }, { "begin": "(?<!=|:)\\s*(?:(\\.\\.\\.)\\s*)?(\\[)", "beginCaptures": { "1": { "name": "keyword.operator.rest.js.jsx" }, "2": { "name": "punctuation.definition.binding-pattern.array.js.jsx" } }, "end": "\\]", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.array.js.jsx" } }, "name": "meta.paramter.array-binding-pattern.js.jsx", "patterns": [{ "include": "#parameter-binding-element" }, { "include": "#punctuation-comma" }] }] }, "destructuring-parameter-rest": { "captures": { "1": { "name": "keyword.operator.rest.js.jsx" }, "2": { "name": "variable.parameter.js.jsx" } }, "match": "(?:(\\.\\.\\.)\\s*)?([_$[:alpha:]][_$[:alnum:]]*)" }, "destructuring-variable": { "patterns": [{ "begin": "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\{)", "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))", "name": "meta.object-binding-pattern-variable.js.jsx", "patterns": [{ "include": "#object-binding-pattern" }, { "include": "#type-annotation" }, { "include": "#comment" }] }, { "begin": "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\[)", "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))", "name": "meta.array-binding-pattern-variable.js.jsx", "patterns": [{ "include": "#array-binding-pattern" }, { "include": "#type-annotation" }, { "include": "#comment" }] }] }, "destructuring-variable-rest": { "captures": { "1": { "name": "keyword.operator.rest.js.jsx" }, "2": { "name": "meta.definition.variable.js.jsx variable.other.readwrite.js.jsx" } }, "match": "(?:(\\.\\.\\.)\\s*)?([_$[:alpha:]][_$[:alnum:]]*)" }, "destructuring-variable-rest-const": { "captures": { "1": { "name": "keyword.operator.rest.js.jsx" }, "2": { "name": "meta.definition.variable.js.jsx variable.other.constant.js.jsx" } }, "match": "(?:(\\.\\.\\.)\\s*)?([_$[:alpha:]][_$[:alnum:]]*)" }, "directives": { "begin": "^(///)\\s*(?=<(reference|amd-dependency|amd-module)(\\s+(path|types|no-default-lib|lib|name|resolution-mode)\\s*=\\s*((\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)))+\\s*/>\\s*$)", "beginCaptures": { "1": { "name": "punctuation.definition.comment.js.jsx" } }, "end": "(?=$)", "name": "comment.line.triple-slash.directive.js.jsx", "patterns": [{ "begin": "(<)(reference|amd-dependency|amd-module)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.directive.js.jsx" }, "2": { "name": "entity.name.tag.directive.js.jsx" } }, "end": "/>", "endCaptures": { "0": { "name": "punctuation.definition.tag.directive.js.jsx" } }, "name": "meta.tag.js.jsx", "patterns": [{ "match": "path|types|no-default-lib|lib|name|resolution-mode", "name": "entity.other.attribute-name.directive.js.jsx" }, { "match": "=", "name": "keyword.operator.assignment.js.jsx" }, { "include": "#string" }] }] }, "docblock": { "patterns": [{ "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "constant.language.access-type.jsdoc" } }, "match": "(?x)\n((@)(?:access|api))\n\\s+\n(private|protected|public)\n\\b" }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "entity.name.type.instance.jsdoc" }, "4": { "name": "punctuation.definition.bracket.angle.begin.jsdoc" }, "5": { "name": "constant.other.email.link.underline.jsdoc" }, "6": { "name": "punctuation.definition.bracket.angle.end.jsdoc" } }, "match": "(?x)\n((@)author)\n\\s+\n(\n  [^@\\s<>*/]\n  (?:[^@<>*/]|\\*[^/])*\n)\n(?:\n  \\s*\n  (<)\n  ([^>\\s]+)\n  (>)\n)?" }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "entity.name.type.instance.jsdoc" }, "4": { "name": "keyword.operator.control.jsdoc" }, "5": { "name": "entity.name.type.instance.jsdoc" } }, "match": "(?x)\n((@)borrows) \\s+\n((?:[^@\\s*/]|\\*[^/])+)    # <that namepath>\n\\s+ (as) \\s+              # as\n((?:[^@\\s*/]|\\*[^/])+)    # <this namepath>" }, { "begin": "((@)example)\\s+", "beginCaptures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" } }, "end": "(?=@|\\*/)", "name": "meta.example.jsdoc", "patterns": [{ "match": "^\\s\\*\\s+" }, { "begin": "\\G(<)caption(>)", "beginCaptures": { "0": { "name": "entity.name.tag.inline.jsdoc" }, "1": { "name": "punctuation.definition.bracket.angle.begin.jsdoc" }, "2": { "name": "punctuation.definition.bracket.angle.end.jsdoc" } }, "contentName": "constant.other.description.jsdoc", "end": "(</)caption(>)|(?=\\*/)", "endCaptures": { "0": { "name": "entity.name.tag.inline.jsdoc" }, "1": { "name": "punctuation.definition.bracket.angle.begin.jsdoc" }, "2": { "name": "punctuation.definition.bracket.angle.end.jsdoc" } } }, { "captures": { "0": { "name": "source.embedded.js.jsx" } }, "match": "[^\\s@*](?:[^*]|\\*[^/])*" }] }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "constant.language.symbol-type.jsdoc" } }, "match": "(?x) ((@)kind) \\s+ (class|constant|event|external|file|function|member|mixin|module|namespace|typedef) \\b" }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "variable.other.link.underline.jsdoc" }, "4": { "name": "entity.name.type.instance.jsdoc" } }, "match": "(?x)\n((@)see)\n\\s+\n(?:\n  # URL\n  (\n    (?=https?://)\n    (?:[^\\s*]|\\*[^/])+\n  )\n  |\n  # JSDoc namepath\n  (\n    (?!\n      # Avoid matching bare URIs (also acceptable as links)\n      https?://\n      |\n      # Avoid matching {@inline tags}; we match those below\n      (?:\\[[^\\[\\]]*\\])? # Possible description [preceding]{@tag}\n      {@(?:link|linkcode|linkplain|tutorial)\\b\n    )\n    # Matched namepath\n    (?:[^@\\s*/]|\\*[^/])+\n  )\n)" }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "variable.other.jsdoc" } }, "match": "(?x)\n((@)template)\n\\s+\n# One or more valid identifiers\n(\n  [A-Za-z_$]         # First character: non-numeric word character\n  [\\w$.\\[\\]]*        # Rest of identifier\n  (?:                # Possible list of additional identifiers\n    \\s* , \\s*\n    [A-Za-z_$]\n    [\\w$.\\[\\]]*\n  )*\n)" }, { "begin": "(?x)((@)template)\\s+(?={)", "beginCaptures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" } }, "end": "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])", "patterns": [{ "include": "#jsdoctype" }, { "match": "([A-Za-z_$][\\w$.\\[\\]]*)", "name": "variable.other.jsdoc" }] }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "variable.other.jsdoc" } }, "match": "(?x)\n(\n  (@)\n  (?:arg|argument|const|constant|member|namespace|param|var)\n)\n\\s+\n(\n  [A-Za-z_$]\n  [\\w$.\\[\\]]*\n)" }, { "begin": "((@)typedef)\\s+(?={)", "beginCaptures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" } }, "end": "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])", "patterns": [{ "include": "#jsdoctype" }, { "match": "(?:[^@\\s*/]|\\*[^/])+", "name": "entity.name.type.instance.jsdoc" }] }, { "begin": "((@)(?:arg|argument|const|constant|member|namespace|param|prop|property|var))\\s+(?={)", "beginCaptures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" } }, "end": "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])", "patterns": [{ "include": "#jsdoctype" }, { "match": "([A-Za-z_$][\\w$.\\[\\]]*)", "name": "variable.other.jsdoc" }, { "captures": { "1": { "name": "punctuation.definition.optional-value.begin.bracket.square.jsdoc" }, "2": { "name": "keyword.operator.assignment.jsdoc" }, "3": { "name": "source.embedded.js.jsx" }, "4": { "name": "punctuation.definition.optional-value.end.bracket.square.jsdoc" }, "5": { "name": "invalid.illegal.syntax.jsdoc" } }, "match": `(?x)
(\\[)\\s*
[\\w$]+
(?:
  (?:\\[\\])?                                        # Foo[ ].bar properties within an array
  \\.                                                # Foo.Bar namespaced parameter
  [\\w$]+
)*
(?:
  \\s*
  (=)                                                # [foo=bar] Default parameter value
  \\s*
  (
    # The inner regexes are to stop the match early at */ and to not stop at escaped quotes
    (?>
      "(?:(?:\\*(?!/))|(?:\\\\(?!"))|[^*\\\\])*?" |                      # [foo="bar"] Double-quoted
      '(?:(?:\\*(?!/))|(?:\\\\(?!'))|[^*\\\\])*?' |                      # [foo='bar'] Single-quoted
      \\[ (?:(?:\\*(?!/))|[^*])*? \\] |                                # [foo=[1,2]] Array literal
      (?:(?:\\*(?!/))|\\s(?!\\s*\\])|\\[.*?(?:\\]|(?=\\*/))|[^*\\s\\[\\]])*   # Everything else
    )*
  )
)?
\\s*(?:(\\])((?:[^*\\s]|\\*[^\\s/])+)?|(?=\\*/))`, "name": "variable.other.jsdoc" }] }, { "begin": "(?x)\n(\n  (@)\n  (?:define|enum|exception|export|extends|lends|implements|modifies\n  |namespace|private|protected|returns?|satisfies|suppress|this|throws|type\n  |yields?)\n)\n\\s+(?={)", "beginCaptures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" } }, "end": "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])", "patterns": [{ "include": "#jsdoctype" }] }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "entity.name.type.instance.jsdoc" } }, "match": "(?x)\n(\n  (@)\n  (?:alias|augments|callback|constructs|emits|event|fires|exports?\n  |extends|external|function|func|host|lends|listens|interface|memberof!?\n  |method|module|mixes|mixin|name|requires|see|this|typedef|uses)\n)\n\\s+\n(\n  (?:\n    [^{}@\\s*] | \\*[^/]\n  )+\n)" }, { "begin": `((@)(?:default(?:value)?|license|version))\\s+(([''"]))`, "beginCaptures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "variable.other.jsdoc" }, "4": { "name": "punctuation.definition.string.begin.jsdoc" } }, "contentName": "variable.other.jsdoc", "end": "(\\3)|(?=$|\\*/)", "endCaptures": { "0": { "name": "variable.other.jsdoc" }, "1": { "name": "punctuation.definition.string.end.jsdoc" } } }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "variable.other.jsdoc" } }, "match": "((@)(?:default(?:value)?|license|tutorial|variation|version))\\s+([^\\s*]+)" }, { "captures": { "1": { "name": "punctuation.definition.block.tag.jsdoc" } }, "match": "(?x) (@) (?:abstract|access|alias|api|arg|argument|async|attribute|augments|author|beta|borrows|bubbles |callback|chainable|class|classdesc|code|config|const|constant|constructor|constructs|copyright |default|defaultvalue|define|deprecated|desc|description|dict|emits|enum|event|example|exception |exports?|extends|extension(?:_?for)?|external|externs|file|fileoverview|final|fires|for|func |function|generator|global|hideconstructor|host|ignore|implements|implicitCast|inherit[Dd]oc |inner|instance|interface|internal|kind|lends|license|listens|main|member|memberof!?|method |mixes|mixins?|modifies|module|name|namespace|noalias|nocollapse|nocompile|nosideeffects |override|overview|package|param|polymer(?:Behavior)?|preserve|private|prop|property|protected |public|read[Oo]nly|record|require[ds]|returns?|see|since|static|struct|submodule|summary |suppress|template|this|throws|todo|tutorial|type|typedef|unrestricted|uses|var|variation |version|virtual|writeOnce|yields?) \\b", "name": "storage.type.class.jsdoc" }, { "include": "#inline-tags" }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" } }, "match": "((@)(?:[_$[:alpha:]][_$[:alnum:]]*))(?=\\s+)" }] }, "enum-declaration": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?(?:\\b(const)\\s+)?\\b(enum)\\s+([_$[:alpha:]][_$[:alnum:]]*)", "beginCaptures": { "1": { "name": "keyword.control.export.js.jsx" }, "2": { "name": "storage.modifier.js.jsx" }, "3": { "name": "storage.modifier.js.jsx" }, "4": { "name": "storage.type.enum.js.jsx" }, "5": { "name": "entity.name.type.enum.js.jsx" } }, "end": "(?<=\\})", "name": "meta.enum.declaration.js.jsx", "patterns": [{ "include": "#comment" }, { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.block.js.jsx" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.js.jsx" } }, "patterns": [{ "include": "#comment" }, { "begin": "([_$[:alpha:]][_$[:alnum:]]*)", "beginCaptures": { "0": { "name": "variable.other.enummember.js.jsx" } }, "end": "(?=,|\\}|$)", "patterns": [{ "include": "#comment" }, { "include": "#variable-initializer" }] }, { "begin": "(?=((\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\])))", "end": "(?=,|\\}|$)", "patterns": [{ "include": "#string" }, { "include": "#array-literal" }, { "include": "#comment" }, { "include": "#variable-initializer" }] }, { "include": "#punctuation-comma" }] }] }, "export-declaration": { "patterns": [{ "captures": { "1": { "name": "keyword.control.export.js.jsx" }, "2": { "name": "keyword.control.as.js.jsx" }, "3": { "name": "storage.type.namespace.js.jsx" }, "4": { "name": "entity.name.type.module.js.jsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(export)\\s+(as)\\s+(namespace)\\s+([_$[:alpha:]][_$[:alnum:]]*)" }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(export)(?:\\s+(type))?(?:(?:\\s*(=))|(?:\\s+(default)(?=\\s+)))", "beginCaptures": { "1": { "name": "keyword.control.export.js.jsx" }, "2": { "name": "keyword.control.type.js.jsx" }, "3": { "name": "keyword.operator.assignment.js.jsx" }, "4": { "name": "keyword.control.default.js.jsx" } }, "end": "(?=$|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "name": "meta.export.default.js.jsx", "patterns": [{ "include": "#interface-declaration" }, { "include": "#expression" }] }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(export)(?:\\s+(type))?\\b(?!(\\$)|(\\s*:))((?=\\s*[\\{*])|((?=\\s*[_$[:alpha:]][_$[:alnum:]]*(\\s|,))(?!\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b)))", "beginCaptures": { "1": { "name": "keyword.control.export.js.jsx" }, "2": { "name": "keyword.control.type.js.jsx" } }, "end": "(?=$|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "name": "meta.export.js.jsx", "patterns": [{ "include": "#import-export-declaration" }] }] }, "expression": { "patterns": [{ "include": "#expressionWithoutIdentifiers" }, { "include": "#identifiers" }, { "include": "#expressionPunctuations" }] }, "expression-inside-possibly-arrow-parens": { "patterns": [{ "include": "#expressionWithoutIdentifiers" }, { "include": "#comment" }, { "include": "#string" }, { "include": "#decorator" }, { "include": "#destructuring-parameter" }, { "captures": { "1": { "name": "storage.modifier.js.jsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|protected|private|readonly)\\s+(?=(override|public|protected|private|readonly)\\s+)" }, { "captures": { "1": { "name": "storage.modifier.js.jsx" }, "2": { "name": "keyword.operator.rest.js.jsx" }, "3": { "name": "entity.name.function.js.jsx variable.language.this.js.jsx" }, "4": { "name": "entity.name.function.js.jsx" }, "5": { "name": "keyword.operator.optional.js.jsx" } }, "match": "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))" }, { "captures": { "1": { "name": "storage.modifier.js.jsx" }, "2": { "name": "keyword.operator.rest.js.jsx" }, "3": { "name": "variable.parameter.js.jsx variable.language.this.js.jsx" }, "4": { "name": "variable.parameter.js.jsx" }, "5": { "name": "keyword.operator.optional.js.jsx" } }, "match": "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)(?=\\s*[:,]|$)" }, { "include": "#type-annotation" }, { "include": "#variable-initializer" }, { "match": ",", "name": "punctuation.separator.parameter.js.jsx" }, { "include": "#identifiers" }, { "include": "#expressionPunctuations" }] }, "expression-operators": { "patterns": [{ "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(await)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.control.flow.js.jsx" }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(yield)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?=\\s*\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*\\*)", "beginCaptures": { "1": { "name": "keyword.control.flow.js.jsx" } }, "end": "\\*", "endCaptures": { "0": { "name": "keyword.generator.asterisk.js.jsx" } }, "patterns": [{ "include": "#comment" }] }, { "captures": { "1": { "name": "keyword.control.flow.js.jsx" }, "2": { "name": "keyword.generator.asterisk.js.jsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(yield)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?:\\s*(\\*))?" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))delete(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.operator.expression.delete.js.jsx" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))in(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?!\\()", "name": "keyword.operator.expression.in.js.jsx" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))of(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?!\\()", "name": "keyword.operator.expression.of.js.jsx" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))instanceof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.operator.expression.instanceof.js.jsx" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))new(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.operator.new.js.jsx" }, { "include": "#typeof-operator" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))void(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.operator.expression.void.js.jsx" }, { "captures": { "1": { "name": "keyword.control.as.js.jsx" }, "2": { "name": "storage.modifier.js.jsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+(const)(?=\\s*($|[;,:})\\]]))" }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(as)|(satisfies))\\s+", "beginCaptures": { "1": { "name": "keyword.control.as.js.jsx" }, "2": { "name": "keyword.control.satisfies.js.jsx" } }, "end": "(?=^|[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as|satisfies)\\s+)|(\\s+\\<))", "patterns": [{ "include": "#type" }] }, { "match": "\\.\\.\\.", "name": "keyword.operator.spread.js.jsx" }, { "match": "\\*=|(?<!\\()/=|%=|\\+=|\\-=", "name": "keyword.operator.assignment.compound.js.jsx" }, { "match": "\\&=|\\^=|<<=|>>=|>>>=|\\|=", "name": "keyword.operator.assignment.compound.bitwise.js.jsx" }, { "match": "<<|>>>|>>", "name": "keyword.operator.bitwise.shift.js.jsx" }, { "match": "===|!==|==|!=", "name": "keyword.operator.comparison.js.jsx" }, { "match": "<=|>=|<>|<|>", "name": "keyword.operator.relational.js.jsx" }, { "captures": { "1": { "name": "keyword.operator.logical.js.jsx" }, "2": { "name": "keyword.operator.assignment.compound.js.jsx" }, "3": { "name": "keyword.operator.arithmetic.js.jsx" } }, "match": "(?<=[_$[:alnum:]])(\\!)\\s*(?:(/=)|(?:(/)(?![/*])))" }, { "match": "\\!|&&|\\|\\||\\?\\?", "name": "keyword.operator.logical.js.jsx" }, { "match": "\\&|~|\\^|\\|", "name": "keyword.operator.bitwise.js.jsx" }, { "match": "\\=", "name": "keyword.operator.assignment.js.jsx" }, { "match": "--", "name": "keyword.operator.decrement.js.jsx" }, { "match": "\\+\\+", "name": "keyword.operator.increment.js.jsx" }, { "match": "%|\\*|/|-|\\+", "name": "keyword.operator.arithmetic.js.jsx" }, { "begin": "(?<=[_$[:alnum:])\\]])\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)+(?:(/=)|(?:(/)(?![/*]))))", "end": "(?:(/=)|(?:(/)(?!\\*([^\\*]|(\\*[^\\/]))*\\*\\/)))", "endCaptures": { "1": { "name": "keyword.operator.assignment.compound.js.jsx" }, "2": { "name": "keyword.operator.arithmetic.js.jsx" } }, "patterns": [{ "include": "#comment" }] }, { "captures": { "1": { "name": "keyword.operator.assignment.compound.js.jsx" }, "2": { "name": "keyword.operator.arithmetic.js.jsx" } }, "match": "(?<=[_$[:alnum:])\\]])\\s*(?:(/=)|(?:(/)(?![/*])))" }] }, "expressionPunctuations": { "patterns": [{ "include": "#punctuation-comma" }, { "include": "#punctuation-accessor" }] }, "expressionWithoutIdentifiers": { "patterns": [{ "include": "#jsx" }, { "include": "#string" }, { "include": "#regex" }, { "include": "#comment" }, { "include": "#function-expression" }, { "include": "#class-expression" }, { "include": "#arrow-function" }, { "include": "#paren-expression-possibly-arrow" }, { "include": "#cast" }, { "include": "#ternary-expression" }, { "include": "#new-expr" }, { "include": "#instanceof-expr" }, { "include": "#object-literal" }, { "include": "#expression-operators" }, { "include": "#function-call" }, { "include": "#literal" }, { "include": "#support-objects" }, { "include": "#paren-expression" }] }, "field-declaration": { "begin": "(?x)(?<!\\()(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(readonly)\\s+)?(?=\\s*((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|(\\#?[_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(?:(?:(\\?)|(\\!))\\s*)?(=|:|;|,|\\}|$))", "beginCaptures": { "1": { "name": "storage.modifier.js.jsx" } }, "end": "(?x)(?=\\}|;|,|$|(^(?!\\s*((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|(\\#?[_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(?:(?:(\\?)|(\\!))\\s*)?(=|:|;|,|$))))|(?<=\\})", "name": "meta.field.declaration.js.jsx", "patterns": [{ "include": "#variable-initializer" }, { "include": "#type-annotation" }, { "include": "#string" }, { "include": "#array-literal" }, { "include": "#numeric-literal" }, { "include": "#comment" }, { "captures": { "1": { "name": "meta.definition.property.js.jsx entity.name.function.js.jsx" }, "2": { "name": "keyword.operator.optional.js.jsx" }, "3": { "name": "keyword.operator.definiteassignment.js.jsx" } }, "match": "(?x)(\\#?[_$[:alpha:]][_$[:alnum:]]*)(?:(\\?)|(\\!))?(?=\\s*\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))" }, { "match": "\\#?[_$[:alpha:]][_$[:alnum:]]*", "name": "meta.definition.property.js.jsx variable.object.property.js.jsx" }, { "match": "\\?", "name": "keyword.operator.optional.js.jsx" }, { "match": "\\!", "name": "keyword.operator.definiteassignment.js.jsx" }] }, "for-loop": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))for(?=((\\s+|(\\s*\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*))await)?\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)?(\\())", "beginCaptures": { "0": { "name": "keyword.control.loop.js.jsx" } }, "end": "(?<=\\))", "patterns": [{ "include": "#comment" }, { "match": "await", "name": "keyword.control.loop.js.jsx" }, { "begin": "\\(", "beginCaptures": { "0": { "name": "meta.brace.round.js.jsx" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.js.jsx" } }, "patterns": [{ "include": "#var-expr" }, { "include": "#expression" }, { "include": "#punctuation-semicolon" }] }] }, "function-body": { "patterns": [{ "include": "#comment" }, { "include": "#type-parameters" }, { "include": "#function-parameters" }, { "include": "#return-type" }, { "include": "#type-function-return-type" }, { "include": "#decl-block" }, { "match": "\\*", "name": "keyword.generator.asterisk.js.jsx" }] }, "function-call": { "patterns": [{ "begin": "(?=(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))\\s*(?:(\\?\\.\\s*)|(\\!))?((<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?\\())", "end": "(?<=\\))(?!(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))\\s*(?:(\\?\\.\\s*)|(\\!))?((<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?\\())", "patterns": [{ "begin": "(?=(([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))", "end": "(?=\\s*(?:(\\?\\.\\s*)|(\\!))?((<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?\\())", "name": "meta.function-call.js.jsx", "patterns": [{ "include": "#function-call-target" }] }, { "include": "#comment" }, { "include": "#function-call-optionals" }, { "include": "#type-arguments" }, { "include": "#paren-expression" }] }, { "begin": "(?=(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))(<\\s*[\\{\\[\\(]\\s*$))", "end": "(?<=\\>)(?!(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))(<\\s*[\\{\\[\\(]\\s*$))", "patterns": [{ "begin": "(?=(([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))", "end": "(?=(<\\s*[\\{\\[\\(]\\s*$))", "name": "meta.function-call.js.jsx", "patterns": [{ "include": "#function-call-target" }] }, { "include": "#comment" }, { "include": "#function-call-optionals" }, { "include": "#type-arguments" }] }] }, "function-call-optionals": { "patterns": [{ "match": "\\?\\.", "name": "meta.function-call.js.jsx punctuation.accessor.optional.js.jsx" }, { "match": "\\!", "name": "meta.function-call.js.jsx keyword.operator.definiteassignment.js.jsx" }] }, "function-call-target": { "patterns": [{ "include": "#support-function-call-identifiers" }, { "match": "(\\#?[_$[:alpha:]][_$[:alnum:]]*)", "name": "entity.name.function.js.jsx" }] }, "function-declaration": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?(?:(async)\\s+)?(function\\b)(?:\\s*(\\*))?(?:(?:\\s+|(?<=\\*))([_$[:alpha:]][_$[:alnum:]]*))?\\s*", "beginCaptures": { "1": { "name": "keyword.control.export.js.jsx" }, "2": { "name": "storage.modifier.js.jsx" }, "3": { "name": "storage.modifier.async.js.jsx" }, "4": { "name": "storage.type.function.js.jsx" }, "5": { "name": "keyword.generator.asterisk.js.jsx" }, "6": { "name": "meta.definition.function.js.jsx entity.name.function.js.jsx" } }, "end": "(?=;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))|(?<=\\})", "name": "meta.function.js.jsx", "patterns": [{ "include": "#function-name" }, { "include": "#function-body" }] }, "function-expression": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(async)\\s+)?(function\\b)(?:\\s*(\\*))?(?:(?:\\s+|(?<=\\*))([_$[:alpha:]][_$[:alnum:]]*))?\\s*", "beginCaptures": { "1": { "name": "storage.modifier.async.js.jsx" }, "2": { "name": "storage.type.function.js.jsx" }, "3": { "name": "keyword.generator.asterisk.js.jsx" }, "4": { "name": "meta.definition.function.js.jsx entity.name.function.js.jsx" } }, "end": "(?=;)|(?<=\\})", "name": "meta.function.expression.js.jsx", "patterns": [{ "include": "#function-name" }, { "include": "#single-line-comment-consuming-line-ending" }, { "include": "#function-body" }] }, "function-name": { "match": "[_$[:alpha:]][_$[:alnum:]]*", "name": "meta.definition.function.js.jsx entity.name.function.js.jsx" }, "function-parameters": { "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.parameters.begin.js.jsx" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.parameters.end.js.jsx" } }, "name": "meta.parameters.js.jsx", "patterns": [{ "include": "#function-parameters-body" }] }, "function-parameters-body": { "patterns": [{ "include": "#comment" }, { "include": "#string" }, { "include": "#decorator" }, { "include": "#destructuring-parameter" }, { "include": "#parameter-name" }, { "include": "#parameter-type-annotation" }, { "include": "#variable-initializer" }, { "match": ",", "name": "punctuation.separator.parameter.js.jsx" }] }, "identifiers": { "patterns": [{ "include": "#object-identifiers" }, { "captures": { "1": { "name": "punctuation.accessor.js.jsx" }, "2": { "name": "punctuation.accessor.optional.js.jsx" }, "3": { "name": "entity.name.function.js.jsx" } }, "match": "(?x)(?:(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*)?([_$[:alpha:]][_$[:alnum:]]*)(?=\\s*=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n))" }, { "captures": { "1": { "name": "punctuation.accessor.js.jsx" }, "2": { "name": "punctuation.accessor.optional.js.jsx" }, "3": { "name": "variable.other.constant.property.js.jsx" } }, "match": "(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(\\#?[[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])" }, { "captures": { "1": { "name": "punctuation.accessor.js.jsx" }, "2": { "name": "punctuation.accessor.optional.js.jsx" }, "3": { "name": "variable.other.property.js.jsx" } }, "match": "(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*)" }, { "match": "([[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])", "name": "variable.other.constant.js.jsx" }, { "match": "[_$[:alpha:]][_$[:alnum:]]*", "name": "variable.other.readwrite.js.jsx" }] }, "if-statement": { "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?=\\bif\\s*(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))\\s*(?!\\{))", "end": "(?=;|$|\\})", "patterns": [{ "include": "#comment" }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(if)\\s*(\\()", "beginCaptures": { "1": { "name": "keyword.control.conditional.js.jsx" }, "2": { "name": "meta.brace.round.js.jsx" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.js.jsx" } }, "patterns": [{ "include": "#expression" }] }, { "begin": "(?<=\\))\\s*\\/(?![\\/*])(?=(?:[^\\/\\\\\\[]|\\\\.|\\[([^\\]\\\\]|\\\\.)*\\])+\\/([dgimsuy]+|(?![\\/\\*])|(?=\\/\\*))(?!\\s*[a-zA-Z0-9_$]))", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.js.jsx" } }, "end": "(/)([dgimsuy]*)", "endCaptures": { "1": { "name": "punctuation.definition.string.end.js.jsx" }, "2": { "name": "keyword.other.js.jsx" } }, "name": "string.regexp.js.jsx", "patterns": [{ "include": "#regexp" }] }, { "include": "#statements" }] }] }, "import-declaration": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(import)(?:\\s+(type)(?!\\s+from))?(?!\\s*[:\\(])(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "1": { "name": "keyword.control.export.js.jsx" }, "2": { "name": "storage.modifier.js.jsx" }, "3": { "name": "keyword.control.import.js.jsx" }, "4": { "name": "keyword.control.type.js.jsx" } }, "end": "(?<!^import|[^\\._$[:alnum:]]import)(?=;|$|^)", "name": "meta.import.js.jsx", "patterns": [{ "include": "#single-line-comment-consuming-line-ending" }, { "include": "#comment" }, { "include": "#string" }, { "begin": `(?<=^import|[^\\._$[:alnum:]]import)(?!\\s*["'])`, "end": "\\bfrom\\b", "endCaptures": { "0": { "name": "keyword.control.from.js.jsx" } }, "patterns": [{ "include": "#import-export-declaration" }] }, { "include": "#import-export-declaration" }] }, "import-equals-declaration": { "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(import)(?:\\s+(type))?\\s+([_$[:alpha:]][_$[:alnum:]]*)\\s*(=)\\s*(require)\\s*(\\()", "beginCaptures": { "1": { "name": "keyword.control.export.js.jsx" }, "2": { "name": "storage.modifier.js.jsx" }, "3": { "name": "keyword.control.import.js.jsx" }, "4": { "name": "keyword.control.type.js.jsx" }, "5": { "name": "variable.other.readwrite.alias.js.jsx" }, "6": { "name": "keyword.operator.assignment.js.jsx" }, "7": { "name": "keyword.control.require.js.jsx" }, "8": { "name": "meta.brace.round.js.jsx" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.js.jsx" } }, "name": "meta.import-equals.external.js.jsx", "patterns": [{ "include": "#comment" }, { "include": "#string" }] }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(import)(?:\\s+(type))?\\s+([_$[:alpha:]][_$[:alnum:]]*)\\s*(=)\\s*(?!require\\b)", "beginCaptures": { "1": { "name": "keyword.control.export.js.jsx" }, "2": { "name": "storage.modifier.js.jsx" }, "3": { "name": "keyword.control.import.js.jsx" }, "4": { "name": "keyword.control.type.js.jsx" }, "5": { "name": "variable.other.readwrite.alias.js.jsx" }, "6": { "name": "keyword.operator.assignment.js.jsx" } }, "end": "(?=;|$|^)", "name": "meta.import-equals.internal.js.jsx", "patterns": [{ "include": "#single-line-comment-consuming-line-ending" }, { "include": "#comment" }, { "captures": { "1": { "name": "entity.name.type.module.js.jsx" }, "2": { "name": "punctuation.accessor.js.jsx" }, "3": { "name": "punctuation.accessor.optional.js.jsx" } }, "match": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))" }, { "match": "([_$[:alpha:]][_$[:alnum:]]*)", "name": "variable.other.readwrite.js.jsx" }] }] }, "import-export-assert-clause": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(assert)\\s*(\\{)", "beginCaptures": { "1": { "name": "keyword.control.assert.js.jsx" }, "2": { "name": "punctuation.definition.block.js.jsx" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.js.jsx" } }, "patterns": [{ "include": "#comment" }, { "include": "#string" }, { "match": "(?:[_$[:alpha:]][_$[:alnum:]]*)\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*:)", "name": "meta.object-literal.key.js.jsx" }, { "match": ":", "name": "punctuation.separator.key-value.js.jsx" }] }, "import-export-block": { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.block.js.jsx" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.js.jsx" } }, "name": "meta.block.js.jsx", "patterns": [{ "include": "#import-export-clause" }] }, "import-export-clause": { "patterns": [{ "include": "#comment" }, { "captures": { "1": { "name": "keyword.control.type.js.jsx" }, "2": { "name": "keyword.control.default.js.jsx" }, "3": { "name": "constant.language.import-export-all.js.jsx" }, "4": { "name": "variable.other.readwrite.js.jsx" }, "5": { "name": "keyword.control.as.js.jsx" }, "6": { "name": "keyword.control.default.js.jsx" }, "7": { "name": "variable.other.readwrite.alias.js.jsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(?:(\\btype)\\s+)?(?:(\\bdefault)|(\\*)|(\\b[_$[:alpha:]][_$[:alnum:]]*)))\\s+(as)\\s+(?:(default(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|([_$[:alpha:]][_$[:alnum:]]*))" }, { "include": "#punctuation-comma" }, { "match": "\\*", "name": "constant.language.import-export-all.js.jsx" }, { "match": "\\b(default)\\b", "name": "keyword.control.default.js.jsx" }, { "captures": { "1": { "name": "keyword.control.type.js.jsx" }, "2": { "name": "variable.other.readwrite.alias.js.jsx" } }, "match": "(?:(\\btype)\\s+)?([_$[:alpha:]][_$[:alnum:]]*)" }] }, "import-export-declaration": { "patterns": [{ "include": "#comment" }, { "include": "#string" }, { "include": "#import-export-block" }, { "match": "\\bfrom\\b", "name": "keyword.control.from.js.jsx" }, { "include": "#import-export-assert-clause" }, { "include": "#import-export-clause" }] }, "indexer-declaration": { "begin": "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(readonly)\\s*)?\\s*(\\[)\\s*([_$[:alpha:]][_$[:alnum:]]*)\\s*(?=:)", "beginCaptures": { "1": { "name": "storage.modifier.js.jsx" }, "2": { "name": "meta.brace.square.js.jsx" }, "3": { "name": "variable.parameter.js.jsx" } }, "end": "(\\])\\s*(\\?\\s*)?|$", "endCaptures": { "1": { "name": "meta.brace.square.js.jsx" }, "2": { "name": "keyword.operator.optional.js.jsx" } }, "name": "meta.indexer.declaration.js.jsx", "patterns": [{ "include": "#type-annotation" }] }, "indexer-mapped-type-declaration": { "begin": "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))([+-])?(readonly)\\s*)?\\s*(\\[)\\s*([_$[:alpha:]][_$[:alnum:]]*)\\s+(in)\\s+", "beginCaptures": { "1": { "name": "keyword.operator.type.modifier.js.jsx" }, "2": { "name": "storage.modifier.js.jsx" }, "3": { "name": "meta.brace.square.js.jsx" }, "4": { "name": "entity.name.type.js.jsx" }, "5": { "name": "keyword.operator.expression.in.js.jsx" } }, "end": "(\\])([+-])?\\s*(\\?\\s*)?|$", "endCaptures": { "1": { "name": "meta.brace.square.js.jsx" }, "2": { "name": "keyword.operator.type.modifier.js.jsx" }, "3": { "name": "keyword.operator.optional.js.jsx" } }, "name": "meta.indexer.mappedtype.declaration.js.jsx", "patterns": [{ "captures": { "1": { "name": "keyword.control.as.js.jsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+" }, { "include": "#type" }] }, "inline-tags": { "patterns": [{ "captures": { "1": { "name": "punctuation.definition.bracket.square.begin.jsdoc" }, "2": { "name": "punctuation.definition.bracket.square.end.jsdoc" } }, "match": "(\\[)[^\\]]+(\\])(?={@(?:link|linkcode|linkplain|tutorial))", "name": "constant.other.description.jsdoc" }, { "begin": "({)((@)(?:link(?:code|plain)?|tutorial))\\s*", "beginCaptures": { "1": { "name": "punctuation.definition.bracket.curly.begin.jsdoc" }, "2": { "name": "storage.type.class.jsdoc" }, "3": { "name": "punctuation.definition.inline.tag.jsdoc" } }, "end": "}|(?=\\*/)", "endCaptures": { "0": { "name": "punctuation.definition.bracket.curly.end.jsdoc" } }, "name": "entity.name.type.instance.jsdoc", "patterns": [{ "captures": { "1": { "name": "variable.other.link.underline.jsdoc" }, "2": { "name": "punctuation.separator.pipe.jsdoc" } }, "match": "\\G((?=https?://)(?:[^|}\\s*]|\\*[/])+)(\\|)?" }, { "captures": { "1": { "name": "variable.other.description.jsdoc" }, "2": { "name": "punctuation.separator.pipe.jsdoc" } }, "match": "\\G((?:[^{}@\\s|*]|\\*[^/])+)(\\|)?" }] }] }, "instanceof-expr": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(instanceof)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "1": { "name": "keyword.operator.expression.instanceof.js.jsx" } }, "end": "(?<=\\))|(?=[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|(===|!==|==|!=)|(([\\&\\~\\^\\|]\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s+instanceof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))function((\\s+[_$[:alpha:]][_$[:alnum:]]*)|(\\s*[\\(]))))", "patterns": [{ "include": "#type" }] }, "interface-declaration": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(?:(abstract)\\s+)?\\b(interface)\\b(?=\\s+|/[/*])", "beginCaptures": { "1": { "name": "keyword.control.export.js.jsx" }, "2": { "name": "storage.modifier.js.jsx" }, "3": { "name": "storage.modifier.js.jsx" }, "4": { "name": "storage.type.interface.js.jsx" } }, "end": "(?<=\\})", "name": "meta.interface.js.jsx", "patterns": [{ "include": "#comment" }, { "include": "#class-or-interface-heritage" }, { "captures": { "0": { "name": "entity.name.type.interface.js.jsx" } }, "match": "[_$[:alpha:]][_$[:alnum:]]*" }, { "include": "#type-parameters" }, { "include": "#class-or-interface-body" }] }, "jsdoctype": { "patterns": [{ "begin": "\\G({)", "beginCaptures": { "0": { "name": "entity.name.type.instance.jsdoc" }, "1": { "name": "punctuation.definition.bracket.curly.begin.jsdoc" } }, "contentName": "entity.name.type.instance.jsdoc", "end": "((}))\\s*|(?=\\*/)", "endCaptures": { "1": { "name": "entity.name.type.instance.jsdoc" }, "2": { "name": "punctuation.definition.bracket.curly.end.jsdoc" } }, "patterns": [{ "include": "#brackets" }] }] }, "jsx": { "patterns": [{ "include": "#jsx-tag-without-attributes-in-expression" }, { "include": "#jsx-tag-in-expression" }] }, "jsx-children": { "patterns": [{ "include": "#jsx-tag-without-attributes" }, { "include": "#jsx-tag" }, { "include": "#jsx-evaluated-code" }, { "include": "#jsx-entities" }] }, "jsx-entities": { "patterns": [{ "captures": { "1": { "name": "punctuation.definition.entity.js.jsx" }, "3": { "name": "punctuation.definition.entity.js.jsx" } }, "match": "(&)([a-zA-Z0-9]+|#[0-9]+|#x[0-9a-fA-F]+)(;)", "name": "constant.character.entity.js.jsx" }] }, "jsx-evaluated-code": { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.section.embedded.begin.js.jsx" } }, "contentName": "meta.embedded.expression.js.jsx", "end": "\\}", "endCaptures": { "0": { "name": "punctuation.section.embedded.end.js.jsx" } }, "patterns": [{ "include": "#expression" }] }, "jsx-string-double-quoted": { "begin": '"', "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.js.jsx" } }, "end": '"', "endCaptures": { "0": { "name": "punctuation.definition.string.end.js.jsx" } }, "name": "string.quoted.double.js.jsx", "patterns": [{ "include": "#jsx-entities" }] }, "jsx-string-single-quoted": { "begin": "'", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.js.jsx" } }, "end": "'", "endCaptures": { "0": { "name": "punctuation.definition.string.end.js.jsx" } }, "name": "string.quoted.single.js.jsx", "patterns": [{ "include": "#jsx-entities" }] }, "jsx-tag": { "begin": "(?=(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))(?=((<\\s*)|(\\s+))(?!\\?)|\\/?>))", "end": "(/>)|(?:(</)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>))", "endCaptures": { "1": { "name": "punctuation.definition.tag.end.js.jsx" }, "2": { "name": "punctuation.definition.tag.begin.js.jsx" }, "3": { "name": "entity.name.tag.namespace.js.jsx" }, "4": { "name": "punctuation.separator.namespace.js.jsx" }, "5": { "name": "entity.name.tag.js.jsx" }, "6": { "name": "support.class.component.js.jsx" }, "7": { "name": "punctuation.definition.tag.end.js.jsx" } }, "name": "meta.tag.js.jsx", "patterns": [{ "begin": "(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))(?=((<\\s*)|(\\s+))(?!\\?)|\\/?>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.js.jsx" }, "2": { "name": "entity.name.tag.namespace.js.jsx" }, "3": { "name": "punctuation.separator.namespace.js.jsx" }, "4": { "name": "entity.name.tag.js.jsx" }, "5": { "name": "support.class.component.js.jsx" } }, "end": "(?=[/]?>)", "patterns": [{ "include": "#comment" }, { "include": "#type-arguments" }, { "include": "#jsx-tag-attributes" }] }, { "begin": "(>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.end.js.jsx" } }, "contentName": "meta.jsx.children.js.jsx", "end": "(?=</)", "patterns": [{ "include": "#jsx-children" }] }] }, "jsx-tag-attribute-assignment": { "match": `=(?=\\s*(?:'|"|{|/\\*|//|\\n))`, "name": "keyword.operator.assignment.js.jsx" }, "jsx-tag-attribute-name": { "captures": { "1": { "name": "entity.other.attribute-name.namespace.js.jsx" }, "2": { "name": "punctuation.separator.namespace.js.jsx" }, "3": { "name": "entity.other.attribute-name.js.jsx" } }, "match": "(?x)\n  \\s*\n  (?:([_$[:alpha:]][-_$[:alnum:].]*)(:))?\n  ([_$[:alpha:]][-_$[:alnum:]]*)\n  (?=\\s|=|/?>|/\\*|//)" }, "jsx-tag-attributes": { "begin": "\\s+", "end": "(?=[/]?>)", "name": "meta.tag.attributes.js.jsx", "patterns": [{ "include": "#comment" }, { "include": "#jsx-tag-attribute-name" }, { "include": "#jsx-tag-attribute-assignment" }, { "include": "#jsx-string-double-quoted" }, { "include": "#jsx-string-single-quoted" }, { "include": "#jsx-evaluated-code" }, { "include": "#jsx-tag-attributes-illegal" }] }, "jsx-tag-attributes-illegal": { "match": "\\S+", "name": "invalid.illegal.attribute.js.jsx" }, "jsx-tag-in-expression": { "begin": "(?x)\n  (?<!\\+\\+|--)(?<=[({\\[,?=>:*]|&&|\\|\\||\\?|\\*\\/|^await|[^\\._$[:alnum:]]await|^return|[^\\._$[:alnum:]]return|^default|[^\\._$[:alnum:]]default|^yield|[^\\._$[:alnum:]]yield|^)\\s*\n  (?!<\\s*[_$[:alpha:]][_$[:alnum:]]*((\\s+extends\\s+[^=>])|,)) # look ahead is not type parameter of arrow\n  (?=(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))(?=((<\\s*)|(\\s+))(?!\\?)|\\/?>))", "end": "(?!(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))(?=((<\\s*)|(\\s+))(?!\\?)|\\/?>))", "patterns": [{ "include": "#jsx-tag" }] }, "jsx-tag-without-attributes": { "begin": "(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.js.jsx" }, "2": { "name": "entity.name.tag.namespace.js.jsx" }, "3": { "name": "punctuation.separator.namespace.js.jsx" }, "4": { "name": "entity.name.tag.js.jsx" }, "5": { "name": "support.class.component.js.jsx" }, "6": { "name": "punctuation.definition.tag.end.js.jsx" } }, "contentName": "meta.jsx.children.js.jsx", "end": "(</)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.begin.js.jsx" }, "2": { "name": "entity.name.tag.namespace.js.jsx" }, "3": { "name": "punctuation.separator.namespace.js.jsx" }, "4": { "name": "entity.name.tag.js.jsx" }, "5": { "name": "support.class.component.js.jsx" }, "6": { "name": "punctuation.definition.tag.end.js.jsx" } }, "name": "meta.tag.without-attributes.js.jsx", "patterns": [{ "include": "#jsx-children" }] }, "jsx-tag-without-attributes-in-expression": { "begin": "(?<!\\+\\+|--)(?<=[({\\[,?=>:*]|&&|\\|\\||\\?|\\*\\/|^await|[^\\._$[:alnum:]]await|^return|[^\\._$[:alnum:]]return|^default|[^\\._$[:alnum:]]default|^yield|[^\\._$[:alnum:]]yield|^)\\s*(?=(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>))", "end": "(?!(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>))", "patterns": [{ "include": "#jsx-tag-without-attributes" }] }, "label": { "patterns": [{ "begin": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(:)(?=\\s*\\{)", "beginCaptures": { "1": { "name": "entity.name.label.js.jsx" }, "2": { "name": "punctuation.separator.label.js.jsx" } }, "end": "(?<=\\})", "patterns": [{ "include": "#decl-block" }] }, { "captures": { "1": { "name": "entity.name.label.js.jsx" }, "2": { "name": "punctuation.separator.label.js.jsx" } }, "match": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(:)" }] }, "literal": { "patterns": [{ "include": "#numeric-literal" }, { "include": "#boolean-literal" }, { "include": "#null-literal" }, { "include": "#undefined-literal" }, { "include": "#numericConstant-literal" }, { "include": "#array-literal" }, { "include": "#this-literal" }, { "include": "#super-literal" }] }, "method-declaration": { "patterns": [{ "begin": "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(override)\\s+)?(?:\\b(public|private|protected)\\s+)?(?:\\b(abstract)\\s+)?(?:\\b(async)\\s+)?\\s*\\b(constructor)\\b(?!:)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "1": { "name": "storage.modifier.js.jsx" }, "2": { "name": "storage.modifier.js.jsx" }, "3": { "name": "storage.modifier.js.jsx" }, "4": { "name": "storage.modifier.async.js.jsx" }, "5": { "name": "storage.type.js.jsx" } }, "end": "(?=\\}|;|,|$)|(?<=\\})", "name": "meta.method.declaration.js.jsx", "patterns": [{ "include": "#method-declaration-name" }, { "include": "#function-body" }] }, { "begin": "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(override)\\s+)?(?:\\b(public|private|protected)\\s+)?(?:\\b(abstract)\\s+)?(?:\\b(async)\\s+)?(?:(?:\\s*\\b(new)\\b(?!:)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|(?:(\\*)\\s*)?)(?=\\s*((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])", "beginCaptures": { "1": { "name": "storage.modifier.js.jsx" }, "2": { "name": "storage.modifier.js.jsx" }, "3": { "name": "storage.modifier.js.jsx" }, "4": { "name": "storage.modifier.async.js.jsx" }, "5": { "name": "keyword.operator.new.js.jsx" }, "6": { "name": "keyword.generator.asterisk.js.jsx" } }, "end": "(?=\\}|;|,|$)|(?<=\\})", "name": "meta.method.declaration.js.jsx", "patterns": [{ "include": "#method-declaration-name" }, { "include": "#function-body" }] }, { "begin": "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(override)\\s+)?(?:\\b(public|private|protected)\\s+)?(?:\\b(abstract)\\s+)?(?:\\b(async)\\s+)?(?:\\b(get|set)\\s+)?(?:(\\*)\\s*)?(?=\\s*(((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??))\\s*((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])", "beginCaptures": { "1": { "name": "storage.modifier.js.jsx" }, "2": { "name": "storage.modifier.js.jsx" }, "3": { "name": "storage.modifier.js.jsx" }, "4": { "name": "storage.modifier.async.js.jsx" }, "5": { "name": "storage.type.property.js.jsx" }, "6": { "name": "keyword.generator.asterisk.js.jsx" } }, "end": "(?=\\}|;|,|$)|(?<=\\})", "name": "meta.method.declaration.js.jsx", "patterns": [{ "include": "#method-declaration-name" }, { "include": "#function-body" }] }] }, "method-declaration-name": { "begin": "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??)\\s*[\\(\\<])", "end": "(?=\\(|\\<)", "patterns": [{ "include": "#string" }, { "include": "#array-literal" }, { "include": "#numeric-literal" }, { "match": "[_$[:alpha:]][_$[:alnum:]]*", "name": "meta.definition.method.js.jsx entity.name.function.js.jsx" }, { "match": "\\?", "name": "keyword.operator.optional.js.jsx" }] }, "namespace-declaration": { "begin": "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(namespace|module)\\s+(?=[_$[:alpha:]\"'`]))", "beginCaptures": { "1": { "name": "keyword.control.export.js.jsx" }, "2": { "name": "storage.modifier.js.jsx" }, "3": { "name": "storage.type.namespace.js.jsx" } }, "end": "(?<=\\})|(?=;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "name": "meta.namespace.declaration.js.jsx", "patterns": [{ "include": "#comment" }, { "include": "#string" }, { "match": "([_$[:alpha:]][_$[:alnum:]]*)", "name": "entity.name.type.module.js.jsx" }, { "include": "#punctuation-accessor" }, { "include": "#decl-block" }] }, "new-expr": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(new)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "1": { "name": "keyword.operator.new.js.jsx" } }, "end": "(?<=\\))|(?=[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))new(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))function((\\s+[_$[:alpha:]][_$[:alnum:]]*)|(\\s*[\\(]))))", "name": "new.expr.js.jsx", "patterns": [{ "include": "#expression" }] }, "null-literal": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))null(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "constant.language.null.js.jsx" }, "numeric-literal": { "patterns": [{ "captures": { "1": { "name": "storage.type.numeric.bigint.js.jsx" } }, "match": "\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$)", "name": "constant.numeric.hex.js.jsx" }, { "captures": { "1": { "name": "storage.type.numeric.bigint.js.jsx" } }, "match": "\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$)", "name": "constant.numeric.binary.js.jsx" }, { "captures": { "1": { "name": "storage.type.numeric.bigint.js.jsx" } }, "match": "\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$)", "name": "constant.numeric.octal.js.jsx" }, { "captures": { "0": { "name": "constant.numeric.decimal.js.jsx" }, "1": { "name": "meta.delimiter.decimal.period.js.jsx" }, "2": { "name": "storage.type.numeric.bigint.js.jsx" }, "3": { "name": "meta.delimiter.decimal.period.js.jsx" }, "4": { "name": "storage.type.numeric.bigint.js.jsx" }, "5": { "name": "meta.delimiter.decimal.period.js.jsx" }, "6": { "name": "storage.type.numeric.bigint.js.jsx" }, "7": { "name": "storage.type.numeric.bigint.js.jsx" }, "8": { "name": "meta.delimiter.decimal.period.js.jsx" }, "9": { "name": "storage.type.numeric.bigint.js.jsx" }, "10": { "name": "meta.delimiter.decimal.period.js.jsx" }, "11": { "name": "storage.type.numeric.bigint.js.jsx" }, "12": { "name": "meta.delimiter.decimal.period.js.jsx" }, "13": { "name": "storage.type.numeric.bigint.js.jsx" }, "14": { "name": "storage.type.numeric.bigint.js.jsx" } }, "match": "(?x)\n(?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$)" }] }, "numericConstant-literal": { "patterns": [{ "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))NaN(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "constant.language.nan.js.jsx" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Infinity(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "constant.language.infinity.js.jsx" }] }, "object-binding-element": { "patterns": [{ "include": "#comment" }, { "begin": "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))", "end": "(?=,|\\})", "patterns": [{ "include": "#object-binding-element-propertyName" }, { "include": "#binding-element" }] }, { "include": "#object-binding-pattern" }, { "include": "#destructuring-variable-rest" }, { "include": "#variable-initializer" }, { "include": "#punctuation-comma" }] }, "object-binding-element-const": { "patterns": [{ "include": "#comment" }, { "begin": "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))", "end": "(?=,|\\})", "patterns": [{ "include": "#object-binding-element-propertyName" }, { "include": "#binding-element-const" }] }, { "include": "#object-binding-pattern-const" }, { "include": "#destructuring-variable-rest-const" }, { "include": "#variable-initializer" }, { "include": "#punctuation-comma" }] }, "object-binding-element-propertyName": { "begin": "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))", "end": "(:)", "endCaptures": { "0": { "name": "punctuation.destructuring.js.jsx" } }, "patterns": [{ "include": "#string" }, { "include": "#array-literal" }, { "include": "#numeric-literal" }, { "match": "([_$[:alpha:]][_$[:alnum:]]*)", "name": "variable.object.property.js.jsx" }] }, "object-binding-pattern": { "begin": "(?:(\\.\\.\\.)\\s*)?(\\{)", "beginCaptures": { "1": { "name": "keyword.operator.rest.js.jsx" }, "2": { "name": "punctuation.definition.binding-pattern.object.js.jsx" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.object.js.jsx" } }, "patterns": [{ "include": "#object-binding-element" }] }, "object-binding-pattern-const": { "begin": "(?:(\\.\\.\\.)\\s*)?(\\{)", "beginCaptures": { "1": { "name": "keyword.operator.rest.js.jsx" }, "2": { "name": "punctuation.definition.binding-pattern.object.js.jsx" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.object.js.jsx" } }, "patterns": [{ "include": "#object-binding-element-const" }] }, "object-identifiers": { "patterns": [{ "match": "([_$[:alpha:]][_$[:alnum:]]*)(?=\\s*\\??\\.\\s*prototype\\b(?!\\$))", "name": "support.class.js.jsx" }, { "captures": { "1": { "name": "punctuation.accessor.js.jsx" }, "2": { "name": "punctuation.accessor.optional.js.jsx" }, "3": { "name": "variable.other.constant.object.property.js.jsx" }, "4": { "name": "variable.other.object.property.js.jsx" } }, "match": "(?x)(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(?:\n  (\\#?[[:upper:]][_$[:digit:][:upper:]]*) |\n  (\\#?[_$[:alpha:]][_$[:alnum:]]*)\n)(?=\\s*\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*)" }, { "captures": { "1": { "name": "variable.other.constant.object.js.jsx" }, "2": { "name": "variable.other.object.js.jsx" } }, "match": "(?x)(?:\n  ([[:upper:]][_$[:digit:][:upper:]]*) |\n  ([_$[:alpha:]][_$[:alnum:]]*)\n)(?=\\s*\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*)" }] }, "object-literal": { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.block.js.jsx" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.js.jsx" } }, "name": "meta.objectliteral.js.jsx", "patterns": [{ "include": "#object-member" }] }, "object-literal-method-declaration": { "begin": "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(async)\\s+)?(?:\\b(get|set)\\s+)?(?:(\\*)\\s*)?(?=\\s*(((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??))\\s*((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])", "beginCaptures": { "1": { "name": "storage.modifier.async.js.jsx" }, "2": { "name": "storage.type.property.js.jsx" }, "3": { "name": "keyword.generator.asterisk.js.jsx" } }, "end": "(?=\\}|;|,)|(?<=\\})", "name": "meta.method.declaration.js.jsx", "patterns": [{ "include": "#method-declaration-name" }, { "include": "#function-body" }, { "begin": "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(async)\\s+)?(?:\\b(get|set)\\s+)?(?:(\\*)\\s*)?(?=\\s*(((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??))\\s*((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])", "beginCaptures": { "1": { "name": "storage.modifier.async.js.jsx" }, "2": { "name": "storage.type.property.js.jsx" }, "3": { "name": "keyword.generator.asterisk.js.jsx" } }, "end": "(?=\\(|\\<)", "patterns": [{ "include": "#method-declaration-name" }] }] }, "object-member": { "patterns": [{ "include": "#comment" }, { "include": "#object-literal-method-declaration" }, { "begin": "(?=\\[)", "end": "(?=:)|((?<=[\\]])(?=\\s*[\\(\\<]))", "name": "meta.object.member.js.jsx meta.object-literal.key.js.jsx", "patterns": [{ "include": "#comment" }, { "include": "#array-literal" }] }, { "begin": "(?=[\\'\\\"\\`])", "end": "(?=:)|((?<=[\\'\\\"\\`])(?=((\\s*[\\(\\<,}])|(\\s+(as|satisifies)\\s+))))", "name": "meta.object.member.js.jsx meta.object-literal.key.js.jsx", "patterns": [{ "include": "#comment" }, { "include": "#string" }] }, { "begin": "(?x)(?=(\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$)))", "end": "(?=:)|(?=\\s*([\\(\\<,}])|(\\s+as|satisifies\\s+))", "name": "meta.object.member.js.jsx meta.object-literal.key.js.jsx", "patterns": [{ "include": "#comment" }, { "include": "#numeric-literal" }] }, { "begin": "(?<=[\\]\\'\\\"\\`])(?=\\s*[\\(\\<])", "end": "(?=\\}|;|,)|(?<=\\})", "name": "meta.method.declaration.js.jsx", "patterns": [{ "include": "#function-body" }] }, { "captures": { "0": { "name": "meta.object-literal.key.js.jsx" }, "1": { "name": "constant.numeric.decimal.js.jsx" } }, "match": "(?![_$[:alpha:]])([[:digit:]]+)\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*:)", "name": "meta.object.member.js.jsx" }, { "captures": { "0": { "name": "meta.object-literal.key.js.jsx" }, "1": { "name": "entity.name.function.js.jsx" } }, "match": "(?x)(?:([_$[:alpha:]][_$[:alnum:]]*)\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*:(\\s*\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/)*\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))", "name": "meta.object.member.js.jsx" }, { "captures": { "0": { "name": "meta.object-literal.key.js.jsx" } }, "match": "(?:[_$[:alpha:]][_$[:alnum:]]*)\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*:)", "name": "meta.object.member.js.jsx" }, { "begin": "\\.\\.\\.", "beginCaptures": { "0": { "name": "keyword.operator.spread.js.jsx" } }, "end": "(?=,|\\})", "name": "meta.object.member.js.jsx", "patterns": [{ "include": "#expression" }] }, { "captures": { "1": { "name": "variable.other.readwrite.js.jsx" } }, "match": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?=,|\\}|$|\\/\\/|\\/\\*)", "name": "meta.object.member.js.jsx" }, { "captures": { "1": { "name": "keyword.control.as.js.jsx" }, "2": { "name": "storage.modifier.js.jsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+(const)(?=\\s*([,}]|$))", "name": "meta.object.member.js.jsx" }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(as)|(satisfies))\\s+", "beginCaptures": { "1": { "name": "keyword.control.as.js.jsx" }, "2": { "name": "keyword.control.satisfies.js.jsx" } }, "end": "(?=[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|^|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as|satisifies)\\s+))", "name": "meta.object.member.js.jsx", "patterns": [{ "include": "#type" }] }, { "begin": "(?=[_$[:alpha:]][_$[:alnum:]]*\\s*=)", "end": "(?=,|\\}|$|\\/\\/|\\/\\*)", "name": "meta.object.member.js.jsx", "patterns": [{ "include": "#expression" }] }, { "begin": ":", "beginCaptures": { "0": { "name": "meta.object-literal.key.js.jsx punctuation.separator.key-value.js.jsx" } }, "end": "(?=,|\\})", "name": "meta.object.member.js.jsx", "patterns": [{ "begin": "(?<=:)\\s*(async)?(?=\\s*(<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)\\(\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))", "beginCaptures": { "1": { "name": "storage.modifier.async.js.jsx" } }, "end": "(?<=\\))", "patterns": [{ "include": "#type-parameters" }, { "begin": "\\(", "beginCaptures": { "0": { "name": "meta.brace.round.js.jsx" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.js.jsx" } }, "patterns": [{ "include": "#expression-inside-possibly-arrow-parens" }] }] }, { "begin": "(?<=:)\\s*(async)?\\s*(\\()(?=\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))", "beginCaptures": { "1": { "name": "storage.modifier.async.js.jsx" }, "2": { "name": "meta.brace.round.js.jsx" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.js.jsx" } }, "patterns": [{ "include": "#expression-inside-possibly-arrow-parens" }] }, { "begin": "(?<=:)\\s*(async)?\\s*(?=\\<\\s*$)", "beginCaptures": { "1": { "name": "storage.modifier.async.js.jsx" } }, "end": "(?<=\\>)", "patterns": [{ "include": "#type-parameters" }] }, { "begin": "(?<=\\>)\\s*(\\()(?=\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))", "beginCaptures": { "1": { "name": "meta.brace.round.js.jsx" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.js.jsx" } }, "patterns": [{ "include": "#expression-inside-possibly-arrow-parens" }] }, { "include": "#possibly-arrow-return-type" }, { "include": "#expression" }] }, { "include": "#punctuation-comma" }, { "include": "#decl-block" }] }, "parameter-array-binding-pattern": { "begin": "(?:(\\.\\.\\.)\\s*)?(\\[)", "beginCaptures": { "1": { "name": "keyword.operator.rest.js.jsx" }, "2": { "name": "punctuation.definition.binding-pattern.array.js.jsx" } }, "end": "\\]", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.array.js.jsx" } }, "patterns": [{ "include": "#parameter-binding-element" }, { "include": "#punctuation-comma" }] }, "parameter-binding-element": { "patterns": [{ "include": "#comment" }, { "include": "#string" }, { "include": "#numeric-literal" }, { "include": "#regex" }, { "include": "#parameter-object-binding-pattern" }, { "include": "#parameter-array-binding-pattern" }, { "include": "#destructuring-parameter-rest" }, { "include": "#variable-initializer" }] }, "parameter-name": { "patterns": [{ "captures": { "1": { "name": "storage.modifier.js.jsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|protected|private|readonly)\\s+(?=(override|public|protected|private|readonly)\\s+)" }, { "captures": { "1": { "name": "storage.modifier.js.jsx" }, "2": { "name": "keyword.operator.rest.js.jsx" }, "3": { "name": "entity.name.function.js.jsx variable.language.this.js.jsx" }, "4": { "name": "entity.name.function.js.jsx" }, "5": { "name": "keyword.operator.optional.js.jsx" } }, "match": "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))" }, { "captures": { "1": { "name": "storage.modifier.js.jsx" }, "2": { "name": "keyword.operator.rest.js.jsx" }, "3": { "name": "variable.parameter.js.jsx variable.language.this.js.jsx" }, "4": { "name": "variable.parameter.js.jsx" }, "5": { "name": "keyword.operator.optional.js.jsx" } }, "match": "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)" }] }, "parameter-object-binding-element": { "patterns": [{ "include": "#comment" }, { "begin": "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))", "end": "(?=,|\\})", "patterns": [{ "include": "#object-binding-element-propertyName" }, { "include": "#parameter-binding-element" }, { "include": "#paren-expression" }] }, { "include": "#parameter-object-binding-pattern" }, { "include": "#destructuring-parameter-rest" }, { "include": "#variable-initializer" }, { "include": "#punctuation-comma" }] }, "parameter-object-binding-pattern": { "begin": "(?:(\\.\\.\\.)\\s*)?(\\{)", "beginCaptures": { "1": { "name": "keyword.operator.rest.js.jsx" }, "2": { "name": "punctuation.definition.binding-pattern.object.js.jsx" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.object.js.jsx" } }, "patterns": [{ "include": "#parameter-object-binding-element" }] }, "parameter-type-annotation": { "patterns": [{ "begin": "(:)", "beginCaptures": { "1": { "name": "keyword.operator.type.annotation.js.jsx" } }, "end": "(?=[,)])|(?==[^>])", "name": "meta.type.annotation.js.jsx", "patterns": [{ "include": "#type" }] }] }, "paren-expression": { "begin": "\\(", "beginCaptures": { "0": { "name": "meta.brace.round.js.jsx" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.js.jsx" } }, "patterns": [{ "include": "#expression" }] }, "paren-expression-possibly-arrow": { "patterns": [{ "begin": "(?<=[(=,])\\s*(async)?(?=\\s*((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?\\(\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))", "beginCaptures": { "1": { "name": "storage.modifier.async.js.jsx" } }, "end": "(?<=\\))", "patterns": [{ "include": "#paren-expression-possibly-arrow-with-typeparameters" }] }, { "begin": "(?<=[(=,]|=>|^return|[^\\._$[:alnum:]]return)\\s*(async)?(?=\\s*((((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?\\()|(<)|((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)))\\s*$)", "beginCaptures": { "1": { "name": "storage.modifier.async.js.jsx" } }, "end": "(?<=\\))", "patterns": [{ "include": "#paren-expression-possibly-arrow-with-typeparameters" }] }, { "include": "#possibly-arrow-return-type" }] }, "paren-expression-possibly-arrow-with-typeparameters": { "patterns": [{ "include": "#type-parameters" }, { "begin": "\\(", "beginCaptures": { "0": { "name": "meta.brace.round.js.jsx" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.js.jsx" } }, "patterns": [{ "include": "#expression-inside-possibly-arrow-parens" }] }] }, "possibly-arrow-return-type": { "begin": "(?<=\\)|^)\\s*(:)(?=\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*=>)", "beginCaptures": { "1": { "name": "meta.arrow.js.jsx meta.return.type.arrow.js.jsx keyword.operator.type.annotation.js.jsx" } }, "contentName": "meta.arrow.js.jsx meta.return.type.arrow.js.jsx", "end": "(?==>|\\{|(^\\s*(export|function|class|interface|let|var|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|const|import|enum|namespace|module|type|abstract|declare)\\s+))", "patterns": [{ "include": "#arrow-return-type-body" }] }, "property-accessor": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(accessor|get|set)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "storage.type.property.js.jsx" }, "punctuation-accessor": { "captures": { "1": { "name": "punctuation.accessor.js.jsx" }, "2": { "name": "punctuation.accessor.optional.js.jsx" } }, "match": "(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))" }, "punctuation-comma": { "match": ",", "name": "punctuation.separator.comma.js.jsx" }, "punctuation-semicolon": { "match": ";", "name": "punctuation.terminator.statement.js.jsx" }, "qstring-double": { "begin": '"', "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.js.jsx" } }, "end": '(")|((?:[^\\\\\\n])$)', "endCaptures": { "1": { "name": "punctuation.definition.string.end.js.jsx" }, "2": { "name": "invalid.illegal.newline.js.jsx" } }, "name": "string.quoted.double.js.jsx", "patterns": [{ "include": "#string-character-escape" }] }, "qstring-single": { "begin": "'", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.js.jsx" } }, "end": "(\\')|((?:[^\\\\\\n])$)", "endCaptures": { "1": { "name": "punctuation.definition.string.end.js.jsx" }, "2": { "name": "invalid.illegal.newline.js.jsx" } }, "name": "string.quoted.single.js.jsx", "patterns": [{ "include": "#string-character-escape" }] }, "regex": { "patterns": [{ "begin": "(?<!\\+\\+|--|})(?<=[=(:,\\[?+!]|^return|[^\\._$[:alnum:]]return|^case|[^\\._$[:alnum:]]case|=>|&&|\\|\\||\\*\\/)\\s*(\\/)(?![\\/*])(?=(?:[^\\/\\\\\\[\\()]|\\\\.|\\[([^\\]\\\\]|\\\\.)+\\]|\\(([^\\)\\\\]|\\\\.)+\\))+\\/([dgimsuy]+|(?![\\/\\*])|(?=\\/\\*))(?!\\s*[a-zA-Z0-9_$]))", "beginCaptures": { "1": { "name": "punctuation.definition.string.begin.js.jsx" } }, "end": "(/)([dgimsuy]*)", "endCaptures": { "1": { "name": "punctuation.definition.string.end.js.jsx" }, "2": { "name": "keyword.other.js.jsx" } }, "name": "string.regexp.js.jsx", "patterns": [{ "include": "#regexp" }] }, { "begin": "((?<![_$[:alnum:])\\]]|\\+\\+|--|}|\\*\\/)|((?<=^return|[^\\._$[:alnum:]]return|^case|[^\\._$[:alnum:]]case))\\s*)\\/(?![\\/*])(?=(?:[^\\/\\\\\\[]|\\\\.|\\[([^\\]\\\\]|\\\\.)*\\])+\\/([dgimsuy]+|(?![\\/\\*])|(?=\\/\\*))(?!\\s*[a-zA-Z0-9_$]))", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.js.jsx" } }, "end": "(/)([dgimsuy]*)", "endCaptures": { "1": { "name": "punctuation.definition.string.end.js.jsx" }, "2": { "name": "keyword.other.js.jsx" } }, "name": "string.regexp.js.jsx", "patterns": [{ "include": "#regexp" }] }] }, "regex-character-class": { "patterns": [{ "match": "\\\\[wWsSdDtrnvf]|\\.", "name": "constant.other.character-class.regexp" }, { "match": "\\\\([0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4})", "name": "constant.character.numeric.regexp" }, { "match": "\\\\c[A-Z]", "name": "constant.character.control.regexp" }, { "match": "\\\\.", "name": "constant.character.escape.backslash.regexp" }] }, "regexp": { "patterns": [{ "match": "\\\\[bB]|\\^|\\$", "name": "keyword.control.anchor.regexp" }, { "captures": { "0": { "name": "keyword.other.back-reference.regexp" }, "1": { "name": "variable.other.regexp" } }, "match": "\\\\[1-9]\\d*|\\\\k<([a-zA-Z_$][\\w$]*)>" }, { "match": "[?+*]|\\{(\\d+,\\d+|\\d+,|,\\d+|\\d+)\\}\\??", "name": "keyword.operator.quantifier.regexp" }, { "match": "\\|", "name": "keyword.operator.or.regexp" }, { "begin": "(\\()((\\?=)|(\\?!)|(\\?<=)|(\\?<!))", "beginCaptures": { "1": { "name": "punctuation.definition.group.regexp" }, "2": { "name": "punctuation.definition.group.assertion.regexp" }, "3": { "name": "meta.assertion.look-ahead.regexp" }, "4": { "name": "meta.assertion.negative-look-ahead.regexp" }, "5": { "name": "meta.assertion.look-behind.regexp" }, "6": { "name": "meta.assertion.negative-look-behind.regexp" } }, "end": "(\\))", "endCaptures": { "1": { "name": "punctuation.definition.group.regexp" } }, "name": "meta.group.assertion.regexp", "patterns": [{ "include": "#regexp" }] }, { "begin": "\\((?:(\\?:)|(?:\\?<([a-zA-Z_$][\\w$]*)>))?", "beginCaptures": { "0": { "name": "punctuation.definition.group.regexp" }, "1": { "name": "punctuation.definition.group.no-capture.regexp" }, "2": { "name": "variable.other.regexp" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.regexp" } }, "name": "meta.group.regexp", "patterns": [{ "include": "#regexp" }] }, { "begin": "(\\[)(\\^)?", "beginCaptures": { "1": { "name": "punctuation.definition.character-class.regexp" }, "2": { "name": "keyword.operator.negation.regexp" } }, "end": "(\\])", "endCaptures": { "1": { "name": "punctuation.definition.character-class.regexp" } }, "name": "constant.other.character-class.set.regexp", "patterns": [{ "captures": { "1": { "name": "constant.character.numeric.regexp" }, "2": { "name": "constant.character.control.regexp" }, "3": { "name": "constant.character.escape.backslash.regexp" }, "4": { "name": "constant.character.numeric.regexp" }, "5": { "name": "constant.character.control.regexp" }, "6": { "name": "constant.character.escape.backslash.regexp" } }, "match": "(?:.|(\\\\(?:[0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}))|(\\\\c[A-Z])|(\\\\.))\\-(?:[^\\]\\\\]|(\\\\(?:[0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}))|(\\\\c[A-Z])|(\\\\.))", "name": "constant.other.character-class.range.regexp" }, { "include": "#regex-character-class" }] }, { "include": "#regex-character-class" }] }, "return-type": { "patterns": [{ "begin": "(?<=\\))\\s*(:)(?=\\s*\\S)", "beginCaptures": { "1": { "name": "keyword.operator.type.annotation.js.jsx" } }, "end": "(?<![:|&])(?=$|^|[{};,]|//)", "name": "meta.return.type.js.jsx", "patterns": [{ "include": "#return-type-core" }] }, { "begin": "(?<=\\))\\s*(:)", "beginCaptures": { "1": { "name": "keyword.operator.type.annotation.js.jsx" } }, "end": "(?<![:|&])((?=[{};,]|//|^\\s*$)|((?<=\\S)(?=\\s*$)))", "name": "meta.return.type.js.jsx", "patterns": [{ "include": "#return-type-core" }] }] }, "return-type-core": { "patterns": [{ "include": "#comment" }, { "begin": "(?<=[:|&])(?=\\s*\\{)", "end": "(?<=\\})", "patterns": [{ "include": "#type-object" }] }, { "include": "#type-predicate-operator" }, { "include": "#type" }] }, "shebang": { "captures": { "1": { "name": "punctuation.definition.comment.js.jsx" } }, "match": "\\A(#!).*(?=$)", "name": "comment.line.shebang.js.jsx" }, "single-line-comment-consuming-line-ending": { "begin": "(^[ \\t]+)?((//)(?:\\s*((@)internal)(?=\\s|$))?)", "beginCaptures": { "1": { "name": "punctuation.whitespace.comment.leading.js.jsx" }, "2": { "name": "comment.line.double-slash.js.jsx" }, "3": { "name": "punctuation.definition.comment.js.jsx" }, "4": { "name": "storage.type.internaldeclaration.js.jsx" }, "5": { "name": "punctuation.decorator.internaldeclaration.js.jsx" } }, "contentName": "comment.line.double-slash.js.jsx", "end": "(?=^)" }, "statements": { "patterns": [{ "include": "#declaration" }, { "include": "#control-statement" }, { "include": "#after-operator-block-as-object-literal" }, { "include": "#decl-block" }, { "include": "#label" }, { "include": "#expression" }, { "include": "#punctuation-semicolon" }, { "include": "#string" }, { "include": "#comment" }] }, "string": { "patterns": [{ "include": "#qstring-single" }, { "include": "#qstring-double" }, { "include": "#template" }] }, "string-character-escape": { "match": "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|u\\{[0-9A-Fa-f]+\\}|[0-2][0-7]{0,2}|3[0-6][0-7]?|37[0-7]?|[4-7][0-7]?|.|$)", "name": "constant.character.escape.js.jsx" }, "super-literal": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))super\\b(?!\\$)", "name": "variable.language.super.js.jsx" }, "support-function-call-identifiers": { "patterns": [{ "include": "#literal" }, { "include": "#support-objects" }, { "include": "#object-identifiers" }, { "include": "#punctuation-accessor" }, { "match": "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))import(?=\\s*[\\(]\\s*[\\\"\\'\\`]))", "name": "keyword.operator.expression.import.js.jsx" }] }, "support-objects": { "patterns": [{ "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(arguments)\\b(?!\\$)", "name": "variable.language.arguments.js.jsx" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(Promise)\\b(?!\\$)", "name": "support.class.promise.js.jsx" }, { "captures": { "1": { "name": "keyword.control.import.js.jsx" }, "2": { "name": "punctuation.accessor.js.jsx" }, "3": { "name": "punctuation.accessor.optional.js.jsx" }, "4": { "name": "support.variable.property.importmeta.js.jsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(import)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(meta)\\b(?!\\$)" }, { "captures": { "1": { "name": "keyword.operator.new.js.jsx" }, "2": { "name": "punctuation.accessor.js.jsx" }, "3": { "name": "punctuation.accessor.optional.js.jsx" }, "4": { "name": "support.variable.property.target.js.jsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(new)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(target)\\b(?!\\$)" }, { "captures": { "1": { "name": "punctuation.accessor.js.jsx" }, "2": { "name": "punctuation.accessor.optional.js.jsx" }, "3": { "name": "support.variable.property.js.jsx" }, "4": { "name": "support.constant.js.jsx" } }, "match": "(?x) (?:(\\.)|(\\?\\.(?!\\s*[[:digit:]]))) \\s* (?:\n  (?:(constructor|length|prototype|__proto__)\\b(?!\\$|\\s*(<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\\())\n  |\n  (?:(EPSILON|MAX_SAFE_INTEGER|MAX_VALUE|MIN_SAFE_INTEGER|MIN_VALUE|NEGATIVE_INFINITY|POSITIVE_INFINITY)\\b(?!\\$)))" }, { "captures": { "1": { "name": "support.type.object.module.js.jsx" }, "2": { "name": "support.type.object.module.js.jsx" }, "3": { "name": "punctuation.accessor.js.jsx" }, "4": { "name": "punctuation.accessor.optional.js.jsx" }, "5": { "name": "support.type.object.module.js.jsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(exports)|(module)(?:(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))(exports|id|filename|loaded|parent|children))?)\\b(?!\\$)" }] }, "switch-statement": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?=\\bswitch\\s*\\()", "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.js.jsx" } }, "name": "switch-statement.expr.js.jsx", "patterns": [{ "include": "#comment" }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(switch)\\s*(\\()", "beginCaptures": { "1": { "name": "keyword.control.switch.js.jsx" }, "2": { "name": "meta.brace.round.js.jsx" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.js.jsx" } }, "name": "switch-expression.expr.js.jsx", "patterns": [{ "include": "#expression" }] }, { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.block.js.jsx" } }, "end": "(?=\\})", "name": "switch-block.expr.js.jsx", "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(case|default(?=:))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "1": { "name": "keyword.control.switch.js.jsx" } }, "end": "(?=:)", "name": "case-clause.expr.js.jsx", "patterns": [{ "include": "#expression" }] }, { "begin": "(:)\\s*(\\{)", "beginCaptures": { "1": { "name": "case-clause.expr.js.jsx punctuation.definition.section.case-statement.js.jsx" }, "2": { "name": "meta.block.js.jsx punctuation.definition.block.js.jsx" } }, "contentName": "meta.block.js.jsx", "end": "\\}", "endCaptures": { "0": { "name": "meta.block.js.jsx punctuation.definition.block.js.jsx" } }, "patterns": [{ "include": "#statements" }] }, { "captures": { "0": { "name": "case-clause.expr.js.jsx punctuation.definition.section.case-statement.js.jsx" } }, "match": "(:)" }, { "include": "#statements" }] }] }, "template": { "patterns": [{ "include": "#template-call" }, { "begin": "([_$[:alpha:]][_$[:alnum:]]*)?(`)", "beginCaptures": { "1": { "name": "entity.name.function.tagged-template.js.jsx" }, "2": { "name": "string.template.js.jsx punctuation.definition.string.template.begin.js.jsx" } }, "contentName": "string.template.js.jsx", "end": "`", "endCaptures": { "0": { "name": "string.template.js.jsx punctuation.definition.string.template.end.js.jsx" } }, "patterns": [{ "include": "#template-substitution-element" }, { "include": "#string-character-escape" }] }] }, "template-call": { "patterns": [{ "begin": "(?=(([_$[:alpha:]][_$[:alnum:]]*\\s*\\??\\.\\s*)*|(\\??\\.\\s*)?)([_$[:alpha:]][_$[:alnum:]]*)(<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?`)", "end": "(?=`)", "patterns": [{ "begin": "(?=(([_$[:alpha:]][_$[:alnum:]]*\\s*\\??\\.\\s*)*|(\\??\\.\\s*)?)([_$[:alpha:]][_$[:alnum:]]*))", "end": "(?=(<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?`)", "patterns": [{ "include": "#support-function-call-identifiers" }, { "match": "([_$[:alpha:]][_$[:alnum:]]*)", "name": "entity.name.function.tagged-template.js.jsx" }] }, { "include": "#type-arguments" }] }, { "begin": "([_$[:alpha:]][_$[:alnum:]]*)?\\s*(?=(<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)`)", "beginCaptures": { "1": { "name": "entity.name.function.tagged-template.js.jsx" } }, "end": "(?=`)", "patterns": [{ "include": "#type-arguments" }] }] }, "template-substitution-element": { "begin": "\\$\\{", "beginCaptures": { "0": { "name": "punctuation.definition.template-expression.begin.js.jsx" } }, "contentName": "meta.embedded.line.js.jsx", "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.template-expression.end.js.jsx" } }, "name": "meta.template.expression.js.jsx", "patterns": [{ "include": "#expression" }] }, "template-type": { "patterns": [{ "include": "#template-call" }, { "begin": "([_$[:alpha:]][_$[:alnum:]]*)?(`)", "beginCaptures": { "1": { "name": "entity.name.function.tagged-template.js.jsx" }, "2": { "name": "string.template.js.jsx punctuation.definition.string.template.begin.js.jsx" } }, "contentName": "string.template.js.jsx", "end": "`", "endCaptures": { "0": { "name": "string.template.js.jsx punctuation.definition.string.template.end.js.jsx" } }, "patterns": [{ "include": "#template-type-substitution-element" }, { "include": "#string-character-escape" }] }] }, "template-type-substitution-element": { "begin": "\\$\\{", "beginCaptures": { "0": { "name": "punctuation.definition.template-expression.begin.js.jsx" } }, "contentName": "meta.embedded.line.js.jsx", "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.template-expression.end.js.jsx" } }, "name": "meta.template.expression.js.jsx", "patterns": [{ "include": "#type" }] }, "ternary-expression": { "begin": "(?!\\?\\.\\s*[^[:digit:]])(\\?)(?!\\?)", "beginCaptures": { "1": { "name": "keyword.operator.ternary.js.jsx" } }, "end": "\\s*(:)", "endCaptures": { "1": { "name": "keyword.operator.ternary.js.jsx" } }, "patterns": [{ "include": "#expression" }] }, "this-literal": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))this\\b(?!\\$)", "name": "variable.language.this.js.jsx" }, "type": { "patterns": [{ "include": "#comment" }, { "include": "#type-string" }, { "include": "#numeric-literal" }, { "include": "#type-primitive" }, { "include": "#type-builtin-literals" }, { "include": "#type-parameters" }, { "include": "#type-tuple" }, { "include": "#type-object" }, { "include": "#type-operators" }, { "include": "#type-conditional" }, { "include": "#type-fn-type-parameters" }, { "include": "#type-paren-or-function-parameters" }, { "include": "#type-function-return-type" }, { "captures": { "1": { "name": "storage.modifier.js.jsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(readonly)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*" }, { "include": "#type-name" }] }, "type-alias-declaration": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(type)\\b\\s+([_$[:alpha:]][_$[:alnum:]]*)\\s*", "beginCaptures": { "1": { "name": "keyword.control.export.js.jsx" }, "2": { "name": "storage.modifier.js.jsx" }, "3": { "name": "storage.type.type.js.jsx" }, "4": { "name": "entity.name.type.alias.js.jsx" } }, "end": "(?=\\}|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "name": "meta.type.declaration.js.jsx", "patterns": [{ "include": "#comment" }, { "include": "#type-parameters" }, { "begin": "(=)\\s*(intrinsic)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "1": { "name": "keyword.operator.assignment.js.jsx" }, "2": { "name": "keyword.control.intrinsic.js.jsx" } }, "end": "(?=\\}|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "patterns": [{ "include": "#type" }] }, { "begin": "(=)\\s*", "beginCaptures": { "1": { "name": "keyword.operator.assignment.js.jsx" } }, "end": "(?=\\}|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "patterns": [{ "include": "#type" }] }] }, "type-annotation": { "patterns": [{ "begin": "(:)(?=\\s*\\S)", "beginCaptures": { "1": { "name": "keyword.operator.type.annotation.js.jsx" } }, "end": "(?<![:|&])(?!\\s*[|&]\\s+)((?=^|[,);\\}\\]]|//)|(?==[^>])|((?<=[\\}>\\]\\)]|[_$[:alpha:]])\\s*(?=\\{)))", "name": "meta.type.annotation.js.jsx", "patterns": [{ "include": "#type" }] }, { "begin": "(:)", "beginCaptures": { "1": { "name": "keyword.operator.type.annotation.js.jsx" } }, "end": "(?<![:|&])((?=[,);\\}\\]]|\\/\\/)|(?==[^>])|(?=^\\s*$)|((?<=[\\}>\\]\\)]|[_$[:alpha:]])\\s*(?=\\{)))", "name": "meta.type.annotation.js.jsx", "patterns": [{ "include": "#type" }] }] }, "type-arguments": { "begin": "\\<", "beginCaptures": { "0": { "name": "punctuation.definition.typeparameters.begin.js.jsx" } }, "end": "\\>", "endCaptures": { "0": { "name": "punctuation.definition.typeparameters.end.js.jsx" } }, "name": "meta.type.parameters.js.jsx", "patterns": [{ "include": "#type-arguments-body" }] }, "type-arguments-body": { "patterns": [{ "captures": { "0": { "name": "keyword.operator.type.js.jsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(_)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))" }, { "include": "#type" }, { "include": "#punctuation-comma" }] }, "type-builtin-literals": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(this|true|false|undefined|null|object)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "support.type.builtin.js.jsx" }, "type-conditional": { "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(extends)\\s+", "beginCaptures": { "1": { "name": "storage.modifier.js.jsx" } }, "end": "(?<=:)", "patterns": [{ "begin": "\\?", "beginCaptures": { "0": { "name": "keyword.operator.ternary.js.jsx" } }, "end": ":", "endCaptures": { "0": { "name": "keyword.operator.ternary.js.jsx" } }, "patterns": [{ "include": "#type" }] }, { "include": "#type" }] }] }, "type-fn-type-parameters": { "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(abstract)\\s+)?(new)\\b(?=\\s*\\<)", "beginCaptures": { "1": { "name": "meta.type.constructor.js.jsx storage.modifier.js.jsx" }, "2": { "name": "meta.type.constructor.js.jsx keyword.control.new.js.jsx" } }, "end": "(?<=>)", "patterns": [{ "include": "#comment" }, { "include": "#type-parameters" }] }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(abstract)\\s+)?(new)\\b\\s*(?=\\()", "beginCaptures": { "1": { "name": "storage.modifier.js.jsx" }, "2": { "name": "keyword.control.new.js.jsx" } }, "end": "(?<=\\))", "name": "meta.type.constructor.js.jsx", "patterns": [{ "include": "#function-parameters" }] }, { "begin": "(?x)(\n  (?=\n    [(]\\s*(\n      ([)]) |\n      (\\.\\.\\.) |\n      ([_$[:alnum:]]+\\s*(\n        ([:,?=])|\n        ([)]\\s*=>)\n      ))\n    )\n  )\n)", "end": "(?<=\\))", "name": "meta.type.function.js.jsx", "patterns": [{ "include": "#function-parameters" }] }] }, "type-function-return-type": { "patterns": [{ "begin": "(=>)(?=\\s*\\S)", "beginCaptures": { "1": { "name": "storage.type.function.arrow.js.jsx" } }, "end": "(?<!=>)(?<![|&])(?=[,\\]\\)\\{\\}=;>:\\?]|//|$)", "name": "meta.type.function.return.js.jsx", "patterns": [{ "include": "#type-function-return-type-core" }] }, { "begin": "=>", "beginCaptures": { "0": { "name": "storage.type.function.arrow.js.jsx" } }, "end": "(?<!=>)(?<![|&])((?=[,\\]\\)\\{\\}=;:\\?>]|//|^\\s*$)|((?<=\\S)(?=\\s*$)))", "name": "meta.type.function.return.js.jsx", "patterns": [{ "include": "#type-function-return-type-core" }] }] }, "type-function-return-type-core": { "patterns": [{ "include": "#comment" }, { "begin": "(?<==>)(?=\\s*\\{)", "end": "(?<=\\})", "patterns": [{ "include": "#type-object" }] }, { "include": "#type-predicate-operator" }, { "include": "#type" }] }, "type-infer": { "patterns": [{ "captures": { "1": { "name": "keyword.operator.expression.infer.js.jsx" }, "2": { "name": "entity.name.type.js.jsx" }, "3": { "name": "keyword.operator.expression.extends.js.jsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(infer)\\s+([_$[:alpha:]][_$[:alnum:]]*)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?:\\s+(extends)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))?", "name": "meta.type.infer.js.jsx" }] }, "type-name": { "patterns": [{ "begin": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(<)", "captures": { "1": { "name": "entity.name.type.module.js.jsx" }, "2": { "name": "punctuation.accessor.js.jsx" }, "3": { "name": "punctuation.accessor.optional.js.jsx" }, "4": { "name": "meta.type.parameters.js.jsx punctuation.definition.typeparameters.begin.js.jsx" } }, "contentName": "meta.type.parameters.js.jsx", "end": "(>)", "endCaptures": { "1": { "name": "meta.type.parameters.js.jsx punctuation.definition.typeparameters.end.js.jsx" } }, "patterns": [{ "include": "#type-arguments-body" }] }, { "begin": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(<)", "beginCaptures": { "1": { "name": "entity.name.type.js.jsx" }, "2": { "name": "meta.type.parameters.js.jsx punctuation.definition.typeparameters.begin.js.jsx" } }, "contentName": "meta.type.parameters.js.jsx", "end": "(>)", "endCaptures": { "1": { "name": "meta.type.parameters.js.jsx punctuation.definition.typeparameters.end.js.jsx" } }, "patterns": [{ "include": "#type-arguments-body" }] }, { "captures": { "1": { "name": "entity.name.type.module.js.jsx" }, "2": { "name": "punctuation.accessor.js.jsx" }, "3": { "name": "punctuation.accessor.optional.js.jsx" } }, "match": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))" }, { "match": "[_$[:alpha:]][_$[:alnum:]]*", "name": "entity.name.type.js.jsx" }] }, "type-object": { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.block.js.jsx" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.js.jsx" } }, "name": "meta.object.type.js.jsx", "patterns": [{ "include": "#comment" }, { "include": "#method-declaration" }, { "include": "#indexer-declaration" }, { "include": "#indexer-mapped-type-declaration" }, { "include": "#field-declaration" }, { "include": "#type-annotation" }, { "begin": "\\.\\.\\.", "beginCaptures": { "0": { "name": "keyword.operator.spread.js.jsx" } }, "end": "(?=\\}|;|,|$)|(?<=\\})", "patterns": [{ "include": "#type" }] }, { "include": "#punctuation-comma" }, { "include": "#punctuation-semicolon" }, { "include": "#type" }] }, "type-operators": { "patterns": [{ "include": "#typeof-operator" }, { "include": "#type-infer" }, { "begin": "([&|])(?=\\s*\\{)", "beginCaptures": { "0": { "name": "keyword.operator.type.js.jsx" } }, "end": "(?<=\\})", "patterns": [{ "include": "#type-object" }] }, { "begin": "[&|]", "beginCaptures": { "0": { "name": "keyword.operator.type.js.jsx" } }, "end": "(?=\\S)" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))keyof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.operator.expression.keyof.js.jsx" }, { "match": "(\\?|\\:)", "name": "keyword.operator.ternary.js.jsx" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))import(?=\\s*\\()", "name": "keyword.operator.expression.import.js.jsx" }] }, "type-parameters": { "begin": "(<)", "beginCaptures": { "1": { "name": "punctuation.definition.typeparameters.begin.js.jsx" } }, "end": "(>)", "endCaptures": { "1": { "name": "punctuation.definition.typeparameters.end.js.jsx" } }, "name": "meta.type.parameters.js.jsx", "patterns": [{ "include": "#comment" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(extends|in|out|const)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "storage.modifier.js.jsx" }, { "include": "#type" }, { "include": "#punctuation-comma" }, { "match": "(=)(?!>)", "name": "keyword.operator.assignment.js.jsx" }] }, "type-paren-or-function-parameters": { "begin": "\\(", "beginCaptures": { "0": { "name": "meta.brace.round.js.jsx" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.js.jsx" } }, "name": "meta.type.paren.cover.js.jsx", "patterns": [{ "captures": { "1": { "name": "storage.modifier.js.jsx" }, "2": { "name": "keyword.operator.rest.js.jsx" }, "3": { "name": "entity.name.function.js.jsx variable.language.this.js.jsx" }, "4": { "name": "entity.name.function.js.jsx" }, "5": { "name": "keyword.operator.optional.js.jsx" } }, "match": "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))\\s*(\\??)(?=\\s*(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))))" }, { "captures": { "1": { "name": "storage.modifier.js.jsx" }, "2": { "name": "keyword.operator.rest.js.jsx" }, "3": { "name": "variable.parameter.js.jsx variable.language.this.js.jsx" }, "4": { "name": "variable.parameter.js.jsx" }, "5": { "name": "keyword.operator.optional.js.jsx" } }, "match": "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))\\s*(\\??)(?=:)" }, { "include": "#type-annotation" }, { "match": ",", "name": "punctuation.separator.parameter.js.jsx" }, { "include": "#type" }] }, "type-predicate-operator": { "patterns": [{ "captures": { "1": { "name": "keyword.operator.type.asserts.js.jsx" }, "2": { "name": "variable.parameter.js.jsx variable.language.this.js.jsx" }, "3": { "name": "variable.parameter.js.jsx" }, "4": { "name": "keyword.operator.expression.is.js.jsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(asserts)\\s+)?(?!asserts)(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))\\s(is)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))" }, { "captures": { "1": { "name": "keyword.operator.type.asserts.js.jsx" }, "2": { "name": "variable.parameter.js.jsx variable.language.this.js.jsx" }, "3": { "name": "variable.parameter.js.jsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(asserts)\\s+(?!is)(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))asserts(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.operator.type.asserts.js.jsx" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))is(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.operator.expression.is.js.jsx" }] }, "type-primitive": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(string|number|bigint|boolean|symbol|any|void|never|unknown)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "support.type.primitive.js.jsx" }, "type-string": { "patterns": [{ "include": "#qstring-single" }, { "include": "#qstring-double" }, { "include": "#template-type" }] }, "type-tuple": { "begin": "\\[", "beginCaptures": { "0": { "name": "meta.brace.square.js.jsx" } }, "end": "\\]", "endCaptures": { "0": { "name": "meta.brace.square.js.jsx" } }, "name": "meta.type.tuple.js.jsx", "patterns": [{ "match": "\\.\\.\\.", "name": "keyword.operator.rest.js.jsx" }, { "captures": { "1": { "name": "entity.name.label.js.jsx" }, "2": { "name": "keyword.operator.optional.js.jsx" }, "3": { "name": "punctuation.separator.label.js.jsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))([_$[:alpha:]][_$[:alnum:]]*)\\s*(\\?)?\\s*(:)" }, { "include": "#type" }, { "include": "#punctuation-comma" }] }, "typeof-operator": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))typeof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "0": { "name": "keyword.operator.expression.typeof.js.jsx" } }, "end": "(?=[,);}\\]=>:&|{\\?]|(extends\\s+)|$|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "patterns": [{ "include": "#type-arguments" }, { "include": "#expression" }] }, "undefined-literal": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))undefined(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "constant.language.undefined.js.jsx" }, "var-expr": { "patterns": [{ "begin": "(?=(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(var|let)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))", "end": "(?!(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(var|let)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))((?=^|;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))|((?<!^let|[^\\._$[:alnum:]]let|^var|[^\\._$[:alnum:]]var)(?=\\s*$)))", "name": "meta.var.expr.js.jsx", "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(var|let)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*", "beginCaptures": { "1": { "name": "keyword.control.export.js.jsx" }, "2": { "name": "storage.modifier.js.jsx" }, "3": { "name": "storage.type.js.jsx" } }, "end": "(?=\\S)" }, { "include": "#destructuring-variable" }, { "include": "#var-single-variable" }, { "include": "#variable-initializer" }, { "include": "#comment" }, { "begin": "(,)\\s*(?=$|\\/\\/)", "beginCaptures": { "1": { "name": "punctuation.separator.comma.js.jsx" } }, "end": "(?<!,)(((?==|;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|^\\s*$))|((?<=\\S)(?=\\s*$)))", "patterns": [{ "include": "#single-line-comment-consuming-line-ending" }, { "include": "#comment" }, { "include": "#destructuring-variable" }, { "include": "#var-single-variable" }, { "include": "#punctuation-comma" }] }, { "include": "#punctuation-comma" }] }, { "begin": "(?=(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(const(?!\\s+enum\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))", "beginCaptures": { "1": { "name": "keyword.control.export.js.jsx" }, "2": { "name": "storage.modifier.js.jsx" }, "3": { "name": "storage.type.js.jsx" } }, "end": "(?!(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(const(?!\\s+enum\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))((?=^|;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))|((?<!^const|[^\\._$[:alnum:]]const)(?=\\s*$)))", "name": "meta.var.expr.js.jsx", "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(const(?!\\s+enum\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*", "beginCaptures": { "1": { "name": "keyword.control.export.js.jsx" }, "2": { "name": "storage.modifier.js.jsx" }, "3": { "name": "storage.type.js.jsx" } }, "end": "(?=\\S)" }, { "include": "#destructuring-const" }, { "include": "#var-single-const" }, { "include": "#variable-initializer" }, { "include": "#comment" }, { "begin": "(,)\\s*(?=$|\\/\\/)", "beginCaptures": { "1": { "name": "punctuation.separator.comma.js.jsx" } }, "end": "(?<!,)(((?==|;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|^\\s*$))|((?<=\\S)(?=\\s*$)))", "patterns": [{ "include": "#single-line-comment-consuming-line-ending" }, { "include": "#comment" }, { "include": "#destructuring-const" }, { "include": "#var-single-const" }, { "include": "#punctuation-comma" }] }, { "include": "#punctuation-comma" }] }, { "begin": "(?=(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b((?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))", "beginCaptures": { "1": { "name": "keyword.control.export.js.jsx" }, "2": { "name": "storage.modifier.js.jsx" }, "3": { "name": "storage.type.js.jsx" } }, "end": "(?!(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b((?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))((?=;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))|((?<!^using|[^\\._$[:alnum:]]using|^await\\s+using|[^\\._$[:alnum:]]await\\s+using)(?=\\s*$)))", "name": "meta.var.expr.js.jsx", "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b((?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*", "beginCaptures": { "1": { "name": "keyword.control.export.js.jsx" }, "2": { "name": "storage.modifier.js.jsx" }, "3": { "name": "storage.type.js.jsx" } }, "end": "(?=\\S)" }, { "include": "#var-single-const" }, { "include": "#variable-initializer" }, { "include": "#comment" }, { "begin": "(,)\\s*((?!\\S)|(?=\\/\\/))", "beginCaptures": { "1": { "name": "punctuation.separator.comma.js.jsx" } }, "end": "(?<!,)(((?==|;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|^\\s*$))|((?<=\\S)(?=\\s*$)))", "patterns": [{ "include": "#single-line-comment-consuming-line-ending" }, { "include": "#comment" }, { "include": "#var-single-const" }, { "include": "#punctuation-comma" }] }, { "include": "#punctuation-comma" }] }] }, "var-single-const": { "patterns": [{ "begin": "(?x)([_$[:alpha:]][_$[:alnum:]]*)(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))", "beginCaptures": { "1": { "name": "meta.definition.variable.js.jsx variable.other.constant.js.jsx entity.name.function.js.jsx" } }, "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|(;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b)))", "name": "meta.var-single-variable.expr.js.jsx", "patterns": [{ "include": "#var-single-variable-type-annotation" }] }, { "begin": "([_$[:alpha:]][_$[:alnum:]]*)", "beginCaptures": { "1": { "name": "meta.definition.variable.js.jsx variable.other.constant.js.jsx" } }, "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|(;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b)))", "name": "meta.var-single-variable.expr.js.jsx", "patterns": [{ "include": "#var-single-variable-type-annotation" }] }] }, "var-single-variable": { "patterns": [{ "begin": "(?x)([_$[:alpha:]][_$[:alnum:]]*)(\\!)?(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))", "beginCaptures": { "1": { "name": "meta.definition.variable.js.jsx entity.name.function.js.jsx" }, "2": { "name": "keyword.operator.definiteassignment.js.jsx" } }, "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|(;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b)))", "name": "meta.var-single-variable.expr.js.jsx", "patterns": [{ "include": "#var-single-variable-type-annotation" }] }, { "begin": "([[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])(\\!)?", "beginCaptures": { "1": { "name": "meta.definition.variable.js.jsx variable.other.constant.js.jsx" }, "2": { "name": "keyword.operator.definiteassignment.js.jsx" } }, "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|(;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b)))", "name": "meta.var-single-variable.expr.js.jsx", "patterns": [{ "include": "#var-single-variable-type-annotation" }] }, { "begin": "([_$[:alpha:]][_$[:alnum:]]*)(\\!)?", "beginCaptures": { "1": { "name": "meta.definition.variable.js.jsx variable.other.readwrite.js.jsx" }, "2": { "name": "keyword.operator.definiteassignment.js.jsx" } }, "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|(;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b)))", "name": "meta.var-single-variable.expr.js.jsx", "patterns": [{ "include": "#var-single-variable-type-annotation" }] }] }, "var-single-variable-type-annotation": { "patterns": [{ "include": "#type-annotation" }, { "include": "#string" }, { "include": "#comment" }] }, "variable-initializer": { "patterns": [{ "begin": "(?<!=|!)(=)(?!=)(?=\\s*\\S)(?!\\s*.*=>\\s*$)", "beginCaptures": { "1": { "name": "keyword.operator.assignment.js.jsx" } }, "end": "(?=$|^|[,);}\\]]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))", "patterns": [{ "include": "#expression" }] }, { "begin": "(?<!=|!)(=)(?!=)", "beginCaptures": { "1": { "name": "keyword.operator.assignment.js.jsx" } }, "end": "(?=[,);}\\]]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))|(?=^\\s*$)|(?<![\\|\\&\\+\\-\\*\\/])(?<=\\S)(?<!=)(?=\\s*$)", "patterns": [{ "include": "#expression" }] }] } }, "scopeName": "source.js.jsx" });
var jsx = [
  lang$c
];
var lang$b = Object.freeze({ "displayName": "TSX", "name": "tsx", "patterns": [{ "include": "#directives" }, { "include": "#statements" }, { "include": "#shebang" }], "repository": { "access-modifier": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(abstract|declare|override|public|protected|private|readonly|static)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "storage.modifier.tsx" }, "after-operator-block-as-object-literal": { "begin": "(?<!\\+\\+|--)(?<=[:=(,\\[?+!>]|^await|[^\\._$[:alnum:]]await|^return|[^\\._$[:alnum:]]return|^yield|[^\\._$[:alnum:]]yield|^throw|[^\\._$[:alnum:]]throw|^in|[^\\._$[:alnum:]]in|^of|[^\\._$[:alnum:]]of|^typeof|[^\\._$[:alnum:]]typeof|&&|\\|\\||\\*)\\s*(\\{)", "beginCaptures": { "1": { "name": "punctuation.definition.block.tsx" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.tsx" } }, "name": "meta.objectliteral.tsx", "patterns": [{ "include": "#object-member" }] }, "array-binding-pattern": { "begin": "(?:(\\.\\.\\.)\\s*)?(\\[)", "beginCaptures": { "1": { "name": "keyword.operator.rest.tsx" }, "2": { "name": "punctuation.definition.binding-pattern.array.tsx" } }, "end": "\\]", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.array.tsx" } }, "patterns": [{ "include": "#binding-element" }, { "include": "#punctuation-comma" }] }, "array-binding-pattern-const": { "begin": "(?:(\\.\\.\\.)\\s*)?(\\[)", "beginCaptures": { "1": { "name": "keyword.operator.rest.tsx" }, "2": { "name": "punctuation.definition.binding-pattern.array.tsx" } }, "end": "\\]", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.array.tsx" } }, "patterns": [{ "include": "#binding-element-const" }, { "include": "#punctuation-comma" }] }, "array-literal": { "begin": "\\s*(\\[)", "beginCaptures": { "1": { "name": "meta.brace.square.tsx" } }, "end": "\\]", "endCaptures": { "0": { "name": "meta.brace.square.tsx" } }, "name": "meta.array.literal.tsx", "patterns": [{ "include": "#expression" }, { "include": "#punctuation-comma" }] }, "arrow-function": { "patterns": [{ "captures": { "1": { "name": "storage.modifier.async.tsx" }, "2": { "name": "variable.parameter.tsx" } }, "match": "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(\\basync)\\s+)?([_$[:alpha:]][_$[:alnum:]]*)\\s*(?==>)", "name": "meta.arrow.tsx" }, { "begin": "(?x) (?:\n  (?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(\\basync)\n)? ((?<![})!\\]])\\s*\n  (?=\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  )\n)", "beginCaptures": { "1": { "name": "storage.modifier.async.tsx" } }, "end": "(?==>|\\{|(^\\s*(export|function|class|interface|let|var|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|const|import|enum|namespace|module|type|abstract|declare)\\s+))", "name": "meta.arrow.tsx", "patterns": [{ "include": "#comment" }, { "include": "#type-parameters" }, { "include": "#function-parameters" }, { "include": "#arrow-return-type" }, { "include": "#possibly-arrow-return-type" }] }, { "begin": "=>", "beginCaptures": { "0": { "name": "storage.type.function.arrow.tsx" } }, "end": "((?<=\\}|\\S)(?<!=>)|((?!\\{)(?=\\S)))(?!\\/[\\/\\*])", "name": "meta.arrow.tsx", "patterns": [{ "include": "#single-line-comment-consuming-line-ending" }, { "include": "#decl-block" }, { "include": "#expression" }] }] }, "arrow-return-type": { "begin": "(?<=\\))\\s*(:)", "beginCaptures": { "1": { "name": "keyword.operator.type.annotation.tsx" } }, "end": "(?==>|\\{|(^\\s*(export|function|class|interface|let|var|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|const|import|enum|namespace|module|type|abstract|declare)\\s+))", "name": "meta.return.type.arrow.tsx", "patterns": [{ "include": "#arrow-return-type-body" }] }, "arrow-return-type-body": { "patterns": [{ "begin": "(?<=[:])(?=\\s*\\{)", "end": "(?<=\\})", "patterns": [{ "include": "#type-object" }] }, { "include": "#type-predicate-operator" }, { "include": "#type" }] }, "async-modifier": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(async)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "storage.modifier.async.tsx" }, "binding-element": { "patterns": [{ "include": "#comment" }, { "include": "#string" }, { "include": "#numeric-literal" }, { "include": "#regex" }, { "include": "#object-binding-pattern" }, { "include": "#array-binding-pattern" }, { "include": "#destructuring-variable-rest" }, { "include": "#variable-initializer" }] }, "binding-element-const": { "patterns": [{ "include": "#comment" }, { "include": "#string" }, { "include": "#numeric-literal" }, { "include": "#regex" }, { "include": "#object-binding-pattern-const" }, { "include": "#array-binding-pattern-const" }, { "include": "#destructuring-variable-rest-const" }, { "include": "#variable-initializer" }] }, "boolean-literal": { "patterns": [{ "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))true(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "constant.language.boolean.true.tsx" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))false(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "constant.language.boolean.false.tsx" }] }, "brackets": { "patterns": [{ "begin": "{", "end": "}|(?=\\*/)", "patterns": [{ "include": "#brackets" }] }, { "begin": "\\[", "end": "\\]|(?=\\*/)", "patterns": [{ "include": "#brackets" }] }] }, "cast": { "patterns": [{ "include": "#jsx" }] }, "class-declaration": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(?:(abstract)\\s+)?\\b(class)\\b(?=\\s+|/[/*])", "beginCaptures": { "1": { "name": "keyword.control.export.tsx" }, "2": { "name": "storage.modifier.tsx" }, "3": { "name": "storage.modifier.tsx" }, "4": { "name": "storage.type.class.tsx" } }, "end": "(?<=\\})", "name": "meta.class.tsx", "patterns": [{ "include": "#class-declaration-or-expression-patterns" }] }, "class-declaration-or-expression-patterns": { "patterns": [{ "include": "#comment" }, { "include": "#class-or-interface-heritage" }, { "captures": { "0": { "name": "entity.name.type.class.tsx" } }, "match": "[_$[:alpha:]][_$[:alnum:]]*" }, { "include": "#type-parameters" }, { "include": "#class-or-interface-body" }] }, "class-expression": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(abstract)\\s+)?(class)\\b(?=\\s+|[<{]|\\/[\\/*])", "beginCaptures": { "1": { "name": "storage.modifier.tsx" }, "2": { "name": "storage.type.class.tsx" } }, "end": "(?<=\\})", "name": "meta.class.tsx", "patterns": [{ "include": "#class-declaration-or-expression-patterns" }] }, "class-or-interface-body": { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.block.tsx" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.tsx" } }, "patterns": [{ "include": "#comment" }, { "include": "#decorator" }, { "begin": "(?<=:)\\s*", "end": "(?=\\s|[;),}\\]:\\-\\+]|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "patterns": [{ "include": "#expression" }] }, { "include": "#method-declaration" }, { "include": "#indexer-declaration" }, { "include": "#field-declaration" }, { "include": "#string" }, { "include": "#type-annotation" }, { "include": "#variable-initializer" }, { "include": "#access-modifier" }, { "include": "#property-accessor" }, { "include": "#async-modifier" }, { "include": "#after-operator-block-as-object-literal" }, { "include": "#decl-block" }, { "include": "#expression" }, { "include": "#punctuation-comma" }, { "include": "#punctuation-semicolon" }] }, "class-or-interface-heritage": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(extends|implements)\\b)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "1": { "name": "storage.modifier.tsx" } }, "end": "(?=\\{)", "patterns": [{ "include": "#comment" }, { "include": "#class-or-interface-heritage" }, { "include": "#type-parameters" }, { "include": "#expressionWithoutIdentifiers" }, { "captures": { "1": { "name": "entity.name.type.module.tsx" }, "2": { "name": "punctuation.accessor.tsx" }, "3": { "name": "punctuation.accessor.optional.tsx" } }, "match": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))(?=\\s*[_$[:alpha:]][_$[:alnum:]]*(\\s*\\??\\.\\s*[_$[:alpha:]][_$[:alnum:]]*)*\\s*)" }, { "captures": { "1": { "name": "entity.other.inherited-class.tsx" } }, "match": "([_$[:alpha:]][_$[:alnum:]]*)" }, { "include": "#expressionPunctuations" }] }, "comment": { "patterns": [{ "begin": "/\\*\\*(?!/)", "beginCaptures": { "0": { "name": "punctuation.definition.comment.tsx" } }, "end": "\\*/", "endCaptures": { "0": { "name": "punctuation.definition.comment.tsx" } }, "name": "comment.block.documentation.tsx", "patterns": [{ "include": "#docblock" }] }, { "begin": "(/\\*)(?:\\s*((@)internal)(?=\\s|(\\*/)))?", "beginCaptures": { "1": { "name": "punctuation.definition.comment.tsx" }, "2": { "name": "storage.type.internaldeclaration.tsx" }, "3": { "name": "punctuation.decorator.internaldeclaration.tsx" } }, "end": "\\*/", "endCaptures": { "0": { "name": "punctuation.definition.comment.tsx" } }, "name": "comment.block.tsx" }, { "begin": "(^[ \\t]+)?((//)(?:\\s*((@)internal)(?=\\s|$))?)", "beginCaptures": { "1": { "name": "punctuation.whitespace.comment.leading.tsx" }, "2": { "name": "comment.line.double-slash.tsx" }, "3": { "name": "punctuation.definition.comment.tsx" }, "4": { "name": "storage.type.internaldeclaration.tsx" }, "5": { "name": "punctuation.decorator.internaldeclaration.tsx" } }, "contentName": "comment.line.double-slash.tsx", "end": "(?=$)" }] }, "control-statement": { "patterns": [{ "include": "#switch-statement" }, { "include": "#for-loop" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(catch|finally|throw|try)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.control.trycatch.tsx" }, { "captures": { "1": { "name": "keyword.control.loop.tsx" }, "2": { "name": "entity.name.label.tsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(break|continue|goto)\\s+([_$[:alpha:]][_$[:alnum:]]*)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(break|continue|do|goto|while)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.control.loop.tsx" }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(return)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "0": { "name": "keyword.control.flow.tsx" } }, "end": "(?=[;}]|$|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "patterns": [{ "include": "#expression" }] }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(case|default|switch)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.control.switch.tsx" }, { "include": "#if-statement" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(else|if)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.control.conditional.tsx" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(with)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.control.with.tsx" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(package)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.control.tsx" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(debugger)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.other.debugger.tsx" }] }, "decl-block": { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.block.tsx" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.tsx" } }, "name": "meta.block.tsx", "patterns": [{ "include": "#statements" }] }, "declaration": { "patterns": [{ "include": "#decorator" }, { "include": "#var-expr" }, { "include": "#function-declaration" }, { "include": "#class-declaration" }, { "include": "#interface-declaration" }, { "include": "#enum-declaration" }, { "include": "#namespace-declaration" }, { "include": "#type-alias-declaration" }, { "include": "#import-equals-declaration" }, { "include": "#import-declaration" }, { "include": "#export-declaration" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(declare|export)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "storage.modifier.tsx" }] }, "decorator": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))\\@", "beginCaptures": { "0": { "name": "punctuation.decorator.tsx" } }, "end": "(?=\\s)", "name": "meta.decorator.tsx", "patterns": [{ "include": "#expression" }] }, "destructuring-const": { "patterns": [{ "begin": "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\{)", "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))", "name": "meta.object-binding-pattern-variable.tsx", "patterns": [{ "include": "#object-binding-pattern-const" }, { "include": "#type-annotation" }, { "include": "#comment" }] }, { "begin": "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\[)", "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))", "name": "meta.array-binding-pattern-variable.tsx", "patterns": [{ "include": "#array-binding-pattern-const" }, { "include": "#type-annotation" }, { "include": "#comment" }] }] }, "destructuring-parameter": { "patterns": [{ "begin": "(?<!=|:)\\s*(?:(\\.\\.\\.)\\s*)?(\\{)", "beginCaptures": { "1": { "name": "keyword.operator.rest.tsx" }, "2": { "name": "punctuation.definition.binding-pattern.object.tsx" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.object.tsx" } }, "name": "meta.parameter.object-binding-pattern.tsx", "patterns": [{ "include": "#parameter-object-binding-element" }] }, { "begin": "(?<!=|:)\\s*(?:(\\.\\.\\.)\\s*)?(\\[)", "beginCaptures": { "1": { "name": "keyword.operator.rest.tsx" }, "2": { "name": "punctuation.definition.binding-pattern.array.tsx" } }, "end": "\\]", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.array.tsx" } }, "name": "meta.paramter.array-binding-pattern.tsx", "patterns": [{ "include": "#parameter-binding-element" }, { "include": "#punctuation-comma" }] }] }, "destructuring-parameter-rest": { "captures": { "1": { "name": "keyword.operator.rest.tsx" }, "2": { "name": "variable.parameter.tsx" } }, "match": "(?:(\\.\\.\\.)\\s*)?([_$[:alpha:]][_$[:alnum:]]*)" }, "destructuring-variable": { "patterns": [{ "begin": "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\{)", "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))", "name": "meta.object-binding-pattern-variable.tsx", "patterns": [{ "include": "#object-binding-pattern" }, { "include": "#type-annotation" }, { "include": "#comment" }] }, { "begin": "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\[)", "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))", "name": "meta.array-binding-pattern-variable.tsx", "patterns": [{ "include": "#array-binding-pattern" }, { "include": "#type-annotation" }, { "include": "#comment" }] }] }, "destructuring-variable-rest": { "captures": { "1": { "name": "keyword.operator.rest.tsx" }, "2": { "name": "meta.definition.variable.tsx variable.other.readwrite.tsx" } }, "match": "(?:(\\.\\.\\.)\\s*)?([_$[:alpha:]][_$[:alnum:]]*)" }, "destructuring-variable-rest-const": { "captures": { "1": { "name": "keyword.operator.rest.tsx" }, "2": { "name": "meta.definition.variable.tsx variable.other.constant.tsx" } }, "match": "(?:(\\.\\.\\.)\\s*)?([_$[:alpha:]][_$[:alnum:]]*)" }, "directives": { "begin": "^(///)\\s*(?=<(reference|amd-dependency|amd-module)(\\s+(path|types|no-default-lib|lib|name|resolution-mode)\\s*=\\s*((\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)))+\\s*/>\\s*$)", "beginCaptures": { "1": { "name": "punctuation.definition.comment.tsx" } }, "end": "(?=$)", "name": "comment.line.triple-slash.directive.tsx", "patterns": [{ "begin": "(<)(reference|amd-dependency|amd-module)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.directive.tsx" }, "2": { "name": "entity.name.tag.directive.tsx" } }, "end": "/>", "endCaptures": { "0": { "name": "punctuation.definition.tag.directive.tsx" } }, "name": "meta.tag.tsx", "patterns": [{ "match": "path|types|no-default-lib|lib|name|resolution-mode", "name": "entity.other.attribute-name.directive.tsx" }, { "match": "=", "name": "keyword.operator.assignment.tsx" }, { "include": "#string" }] }] }, "docblock": { "patterns": [{ "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "constant.language.access-type.jsdoc" } }, "match": "(?x)\n((@)(?:access|api))\n\\s+\n(private|protected|public)\n\\b" }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "entity.name.type.instance.jsdoc" }, "4": { "name": "punctuation.definition.bracket.angle.begin.jsdoc" }, "5": { "name": "constant.other.email.link.underline.jsdoc" }, "6": { "name": "punctuation.definition.bracket.angle.end.jsdoc" } }, "match": "(?x)\n((@)author)\n\\s+\n(\n  [^@\\s<>*/]\n  (?:[^@<>*/]|\\*[^/])*\n)\n(?:\n  \\s*\n  (<)\n  ([^>\\s]+)\n  (>)\n)?" }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "entity.name.type.instance.jsdoc" }, "4": { "name": "keyword.operator.control.jsdoc" }, "5": { "name": "entity.name.type.instance.jsdoc" } }, "match": "(?x)\n((@)borrows) \\s+\n((?:[^@\\s*/]|\\*[^/])+)    # <that namepath>\n\\s+ (as) \\s+              # as\n((?:[^@\\s*/]|\\*[^/])+)    # <this namepath>" }, { "begin": "((@)example)\\s+", "beginCaptures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" } }, "end": "(?=@|\\*/)", "name": "meta.example.jsdoc", "patterns": [{ "match": "^\\s\\*\\s+" }, { "begin": "\\G(<)caption(>)", "beginCaptures": { "0": { "name": "entity.name.tag.inline.jsdoc" }, "1": { "name": "punctuation.definition.bracket.angle.begin.jsdoc" }, "2": { "name": "punctuation.definition.bracket.angle.end.jsdoc" } }, "contentName": "constant.other.description.jsdoc", "end": "(</)caption(>)|(?=\\*/)", "endCaptures": { "0": { "name": "entity.name.tag.inline.jsdoc" }, "1": { "name": "punctuation.definition.bracket.angle.begin.jsdoc" }, "2": { "name": "punctuation.definition.bracket.angle.end.jsdoc" } } }, { "captures": { "0": { "name": "source.embedded.tsx" } }, "match": "[^\\s@*](?:[^*]|\\*[^/])*" }] }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "constant.language.symbol-type.jsdoc" } }, "match": "(?x) ((@)kind) \\s+ (class|constant|event|external|file|function|member|mixin|module|namespace|typedef) \\b" }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "variable.other.link.underline.jsdoc" }, "4": { "name": "entity.name.type.instance.jsdoc" } }, "match": "(?x)\n((@)see)\n\\s+\n(?:\n  # URL\n  (\n    (?=https?://)\n    (?:[^\\s*]|\\*[^/])+\n  )\n  |\n  # JSDoc namepath\n  (\n    (?!\n      # Avoid matching bare URIs (also acceptable as links)\n      https?://\n      |\n      # Avoid matching {@inline tags}; we match those below\n      (?:\\[[^\\[\\]]*\\])? # Possible description [preceding]{@tag}\n      {@(?:link|linkcode|linkplain|tutorial)\\b\n    )\n    # Matched namepath\n    (?:[^@\\s*/]|\\*[^/])+\n  )\n)" }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "variable.other.jsdoc" } }, "match": "(?x)\n((@)template)\n\\s+\n# One or more valid identifiers\n(\n  [A-Za-z_$]         # First character: non-numeric word character\n  [\\w$.\\[\\]]*        # Rest of identifier\n  (?:                # Possible list of additional identifiers\n    \\s* , \\s*\n    [A-Za-z_$]\n    [\\w$.\\[\\]]*\n  )*\n)" }, { "begin": "(?x)((@)template)\\s+(?={)", "beginCaptures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" } }, "end": "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])", "patterns": [{ "include": "#jsdoctype" }, { "match": "([A-Za-z_$][\\w$.\\[\\]]*)", "name": "variable.other.jsdoc" }] }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "variable.other.jsdoc" } }, "match": "(?x)\n(\n  (@)\n  (?:arg|argument|const|constant|member|namespace|param|var)\n)\n\\s+\n(\n  [A-Za-z_$]\n  [\\w$.\\[\\]]*\n)" }, { "begin": "((@)typedef)\\s+(?={)", "beginCaptures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" } }, "end": "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])", "patterns": [{ "include": "#jsdoctype" }, { "match": "(?:[^@\\s*/]|\\*[^/])+", "name": "entity.name.type.instance.jsdoc" }] }, { "begin": "((@)(?:arg|argument|const|constant|member|namespace|param|prop|property|var))\\s+(?={)", "beginCaptures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" } }, "end": "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])", "patterns": [{ "include": "#jsdoctype" }, { "match": "([A-Za-z_$][\\w$.\\[\\]]*)", "name": "variable.other.jsdoc" }, { "captures": { "1": { "name": "punctuation.definition.optional-value.begin.bracket.square.jsdoc" }, "2": { "name": "keyword.operator.assignment.jsdoc" }, "3": { "name": "source.embedded.tsx" }, "4": { "name": "punctuation.definition.optional-value.end.bracket.square.jsdoc" }, "5": { "name": "invalid.illegal.syntax.jsdoc" } }, "match": `(?x)
(\\[)\\s*
[\\w$]+
(?:
  (?:\\[\\])?                                        # Foo[ ].bar properties within an array
  \\.                                                # Foo.Bar namespaced parameter
  [\\w$]+
)*
(?:
  \\s*
  (=)                                                # [foo=bar] Default parameter value
  \\s*
  (
    # The inner regexes are to stop the match early at */ and to not stop at escaped quotes
    (?>
      "(?:(?:\\*(?!/))|(?:\\\\(?!"))|[^*\\\\])*?" |                      # [foo="bar"] Double-quoted
      '(?:(?:\\*(?!/))|(?:\\\\(?!'))|[^*\\\\])*?' |                      # [foo='bar'] Single-quoted
      \\[ (?:(?:\\*(?!/))|[^*])*? \\] |                                # [foo=[1,2]] Array literal
      (?:(?:\\*(?!/))|\\s(?!\\s*\\])|\\[.*?(?:\\]|(?=\\*/))|[^*\\s\\[\\]])*   # Everything else
    )*
  )
)?
\\s*(?:(\\])((?:[^*\\s]|\\*[^\\s/])+)?|(?=\\*/))`, "name": "variable.other.jsdoc" }] }, { "begin": "(?x)\n(\n  (@)\n  (?:define|enum|exception|export|extends|lends|implements|modifies\n  |namespace|private|protected|returns?|satisfies|suppress|this|throws|type\n  |yields?)\n)\n\\s+(?={)", "beginCaptures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" } }, "end": "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])", "patterns": [{ "include": "#jsdoctype" }] }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "entity.name.type.instance.jsdoc" } }, "match": "(?x)\n(\n  (@)\n  (?:alias|augments|callback|constructs|emits|event|fires|exports?\n  |extends|external|function|func|host|lends|listens|interface|memberof!?\n  |method|module|mixes|mixin|name|requires|see|this|typedef|uses)\n)\n\\s+\n(\n  (?:\n    [^{}@\\s*] | \\*[^/]\n  )+\n)" }, { "begin": `((@)(?:default(?:value)?|license|version))\\s+(([''"]))`, "beginCaptures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "variable.other.jsdoc" }, "4": { "name": "punctuation.definition.string.begin.jsdoc" } }, "contentName": "variable.other.jsdoc", "end": "(\\3)|(?=$|\\*/)", "endCaptures": { "0": { "name": "variable.other.jsdoc" }, "1": { "name": "punctuation.definition.string.end.jsdoc" } } }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" }, "3": { "name": "variable.other.jsdoc" } }, "match": "((@)(?:default(?:value)?|license|tutorial|variation|version))\\s+([^\\s*]+)" }, { "captures": { "1": { "name": "punctuation.definition.block.tag.jsdoc" } }, "match": "(?x) (@) (?:abstract|access|alias|api|arg|argument|async|attribute|augments|author|beta|borrows|bubbles |callback|chainable|class|classdesc|code|config|const|constant|constructor|constructs|copyright |default|defaultvalue|define|deprecated|desc|description|dict|emits|enum|event|example|exception |exports?|extends|extension(?:_?for)?|external|externs|file|fileoverview|final|fires|for|func |function|generator|global|hideconstructor|host|ignore|implements|implicitCast|inherit[Dd]oc |inner|instance|interface|internal|kind|lends|license|listens|main|member|memberof!?|method |mixes|mixins?|modifies|module|name|namespace|noalias|nocollapse|nocompile|nosideeffects |override|overview|package|param|polymer(?:Behavior)?|preserve|private|prop|property|protected |public|read[Oo]nly|record|require[ds]|returns?|see|since|static|struct|submodule|summary |suppress|template|this|throws|todo|tutorial|type|typedef|unrestricted|uses|var|variation |version|virtual|writeOnce|yields?) \\b", "name": "storage.type.class.jsdoc" }, { "include": "#inline-tags" }, { "captures": { "1": { "name": "storage.type.class.jsdoc" }, "2": { "name": "punctuation.definition.block.tag.jsdoc" } }, "match": "((@)(?:[_$[:alpha:]][_$[:alnum:]]*))(?=\\s+)" }] }, "enum-declaration": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?(?:\\b(const)\\s+)?\\b(enum)\\s+([_$[:alpha:]][_$[:alnum:]]*)", "beginCaptures": { "1": { "name": "keyword.control.export.tsx" }, "2": { "name": "storage.modifier.tsx" }, "3": { "name": "storage.modifier.tsx" }, "4": { "name": "storage.type.enum.tsx" }, "5": { "name": "entity.name.type.enum.tsx" } }, "end": "(?<=\\})", "name": "meta.enum.declaration.tsx", "patterns": [{ "include": "#comment" }, { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.block.tsx" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.tsx" } }, "patterns": [{ "include": "#comment" }, { "begin": "([_$[:alpha:]][_$[:alnum:]]*)", "beginCaptures": { "0": { "name": "variable.other.enummember.tsx" } }, "end": "(?=,|\\}|$)", "patterns": [{ "include": "#comment" }, { "include": "#variable-initializer" }] }, { "begin": "(?=((\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\])))", "end": "(?=,|\\}|$)", "patterns": [{ "include": "#string" }, { "include": "#array-literal" }, { "include": "#comment" }, { "include": "#variable-initializer" }] }, { "include": "#punctuation-comma" }] }] }, "export-declaration": { "patterns": [{ "captures": { "1": { "name": "keyword.control.export.tsx" }, "2": { "name": "keyword.control.as.tsx" }, "3": { "name": "storage.type.namespace.tsx" }, "4": { "name": "entity.name.type.module.tsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(export)\\s+(as)\\s+(namespace)\\s+([_$[:alpha:]][_$[:alnum:]]*)" }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(export)(?:\\s+(type))?(?:(?:\\s*(=))|(?:\\s+(default)(?=\\s+)))", "beginCaptures": { "1": { "name": "keyword.control.export.tsx" }, "2": { "name": "keyword.control.type.tsx" }, "3": { "name": "keyword.operator.assignment.tsx" }, "4": { "name": "keyword.control.default.tsx" } }, "end": "(?=$|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "name": "meta.export.default.tsx", "patterns": [{ "include": "#interface-declaration" }, { "include": "#expression" }] }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(export)(?:\\s+(type))?\\b(?!(\\$)|(\\s*:))((?=\\s*[\\{*])|((?=\\s*[_$[:alpha:]][_$[:alnum:]]*(\\s|,))(?!\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b)))", "beginCaptures": { "1": { "name": "keyword.control.export.tsx" }, "2": { "name": "keyword.control.type.tsx" } }, "end": "(?=$|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "name": "meta.export.tsx", "patterns": [{ "include": "#import-export-declaration" }] }] }, "expression": { "patterns": [{ "include": "#expressionWithoutIdentifiers" }, { "include": "#identifiers" }, { "include": "#expressionPunctuations" }] }, "expression-inside-possibly-arrow-parens": { "patterns": [{ "include": "#expressionWithoutIdentifiers" }, { "include": "#comment" }, { "include": "#string" }, { "include": "#decorator" }, { "include": "#destructuring-parameter" }, { "captures": { "1": { "name": "storage.modifier.tsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|protected|private|readonly)\\s+(?=(override|public|protected|private|readonly)\\s+)" }, { "captures": { "1": { "name": "storage.modifier.tsx" }, "2": { "name": "keyword.operator.rest.tsx" }, "3": { "name": "entity.name.function.tsx variable.language.this.tsx" }, "4": { "name": "entity.name.function.tsx" }, "5": { "name": "keyword.operator.optional.tsx" } }, "match": "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))" }, { "captures": { "1": { "name": "storage.modifier.tsx" }, "2": { "name": "keyword.operator.rest.tsx" }, "3": { "name": "variable.parameter.tsx variable.language.this.tsx" }, "4": { "name": "variable.parameter.tsx" }, "5": { "name": "keyword.operator.optional.tsx" } }, "match": "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)(?=\\s*[:,]|$)" }, { "include": "#type-annotation" }, { "include": "#variable-initializer" }, { "match": ",", "name": "punctuation.separator.parameter.tsx" }, { "include": "#identifiers" }, { "include": "#expressionPunctuations" }] }, "expression-operators": { "patterns": [{ "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(await)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.control.flow.tsx" }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(yield)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?=\\s*\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*\\*)", "beginCaptures": { "1": { "name": "keyword.control.flow.tsx" } }, "end": "\\*", "endCaptures": { "0": { "name": "keyword.generator.asterisk.tsx" } }, "patterns": [{ "include": "#comment" }] }, { "captures": { "1": { "name": "keyword.control.flow.tsx" }, "2": { "name": "keyword.generator.asterisk.tsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(yield)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?:\\s*(\\*))?" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))delete(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.operator.expression.delete.tsx" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))in(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?!\\()", "name": "keyword.operator.expression.in.tsx" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))of(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?!\\()", "name": "keyword.operator.expression.of.tsx" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))instanceof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.operator.expression.instanceof.tsx" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))new(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.operator.new.tsx" }, { "include": "#typeof-operator" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))void(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.operator.expression.void.tsx" }, { "captures": { "1": { "name": "keyword.control.as.tsx" }, "2": { "name": "storage.modifier.tsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+(const)(?=\\s*($|[;,:})\\]]))" }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(as)|(satisfies))\\s+", "beginCaptures": { "1": { "name": "keyword.control.as.tsx" }, "2": { "name": "keyword.control.satisfies.tsx" } }, "end": "(?=^|[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as|satisfies)\\s+)|(\\s+\\<))", "patterns": [{ "include": "#type" }] }, { "match": "\\.\\.\\.", "name": "keyword.operator.spread.tsx" }, { "match": "\\*=|(?<!\\()/=|%=|\\+=|\\-=", "name": "keyword.operator.assignment.compound.tsx" }, { "match": "\\&=|\\^=|<<=|>>=|>>>=|\\|=", "name": "keyword.operator.assignment.compound.bitwise.tsx" }, { "match": "<<|>>>|>>", "name": "keyword.operator.bitwise.shift.tsx" }, { "match": "===|!==|==|!=", "name": "keyword.operator.comparison.tsx" }, { "match": "<=|>=|<>|<|>", "name": "keyword.operator.relational.tsx" }, { "captures": { "1": { "name": "keyword.operator.logical.tsx" }, "2": { "name": "keyword.operator.assignment.compound.tsx" }, "3": { "name": "keyword.operator.arithmetic.tsx" } }, "match": "(?<=[_$[:alnum:]])(\\!)\\s*(?:(/=)|(?:(/)(?![/*])))" }, { "match": "\\!|&&|\\|\\||\\?\\?", "name": "keyword.operator.logical.tsx" }, { "match": "\\&|~|\\^|\\|", "name": "keyword.operator.bitwise.tsx" }, { "match": "\\=", "name": "keyword.operator.assignment.tsx" }, { "match": "--", "name": "keyword.operator.decrement.tsx" }, { "match": "\\+\\+", "name": "keyword.operator.increment.tsx" }, { "match": "%|\\*|/|-|\\+", "name": "keyword.operator.arithmetic.tsx" }, { "begin": "(?<=[_$[:alnum:])\\]])\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)+(?:(/=)|(?:(/)(?![/*]))))", "end": "(?:(/=)|(?:(/)(?!\\*([^\\*]|(\\*[^\\/]))*\\*\\/)))", "endCaptures": { "1": { "name": "keyword.operator.assignment.compound.tsx" }, "2": { "name": "keyword.operator.arithmetic.tsx" } }, "patterns": [{ "include": "#comment" }] }, { "captures": { "1": { "name": "keyword.operator.assignment.compound.tsx" }, "2": { "name": "keyword.operator.arithmetic.tsx" } }, "match": "(?<=[_$[:alnum:])\\]])\\s*(?:(/=)|(?:(/)(?![/*])))" }] }, "expressionPunctuations": { "patterns": [{ "include": "#punctuation-comma" }, { "include": "#punctuation-accessor" }] }, "expressionWithoutIdentifiers": { "patterns": [{ "include": "#jsx" }, { "include": "#string" }, { "include": "#regex" }, { "include": "#comment" }, { "include": "#function-expression" }, { "include": "#class-expression" }, { "include": "#arrow-function" }, { "include": "#paren-expression-possibly-arrow" }, { "include": "#cast" }, { "include": "#ternary-expression" }, { "include": "#new-expr" }, { "include": "#instanceof-expr" }, { "include": "#object-literal" }, { "include": "#expression-operators" }, { "include": "#function-call" }, { "include": "#literal" }, { "include": "#support-objects" }, { "include": "#paren-expression" }] }, "field-declaration": { "begin": "(?x)(?<!\\()(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(readonly)\\s+)?(?=\\s*((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|(\\#?[_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(?:(?:(\\?)|(\\!))\\s*)?(=|:|;|,|\\}|$))", "beginCaptures": { "1": { "name": "storage.modifier.tsx" } }, "end": "(?x)(?=\\}|;|,|$|(^(?!\\s*((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|(\\#?[_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(?:(?:(\\?)|(\\!))\\s*)?(=|:|;|,|$))))|(?<=\\})", "name": "meta.field.declaration.tsx", "patterns": [{ "include": "#variable-initializer" }, { "include": "#type-annotation" }, { "include": "#string" }, { "include": "#array-literal" }, { "include": "#numeric-literal" }, { "include": "#comment" }, { "captures": { "1": { "name": "meta.definition.property.tsx entity.name.function.tsx" }, "2": { "name": "keyword.operator.optional.tsx" }, "3": { "name": "keyword.operator.definiteassignment.tsx" } }, "match": "(?x)(\\#?[_$[:alpha:]][_$[:alnum:]]*)(?:(\\?)|(\\!))?(?=\\s*\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))" }, { "match": "\\#?[_$[:alpha:]][_$[:alnum:]]*", "name": "meta.definition.property.tsx variable.object.property.tsx" }, { "match": "\\?", "name": "keyword.operator.optional.tsx" }, { "match": "\\!", "name": "keyword.operator.definiteassignment.tsx" }] }, "for-loop": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))for(?=((\\s+|(\\s*\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*))await)?\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)?(\\())", "beginCaptures": { "0": { "name": "keyword.control.loop.tsx" } }, "end": "(?<=\\))", "patterns": [{ "include": "#comment" }, { "match": "await", "name": "keyword.control.loop.tsx" }, { "begin": "\\(", "beginCaptures": { "0": { "name": "meta.brace.round.tsx" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.tsx" } }, "patterns": [{ "include": "#var-expr" }, { "include": "#expression" }, { "include": "#punctuation-semicolon" }] }] }, "function-body": { "patterns": [{ "include": "#comment" }, { "include": "#type-parameters" }, { "include": "#function-parameters" }, { "include": "#return-type" }, { "include": "#type-function-return-type" }, { "include": "#decl-block" }, { "match": "\\*", "name": "keyword.generator.asterisk.tsx" }] }, "function-call": { "patterns": [{ "begin": "(?=(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))\\s*(?:(\\?\\.\\s*)|(\\!))?((<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?\\())", "end": "(?<=\\))(?!(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))\\s*(?:(\\?\\.\\s*)|(\\!))?((<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?\\())", "patterns": [{ "begin": "(?=(([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))", "end": "(?=\\s*(?:(\\?\\.\\s*)|(\\!))?((<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?\\())", "name": "meta.function-call.tsx", "patterns": [{ "include": "#function-call-target" }] }, { "include": "#comment" }, { "include": "#function-call-optionals" }, { "include": "#type-arguments" }, { "include": "#paren-expression" }] }, { "begin": "(?=(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))(<\\s*[\\{\\[\\(]\\s*$))", "end": "(?<=\\>)(?!(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))(<\\s*[\\{\\[\\(]\\s*$))", "patterns": [{ "begin": "(?=(([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))", "end": "(?=(<\\s*[\\{\\[\\(]\\s*$))", "name": "meta.function-call.tsx", "patterns": [{ "include": "#function-call-target" }] }, { "include": "#comment" }, { "include": "#function-call-optionals" }, { "include": "#type-arguments" }] }] }, "function-call-optionals": { "patterns": [{ "match": "\\?\\.", "name": "meta.function-call.tsx punctuation.accessor.optional.tsx" }, { "match": "\\!", "name": "meta.function-call.tsx keyword.operator.definiteassignment.tsx" }] }, "function-call-target": { "patterns": [{ "include": "#support-function-call-identifiers" }, { "match": "(\\#?[_$[:alpha:]][_$[:alnum:]]*)", "name": "entity.name.function.tsx" }] }, "function-declaration": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?(?:(async)\\s+)?(function\\b)(?:\\s*(\\*))?(?:(?:\\s+|(?<=\\*))([_$[:alpha:]][_$[:alnum:]]*))?\\s*", "beginCaptures": { "1": { "name": "keyword.control.export.tsx" }, "2": { "name": "storage.modifier.tsx" }, "3": { "name": "storage.modifier.async.tsx" }, "4": { "name": "storage.type.function.tsx" }, "5": { "name": "keyword.generator.asterisk.tsx" }, "6": { "name": "meta.definition.function.tsx entity.name.function.tsx" } }, "end": "(?=;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))|(?<=\\})", "name": "meta.function.tsx", "patterns": [{ "include": "#function-name" }, { "include": "#function-body" }] }, "function-expression": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(async)\\s+)?(function\\b)(?:\\s*(\\*))?(?:(?:\\s+|(?<=\\*))([_$[:alpha:]][_$[:alnum:]]*))?\\s*", "beginCaptures": { "1": { "name": "storage.modifier.async.tsx" }, "2": { "name": "storage.type.function.tsx" }, "3": { "name": "keyword.generator.asterisk.tsx" }, "4": { "name": "meta.definition.function.tsx entity.name.function.tsx" } }, "end": "(?=;)|(?<=\\})", "name": "meta.function.expression.tsx", "patterns": [{ "include": "#function-name" }, { "include": "#single-line-comment-consuming-line-ending" }, { "include": "#function-body" }] }, "function-name": { "match": "[_$[:alpha:]][_$[:alnum:]]*", "name": "meta.definition.function.tsx entity.name.function.tsx" }, "function-parameters": { "begin": "\\(", "beginCaptures": { "0": { "name": "punctuation.definition.parameters.begin.tsx" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.parameters.end.tsx" } }, "name": "meta.parameters.tsx", "patterns": [{ "include": "#function-parameters-body" }] }, "function-parameters-body": { "patterns": [{ "include": "#comment" }, { "include": "#string" }, { "include": "#decorator" }, { "include": "#destructuring-parameter" }, { "include": "#parameter-name" }, { "include": "#parameter-type-annotation" }, { "include": "#variable-initializer" }, { "match": ",", "name": "punctuation.separator.parameter.tsx" }] }, "identifiers": { "patterns": [{ "include": "#object-identifiers" }, { "captures": { "1": { "name": "punctuation.accessor.tsx" }, "2": { "name": "punctuation.accessor.optional.tsx" }, "3": { "name": "entity.name.function.tsx" } }, "match": "(?x)(?:(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*)?([_$[:alpha:]][_$[:alnum:]]*)(?=\\s*=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n))" }, { "captures": { "1": { "name": "punctuation.accessor.tsx" }, "2": { "name": "punctuation.accessor.optional.tsx" }, "3": { "name": "variable.other.constant.property.tsx" } }, "match": "(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(\\#?[[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])" }, { "captures": { "1": { "name": "punctuation.accessor.tsx" }, "2": { "name": "punctuation.accessor.optional.tsx" }, "3": { "name": "variable.other.property.tsx" } }, "match": "(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*)" }, { "match": "([[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])", "name": "variable.other.constant.tsx" }, { "match": "[_$[:alpha:]][_$[:alnum:]]*", "name": "variable.other.readwrite.tsx" }] }, "if-statement": { "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?=\\bif\\s*(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))\\s*(?!\\{))", "end": "(?=;|$|\\})", "patterns": [{ "include": "#comment" }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(if)\\s*(\\()", "beginCaptures": { "1": { "name": "keyword.control.conditional.tsx" }, "2": { "name": "meta.brace.round.tsx" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.tsx" } }, "patterns": [{ "include": "#expression" }] }, { "begin": "(?<=\\))\\s*\\/(?![\\/*])(?=(?:[^\\/\\\\\\[]|\\\\.|\\[([^\\]\\\\]|\\\\.)*\\])+\\/([dgimsuy]+|(?![\\/\\*])|(?=\\/\\*))(?!\\s*[a-zA-Z0-9_$]))", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.tsx" } }, "end": "(/)([dgimsuy]*)", "endCaptures": { "1": { "name": "punctuation.definition.string.end.tsx" }, "2": { "name": "keyword.other.tsx" } }, "name": "string.regexp.tsx", "patterns": [{ "include": "#regexp" }] }, { "include": "#statements" }] }] }, "import-declaration": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(import)(?:\\s+(type)(?!\\s+from))?(?!\\s*[:\\(])(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "1": { "name": "keyword.control.export.tsx" }, "2": { "name": "storage.modifier.tsx" }, "3": { "name": "keyword.control.import.tsx" }, "4": { "name": "keyword.control.type.tsx" } }, "end": "(?<!^import|[^\\._$[:alnum:]]import)(?=;|$|^)", "name": "meta.import.tsx", "patterns": [{ "include": "#single-line-comment-consuming-line-ending" }, { "include": "#comment" }, { "include": "#string" }, { "begin": `(?<=^import|[^\\._$[:alnum:]]import)(?!\\s*["'])`, "end": "\\bfrom\\b", "endCaptures": { "0": { "name": "keyword.control.from.tsx" } }, "patterns": [{ "include": "#import-export-declaration" }] }, { "include": "#import-export-declaration" }] }, "import-equals-declaration": { "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(import)(?:\\s+(type))?\\s+([_$[:alpha:]][_$[:alnum:]]*)\\s*(=)\\s*(require)\\s*(\\()", "beginCaptures": { "1": { "name": "keyword.control.export.tsx" }, "2": { "name": "storage.modifier.tsx" }, "3": { "name": "keyword.control.import.tsx" }, "4": { "name": "keyword.control.type.tsx" }, "5": { "name": "variable.other.readwrite.alias.tsx" }, "6": { "name": "keyword.operator.assignment.tsx" }, "7": { "name": "keyword.control.require.tsx" }, "8": { "name": "meta.brace.round.tsx" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.tsx" } }, "name": "meta.import-equals.external.tsx", "patterns": [{ "include": "#comment" }, { "include": "#string" }] }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(import)(?:\\s+(type))?\\s+([_$[:alpha:]][_$[:alnum:]]*)\\s*(=)\\s*(?!require\\b)", "beginCaptures": { "1": { "name": "keyword.control.export.tsx" }, "2": { "name": "storage.modifier.tsx" }, "3": { "name": "keyword.control.import.tsx" }, "4": { "name": "keyword.control.type.tsx" }, "5": { "name": "variable.other.readwrite.alias.tsx" }, "6": { "name": "keyword.operator.assignment.tsx" } }, "end": "(?=;|$|^)", "name": "meta.import-equals.internal.tsx", "patterns": [{ "include": "#single-line-comment-consuming-line-ending" }, { "include": "#comment" }, { "captures": { "1": { "name": "entity.name.type.module.tsx" }, "2": { "name": "punctuation.accessor.tsx" }, "3": { "name": "punctuation.accessor.optional.tsx" } }, "match": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))" }, { "match": "([_$[:alpha:]][_$[:alnum:]]*)", "name": "variable.other.readwrite.tsx" }] }] }, "import-export-assert-clause": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(assert)\\s*(\\{)", "beginCaptures": { "1": { "name": "keyword.control.assert.tsx" }, "2": { "name": "punctuation.definition.block.tsx" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.tsx" } }, "patterns": [{ "include": "#comment" }, { "include": "#string" }, { "match": "(?:[_$[:alpha:]][_$[:alnum:]]*)\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*:)", "name": "meta.object-literal.key.tsx" }, { "match": ":", "name": "punctuation.separator.key-value.tsx" }] }, "import-export-block": { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.block.tsx" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.tsx" } }, "name": "meta.block.tsx", "patterns": [{ "include": "#import-export-clause" }] }, "import-export-clause": { "patterns": [{ "include": "#comment" }, { "captures": { "1": { "name": "keyword.control.type.tsx" }, "2": { "name": "keyword.control.default.tsx" }, "3": { "name": "constant.language.import-export-all.tsx" }, "4": { "name": "variable.other.readwrite.tsx" }, "5": { "name": "keyword.control.as.tsx" }, "6": { "name": "keyword.control.default.tsx" }, "7": { "name": "variable.other.readwrite.alias.tsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(?:(\\btype)\\s+)?(?:(\\bdefault)|(\\*)|(\\b[_$[:alpha:]][_$[:alnum:]]*)))\\s+(as)\\s+(?:(default(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|([_$[:alpha:]][_$[:alnum:]]*))" }, { "include": "#punctuation-comma" }, { "match": "\\*", "name": "constant.language.import-export-all.tsx" }, { "match": "\\b(default)\\b", "name": "keyword.control.default.tsx" }, { "captures": { "1": { "name": "keyword.control.type.tsx" }, "2": { "name": "variable.other.readwrite.alias.tsx" } }, "match": "(?:(\\btype)\\s+)?([_$[:alpha:]][_$[:alnum:]]*)" }] }, "import-export-declaration": { "patterns": [{ "include": "#comment" }, { "include": "#string" }, { "include": "#import-export-block" }, { "match": "\\bfrom\\b", "name": "keyword.control.from.tsx" }, { "include": "#import-export-assert-clause" }, { "include": "#import-export-clause" }] }, "indexer-declaration": { "begin": "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(readonly)\\s*)?\\s*(\\[)\\s*([_$[:alpha:]][_$[:alnum:]]*)\\s*(?=:)", "beginCaptures": { "1": { "name": "storage.modifier.tsx" }, "2": { "name": "meta.brace.square.tsx" }, "3": { "name": "variable.parameter.tsx" } }, "end": "(\\])\\s*(\\?\\s*)?|$", "endCaptures": { "1": { "name": "meta.brace.square.tsx" }, "2": { "name": "keyword.operator.optional.tsx" } }, "name": "meta.indexer.declaration.tsx", "patterns": [{ "include": "#type-annotation" }] }, "indexer-mapped-type-declaration": { "begin": "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))([+-])?(readonly)\\s*)?\\s*(\\[)\\s*([_$[:alpha:]][_$[:alnum:]]*)\\s+(in)\\s+", "beginCaptures": { "1": { "name": "keyword.operator.type.modifier.tsx" }, "2": { "name": "storage.modifier.tsx" }, "3": { "name": "meta.brace.square.tsx" }, "4": { "name": "entity.name.type.tsx" }, "5": { "name": "keyword.operator.expression.in.tsx" } }, "end": "(\\])([+-])?\\s*(\\?\\s*)?|$", "endCaptures": { "1": { "name": "meta.brace.square.tsx" }, "2": { "name": "keyword.operator.type.modifier.tsx" }, "3": { "name": "keyword.operator.optional.tsx" } }, "name": "meta.indexer.mappedtype.declaration.tsx", "patterns": [{ "captures": { "1": { "name": "keyword.control.as.tsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+" }, { "include": "#type" }] }, "inline-tags": { "patterns": [{ "captures": { "1": { "name": "punctuation.definition.bracket.square.begin.jsdoc" }, "2": { "name": "punctuation.definition.bracket.square.end.jsdoc" } }, "match": "(\\[)[^\\]]+(\\])(?={@(?:link|linkcode|linkplain|tutorial))", "name": "constant.other.description.jsdoc" }, { "begin": "({)((@)(?:link(?:code|plain)?|tutorial))\\s*", "beginCaptures": { "1": { "name": "punctuation.definition.bracket.curly.begin.jsdoc" }, "2": { "name": "storage.type.class.jsdoc" }, "3": { "name": "punctuation.definition.inline.tag.jsdoc" } }, "end": "}|(?=\\*/)", "endCaptures": { "0": { "name": "punctuation.definition.bracket.curly.end.jsdoc" } }, "name": "entity.name.type.instance.jsdoc", "patterns": [{ "captures": { "1": { "name": "variable.other.link.underline.jsdoc" }, "2": { "name": "punctuation.separator.pipe.jsdoc" } }, "match": "\\G((?=https?://)(?:[^|}\\s*]|\\*[/])+)(\\|)?" }, { "captures": { "1": { "name": "variable.other.description.jsdoc" }, "2": { "name": "punctuation.separator.pipe.jsdoc" } }, "match": "\\G((?:[^{}@\\s|*]|\\*[^/])+)(\\|)?" }] }] }, "instanceof-expr": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(instanceof)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "1": { "name": "keyword.operator.expression.instanceof.tsx" } }, "end": "(?<=\\))|(?=[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|(===|!==|==|!=)|(([\\&\\~\\^\\|]\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s+instanceof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))function((\\s+[_$[:alpha:]][_$[:alnum:]]*)|(\\s*[\\(]))))", "patterns": [{ "include": "#type" }] }, "interface-declaration": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(?:(abstract)\\s+)?\\b(interface)\\b(?=\\s+|/[/*])", "beginCaptures": { "1": { "name": "keyword.control.export.tsx" }, "2": { "name": "storage.modifier.tsx" }, "3": { "name": "storage.modifier.tsx" }, "4": { "name": "storage.type.interface.tsx" } }, "end": "(?<=\\})", "name": "meta.interface.tsx", "patterns": [{ "include": "#comment" }, { "include": "#class-or-interface-heritage" }, { "captures": { "0": { "name": "entity.name.type.interface.tsx" } }, "match": "[_$[:alpha:]][_$[:alnum:]]*" }, { "include": "#type-parameters" }, { "include": "#class-or-interface-body" }] }, "jsdoctype": { "patterns": [{ "begin": "\\G({)", "beginCaptures": { "0": { "name": "entity.name.type.instance.jsdoc" }, "1": { "name": "punctuation.definition.bracket.curly.begin.jsdoc" } }, "contentName": "entity.name.type.instance.jsdoc", "end": "((}))\\s*|(?=\\*/)", "endCaptures": { "1": { "name": "entity.name.type.instance.jsdoc" }, "2": { "name": "punctuation.definition.bracket.curly.end.jsdoc" } }, "patterns": [{ "include": "#brackets" }] }] }, "jsx": { "patterns": [{ "include": "#jsx-tag-without-attributes-in-expression" }, { "include": "#jsx-tag-in-expression" }] }, "jsx-children": { "patterns": [{ "include": "#jsx-tag-without-attributes" }, { "include": "#jsx-tag" }, { "include": "#jsx-evaluated-code" }, { "include": "#jsx-entities" }] }, "jsx-entities": { "patterns": [{ "captures": { "1": { "name": "punctuation.definition.entity.tsx" }, "3": { "name": "punctuation.definition.entity.tsx" } }, "match": "(&)([a-zA-Z0-9]+|#[0-9]+|#x[0-9a-fA-F]+)(;)", "name": "constant.character.entity.tsx" }] }, "jsx-evaluated-code": { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.section.embedded.begin.tsx" } }, "contentName": "meta.embedded.expression.tsx", "end": "\\}", "endCaptures": { "0": { "name": "punctuation.section.embedded.end.tsx" } }, "patterns": [{ "include": "#expression" }] }, "jsx-string-double-quoted": { "begin": '"', "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.tsx" } }, "end": '"', "endCaptures": { "0": { "name": "punctuation.definition.string.end.tsx" } }, "name": "string.quoted.double.tsx", "patterns": [{ "include": "#jsx-entities" }] }, "jsx-string-single-quoted": { "begin": "'", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.tsx" } }, "end": "'", "endCaptures": { "0": { "name": "punctuation.definition.string.end.tsx" } }, "name": "string.quoted.single.tsx", "patterns": [{ "include": "#jsx-entities" }] }, "jsx-tag": { "begin": "(?=(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))(?=((<\\s*)|(\\s+))(?!\\?)|\\/?>))", "end": "(/>)|(?:(</)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>))", "endCaptures": { "1": { "name": "punctuation.definition.tag.end.tsx" }, "2": { "name": "punctuation.definition.tag.begin.tsx" }, "3": { "name": "entity.name.tag.namespace.tsx" }, "4": { "name": "punctuation.separator.namespace.tsx" }, "5": { "name": "entity.name.tag.tsx" }, "6": { "name": "support.class.component.tsx" }, "7": { "name": "punctuation.definition.tag.end.tsx" } }, "name": "meta.tag.tsx", "patterns": [{ "begin": "(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))(?=((<\\s*)|(\\s+))(?!\\?)|\\/?>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.tsx" }, "2": { "name": "entity.name.tag.namespace.tsx" }, "3": { "name": "punctuation.separator.namespace.tsx" }, "4": { "name": "entity.name.tag.tsx" }, "5": { "name": "support.class.component.tsx" } }, "end": "(?=[/]?>)", "patterns": [{ "include": "#comment" }, { "include": "#type-arguments" }, { "include": "#jsx-tag-attributes" }] }, { "begin": "(>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.end.tsx" } }, "contentName": "meta.jsx.children.tsx", "end": "(?=</)", "patterns": [{ "include": "#jsx-children" }] }] }, "jsx-tag-attribute-assignment": { "match": `=(?=\\s*(?:'|"|{|/\\*|//|\\n))`, "name": "keyword.operator.assignment.tsx" }, "jsx-tag-attribute-name": { "captures": { "1": { "name": "entity.other.attribute-name.namespace.tsx" }, "2": { "name": "punctuation.separator.namespace.tsx" }, "3": { "name": "entity.other.attribute-name.tsx" } }, "match": "(?x)\n  \\s*\n  (?:([_$[:alpha:]][-_$[:alnum:].]*)(:))?\n  ([_$[:alpha:]][-_$[:alnum:]]*)\n  (?=\\s|=|/?>|/\\*|//)" }, "jsx-tag-attributes": { "begin": "\\s+", "end": "(?=[/]?>)", "name": "meta.tag.attributes.tsx", "patterns": [{ "include": "#comment" }, { "include": "#jsx-tag-attribute-name" }, { "include": "#jsx-tag-attribute-assignment" }, { "include": "#jsx-string-double-quoted" }, { "include": "#jsx-string-single-quoted" }, { "include": "#jsx-evaluated-code" }, { "include": "#jsx-tag-attributes-illegal" }] }, "jsx-tag-attributes-illegal": { "match": "\\S+", "name": "invalid.illegal.attribute.tsx" }, "jsx-tag-in-expression": { "begin": "(?x)\n  (?<!\\+\\+|--)(?<=[({\\[,?=>:*]|&&|\\|\\||\\?|\\*\\/|^await|[^\\._$[:alnum:]]await|^return|[^\\._$[:alnum:]]return|^default|[^\\._$[:alnum:]]default|^yield|[^\\._$[:alnum:]]yield|^)\\s*\n  (?!<\\s*[_$[:alpha:]][_$[:alnum:]]*((\\s+extends\\s+[^=>])|,)) # look ahead is not type parameter of arrow\n  (?=(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))(?=((<\\s*)|(\\s+))(?!\\?)|\\/?>))", "end": "(?!(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))(?=((<\\s*)|(\\s+))(?!\\?)|\\/?>))", "patterns": [{ "include": "#jsx-tag" }] }, "jsx-tag-without-attributes": { "begin": "(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.tsx" }, "2": { "name": "entity.name.tag.namespace.tsx" }, "3": { "name": "punctuation.separator.namespace.tsx" }, "4": { "name": "entity.name.tag.tsx" }, "5": { "name": "support.class.component.tsx" }, "6": { "name": "punctuation.definition.tag.end.tsx" } }, "contentName": "meta.jsx.children.tsx", "end": "(</)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.begin.tsx" }, "2": { "name": "entity.name.tag.namespace.tsx" }, "3": { "name": "punctuation.separator.namespace.tsx" }, "4": { "name": "entity.name.tag.tsx" }, "5": { "name": "support.class.component.tsx" }, "6": { "name": "punctuation.definition.tag.end.tsx" } }, "name": "meta.tag.without-attributes.tsx", "patterns": [{ "include": "#jsx-children" }] }, "jsx-tag-without-attributes-in-expression": { "begin": "(?<!\\+\\+|--)(?<=[({\\[,?=>:*]|&&|\\|\\||\\?|\\*\\/|^await|[^\\._$[:alnum:]]await|^return|[^\\._$[:alnum:]]return|^default|[^\\._$[:alnum:]]default|^yield|[^\\._$[:alnum:]]yield|^)\\s*(?=(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>))", "end": "(?!(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>))", "patterns": [{ "include": "#jsx-tag-without-attributes" }] }, "label": { "patterns": [{ "begin": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(:)(?=\\s*\\{)", "beginCaptures": { "1": { "name": "entity.name.label.tsx" }, "2": { "name": "punctuation.separator.label.tsx" } }, "end": "(?<=\\})", "patterns": [{ "include": "#decl-block" }] }, { "captures": { "1": { "name": "entity.name.label.tsx" }, "2": { "name": "punctuation.separator.label.tsx" } }, "match": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(:)" }] }, "literal": { "patterns": [{ "include": "#numeric-literal" }, { "include": "#boolean-literal" }, { "include": "#null-literal" }, { "include": "#undefined-literal" }, { "include": "#numericConstant-literal" }, { "include": "#array-literal" }, { "include": "#this-literal" }, { "include": "#super-literal" }] }, "method-declaration": { "patterns": [{ "begin": "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(override)\\s+)?(?:\\b(public|private|protected)\\s+)?(?:\\b(abstract)\\s+)?(?:\\b(async)\\s+)?\\s*\\b(constructor)\\b(?!:)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "1": { "name": "storage.modifier.tsx" }, "2": { "name": "storage.modifier.tsx" }, "3": { "name": "storage.modifier.tsx" }, "4": { "name": "storage.modifier.async.tsx" }, "5": { "name": "storage.type.tsx" } }, "end": "(?=\\}|;|,|$)|(?<=\\})", "name": "meta.method.declaration.tsx", "patterns": [{ "include": "#method-declaration-name" }, { "include": "#function-body" }] }, { "begin": "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(override)\\s+)?(?:\\b(public|private|protected)\\s+)?(?:\\b(abstract)\\s+)?(?:\\b(async)\\s+)?(?:(?:\\s*\\b(new)\\b(?!:)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|(?:(\\*)\\s*)?)(?=\\s*((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])", "beginCaptures": { "1": { "name": "storage.modifier.tsx" }, "2": { "name": "storage.modifier.tsx" }, "3": { "name": "storage.modifier.tsx" }, "4": { "name": "storage.modifier.async.tsx" }, "5": { "name": "keyword.operator.new.tsx" }, "6": { "name": "keyword.generator.asterisk.tsx" } }, "end": "(?=\\}|;|,|$)|(?<=\\})", "name": "meta.method.declaration.tsx", "patterns": [{ "include": "#method-declaration-name" }, { "include": "#function-body" }] }, { "begin": "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(override)\\s+)?(?:\\b(public|private|protected)\\s+)?(?:\\b(abstract)\\s+)?(?:\\b(async)\\s+)?(?:\\b(get|set)\\s+)?(?:(\\*)\\s*)?(?=\\s*(((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??))\\s*((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])", "beginCaptures": { "1": { "name": "storage.modifier.tsx" }, "2": { "name": "storage.modifier.tsx" }, "3": { "name": "storage.modifier.tsx" }, "4": { "name": "storage.modifier.async.tsx" }, "5": { "name": "storage.type.property.tsx" }, "6": { "name": "keyword.generator.asterisk.tsx" } }, "end": "(?=\\}|;|,|$)|(?<=\\})", "name": "meta.method.declaration.tsx", "patterns": [{ "include": "#method-declaration-name" }, { "include": "#function-body" }] }] }, "method-declaration-name": { "begin": "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??)\\s*[\\(\\<])", "end": "(?=\\(|\\<)", "patterns": [{ "include": "#string" }, { "include": "#array-literal" }, { "include": "#numeric-literal" }, { "match": "[_$[:alpha:]][_$[:alnum:]]*", "name": "meta.definition.method.tsx entity.name.function.tsx" }, { "match": "\\?", "name": "keyword.operator.optional.tsx" }] }, "namespace-declaration": { "begin": "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(namespace|module)\\s+(?=[_$[:alpha:]\"'`]))", "beginCaptures": { "1": { "name": "keyword.control.export.tsx" }, "2": { "name": "storage.modifier.tsx" }, "3": { "name": "storage.type.namespace.tsx" } }, "end": "(?<=\\})|(?=;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "name": "meta.namespace.declaration.tsx", "patterns": [{ "include": "#comment" }, { "include": "#string" }, { "match": "([_$[:alpha:]][_$[:alnum:]]*)", "name": "entity.name.type.module.tsx" }, { "include": "#punctuation-accessor" }, { "include": "#decl-block" }] }, "new-expr": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(new)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "1": { "name": "keyword.operator.new.tsx" } }, "end": "(?<=\\))|(?=[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))new(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))function((\\s+[_$[:alpha:]][_$[:alnum:]]*)|(\\s*[\\(]))))", "name": "new.expr.tsx", "patterns": [{ "include": "#expression" }] }, "null-literal": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))null(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "constant.language.null.tsx" }, "numeric-literal": { "patterns": [{ "captures": { "1": { "name": "storage.type.numeric.bigint.tsx" } }, "match": "\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$)", "name": "constant.numeric.hex.tsx" }, { "captures": { "1": { "name": "storage.type.numeric.bigint.tsx" } }, "match": "\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$)", "name": "constant.numeric.binary.tsx" }, { "captures": { "1": { "name": "storage.type.numeric.bigint.tsx" } }, "match": "\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$)", "name": "constant.numeric.octal.tsx" }, { "captures": { "0": { "name": "constant.numeric.decimal.tsx" }, "1": { "name": "meta.delimiter.decimal.period.tsx" }, "2": { "name": "storage.type.numeric.bigint.tsx" }, "3": { "name": "meta.delimiter.decimal.period.tsx" }, "4": { "name": "storage.type.numeric.bigint.tsx" }, "5": { "name": "meta.delimiter.decimal.period.tsx" }, "6": { "name": "storage.type.numeric.bigint.tsx" }, "7": { "name": "storage.type.numeric.bigint.tsx" }, "8": { "name": "meta.delimiter.decimal.period.tsx" }, "9": { "name": "storage.type.numeric.bigint.tsx" }, "10": { "name": "meta.delimiter.decimal.period.tsx" }, "11": { "name": "storage.type.numeric.bigint.tsx" }, "12": { "name": "meta.delimiter.decimal.period.tsx" }, "13": { "name": "storage.type.numeric.bigint.tsx" }, "14": { "name": "storage.type.numeric.bigint.tsx" } }, "match": "(?x)\n(?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$)" }] }, "numericConstant-literal": { "patterns": [{ "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))NaN(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "constant.language.nan.tsx" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Infinity(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "constant.language.infinity.tsx" }] }, "object-binding-element": { "patterns": [{ "include": "#comment" }, { "begin": "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))", "end": "(?=,|\\})", "patterns": [{ "include": "#object-binding-element-propertyName" }, { "include": "#binding-element" }] }, { "include": "#object-binding-pattern" }, { "include": "#destructuring-variable-rest" }, { "include": "#variable-initializer" }, { "include": "#punctuation-comma" }] }, "object-binding-element-const": { "patterns": [{ "include": "#comment" }, { "begin": "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))", "end": "(?=,|\\})", "patterns": [{ "include": "#object-binding-element-propertyName" }, { "include": "#binding-element-const" }] }, { "include": "#object-binding-pattern-const" }, { "include": "#destructuring-variable-rest-const" }, { "include": "#variable-initializer" }, { "include": "#punctuation-comma" }] }, "object-binding-element-propertyName": { "begin": "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))", "end": "(:)", "endCaptures": { "0": { "name": "punctuation.destructuring.tsx" } }, "patterns": [{ "include": "#string" }, { "include": "#array-literal" }, { "include": "#numeric-literal" }, { "match": "([_$[:alpha:]][_$[:alnum:]]*)", "name": "variable.object.property.tsx" }] }, "object-binding-pattern": { "begin": "(?:(\\.\\.\\.)\\s*)?(\\{)", "beginCaptures": { "1": { "name": "keyword.operator.rest.tsx" }, "2": { "name": "punctuation.definition.binding-pattern.object.tsx" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.object.tsx" } }, "patterns": [{ "include": "#object-binding-element" }] }, "object-binding-pattern-const": { "begin": "(?:(\\.\\.\\.)\\s*)?(\\{)", "beginCaptures": { "1": { "name": "keyword.operator.rest.tsx" }, "2": { "name": "punctuation.definition.binding-pattern.object.tsx" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.object.tsx" } }, "patterns": [{ "include": "#object-binding-element-const" }] }, "object-identifiers": { "patterns": [{ "match": "([_$[:alpha:]][_$[:alnum:]]*)(?=\\s*\\??\\.\\s*prototype\\b(?!\\$))", "name": "support.class.tsx" }, { "captures": { "1": { "name": "punctuation.accessor.tsx" }, "2": { "name": "punctuation.accessor.optional.tsx" }, "3": { "name": "variable.other.constant.object.property.tsx" }, "4": { "name": "variable.other.object.property.tsx" } }, "match": "(?x)(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(?:\n  (\\#?[[:upper:]][_$[:digit:][:upper:]]*) |\n  (\\#?[_$[:alpha:]][_$[:alnum:]]*)\n)(?=\\s*\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*)" }, { "captures": { "1": { "name": "variable.other.constant.object.tsx" }, "2": { "name": "variable.other.object.tsx" } }, "match": "(?x)(?:\n  ([[:upper:]][_$[:digit:][:upper:]]*) |\n  ([_$[:alpha:]][_$[:alnum:]]*)\n)(?=\\s*\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*)" }] }, "object-literal": { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.block.tsx" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.tsx" } }, "name": "meta.objectliteral.tsx", "patterns": [{ "include": "#object-member" }] }, "object-literal-method-declaration": { "begin": "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(async)\\s+)?(?:\\b(get|set)\\s+)?(?:(\\*)\\s*)?(?=\\s*(((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??))\\s*((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])", "beginCaptures": { "1": { "name": "storage.modifier.async.tsx" }, "2": { "name": "storage.type.property.tsx" }, "3": { "name": "keyword.generator.asterisk.tsx" } }, "end": "(?=\\}|;|,)|(?<=\\})", "name": "meta.method.declaration.tsx", "patterns": [{ "include": "#method-declaration-name" }, { "include": "#function-body" }, { "begin": "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(async)\\s+)?(?:\\b(get|set)\\s+)?(?:(\\*)\\s*)?(?=\\s*(((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??))\\s*((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])", "beginCaptures": { "1": { "name": "storage.modifier.async.tsx" }, "2": { "name": "storage.type.property.tsx" }, "3": { "name": "keyword.generator.asterisk.tsx" } }, "end": "(?=\\(|\\<)", "patterns": [{ "include": "#method-declaration-name" }] }] }, "object-member": { "patterns": [{ "include": "#comment" }, { "include": "#object-literal-method-declaration" }, { "begin": "(?=\\[)", "end": "(?=:)|((?<=[\\]])(?=\\s*[\\(\\<]))", "name": "meta.object.member.tsx meta.object-literal.key.tsx", "patterns": [{ "include": "#comment" }, { "include": "#array-literal" }] }, { "begin": "(?=[\\'\\\"\\`])", "end": "(?=:)|((?<=[\\'\\\"\\`])(?=((\\s*[\\(\\<,}])|(\\s+(as|satisifies)\\s+))))", "name": "meta.object.member.tsx meta.object-literal.key.tsx", "patterns": [{ "include": "#comment" }, { "include": "#string" }] }, { "begin": "(?x)(?=(\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$)))", "end": "(?=:)|(?=\\s*([\\(\\<,}])|(\\s+as|satisifies\\s+))", "name": "meta.object.member.tsx meta.object-literal.key.tsx", "patterns": [{ "include": "#comment" }, { "include": "#numeric-literal" }] }, { "begin": "(?<=[\\]\\'\\\"\\`])(?=\\s*[\\(\\<])", "end": "(?=\\}|;|,)|(?<=\\})", "name": "meta.method.declaration.tsx", "patterns": [{ "include": "#function-body" }] }, { "captures": { "0": { "name": "meta.object-literal.key.tsx" }, "1": { "name": "constant.numeric.decimal.tsx" } }, "match": "(?![_$[:alpha:]])([[:digit:]]+)\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*:)", "name": "meta.object.member.tsx" }, { "captures": { "0": { "name": "meta.object-literal.key.tsx" }, "1": { "name": "entity.name.function.tsx" } }, "match": "(?x)(?:([_$[:alpha:]][_$[:alnum:]]*)\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*:(\\s*\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/)*\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))", "name": "meta.object.member.tsx" }, { "captures": { "0": { "name": "meta.object-literal.key.tsx" } }, "match": "(?:[_$[:alpha:]][_$[:alnum:]]*)\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*:)", "name": "meta.object.member.tsx" }, { "begin": "\\.\\.\\.", "beginCaptures": { "0": { "name": "keyword.operator.spread.tsx" } }, "end": "(?=,|\\})", "name": "meta.object.member.tsx", "patterns": [{ "include": "#expression" }] }, { "captures": { "1": { "name": "variable.other.readwrite.tsx" } }, "match": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?=,|\\}|$|\\/\\/|\\/\\*)", "name": "meta.object.member.tsx" }, { "captures": { "1": { "name": "keyword.control.as.tsx" }, "2": { "name": "storage.modifier.tsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+(const)(?=\\s*([,}]|$))", "name": "meta.object.member.tsx" }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(as)|(satisfies))\\s+", "beginCaptures": { "1": { "name": "keyword.control.as.tsx" }, "2": { "name": "keyword.control.satisfies.tsx" } }, "end": "(?=[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|^|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as|satisifies)\\s+))", "name": "meta.object.member.tsx", "patterns": [{ "include": "#type" }] }, { "begin": "(?=[_$[:alpha:]][_$[:alnum:]]*\\s*=)", "end": "(?=,|\\}|$|\\/\\/|\\/\\*)", "name": "meta.object.member.tsx", "patterns": [{ "include": "#expression" }] }, { "begin": ":", "beginCaptures": { "0": { "name": "meta.object-literal.key.tsx punctuation.separator.key-value.tsx" } }, "end": "(?=,|\\})", "name": "meta.object.member.tsx", "patterns": [{ "begin": "(?<=:)\\s*(async)?(?=\\s*(<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)\\(\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))", "beginCaptures": { "1": { "name": "storage.modifier.async.tsx" } }, "end": "(?<=\\))", "patterns": [{ "include": "#type-parameters" }, { "begin": "\\(", "beginCaptures": { "0": { "name": "meta.brace.round.tsx" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.tsx" } }, "patterns": [{ "include": "#expression-inside-possibly-arrow-parens" }] }] }, { "begin": "(?<=:)\\s*(async)?\\s*(\\()(?=\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))", "beginCaptures": { "1": { "name": "storage.modifier.async.tsx" }, "2": { "name": "meta.brace.round.tsx" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.tsx" } }, "patterns": [{ "include": "#expression-inside-possibly-arrow-parens" }] }, { "begin": "(?<=:)\\s*(async)?\\s*(?=\\<\\s*$)", "beginCaptures": { "1": { "name": "storage.modifier.async.tsx" } }, "end": "(?<=\\>)", "patterns": [{ "include": "#type-parameters" }] }, { "begin": "(?<=\\>)\\s*(\\()(?=\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))", "beginCaptures": { "1": { "name": "meta.brace.round.tsx" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.tsx" } }, "patterns": [{ "include": "#expression-inside-possibly-arrow-parens" }] }, { "include": "#possibly-arrow-return-type" }, { "include": "#expression" }] }, { "include": "#punctuation-comma" }, { "include": "#decl-block" }] }, "parameter-array-binding-pattern": { "begin": "(?:(\\.\\.\\.)\\s*)?(\\[)", "beginCaptures": { "1": { "name": "keyword.operator.rest.tsx" }, "2": { "name": "punctuation.definition.binding-pattern.array.tsx" } }, "end": "\\]", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.array.tsx" } }, "patterns": [{ "include": "#parameter-binding-element" }, { "include": "#punctuation-comma" }] }, "parameter-binding-element": { "patterns": [{ "include": "#comment" }, { "include": "#string" }, { "include": "#numeric-literal" }, { "include": "#regex" }, { "include": "#parameter-object-binding-pattern" }, { "include": "#parameter-array-binding-pattern" }, { "include": "#destructuring-parameter-rest" }, { "include": "#variable-initializer" }] }, "parameter-name": { "patterns": [{ "captures": { "1": { "name": "storage.modifier.tsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|protected|private|readonly)\\s+(?=(override|public|protected|private|readonly)\\s+)" }, { "captures": { "1": { "name": "storage.modifier.tsx" }, "2": { "name": "keyword.operator.rest.tsx" }, "3": { "name": "entity.name.function.tsx variable.language.this.tsx" }, "4": { "name": "entity.name.function.tsx" }, "5": { "name": "keyword.operator.optional.tsx" } }, "match": "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))" }, { "captures": { "1": { "name": "storage.modifier.tsx" }, "2": { "name": "keyword.operator.rest.tsx" }, "3": { "name": "variable.parameter.tsx variable.language.this.tsx" }, "4": { "name": "variable.parameter.tsx" }, "5": { "name": "keyword.operator.optional.tsx" } }, "match": "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)" }] }, "parameter-object-binding-element": { "patterns": [{ "include": "#comment" }, { "begin": "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))", "end": "(?=,|\\})", "patterns": [{ "include": "#object-binding-element-propertyName" }, { "include": "#parameter-binding-element" }, { "include": "#paren-expression" }] }, { "include": "#parameter-object-binding-pattern" }, { "include": "#destructuring-parameter-rest" }, { "include": "#variable-initializer" }, { "include": "#punctuation-comma" }] }, "parameter-object-binding-pattern": { "begin": "(?:(\\.\\.\\.)\\s*)?(\\{)", "beginCaptures": { "1": { "name": "keyword.operator.rest.tsx" }, "2": { "name": "punctuation.definition.binding-pattern.object.tsx" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.binding-pattern.object.tsx" } }, "patterns": [{ "include": "#parameter-object-binding-element" }] }, "parameter-type-annotation": { "patterns": [{ "begin": "(:)", "beginCaptures": { "1": { "name": "keyword.operator.type.annotation.tsx" } }, "end": "(?=[,)])|(?==[^>])", "name": "meta.type.annotation.tsx", "patterns": [{ "include": "#type" }] }] }, "paren-expression": { "begin": "\\(", "beginCaptures": { "0": { "name": "meta.brace.round.tsx" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.tsx" } }, "patterns": [{ "include": "#expression" }] }, "paren-expression-possibly-arrow": { "patterns": [{ "begin": "(?<=[(=,])\\s*(async)?(?=\\s*((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?\\(\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))", "beginCaptures": { "1": { "name": "storage.modifier.async.tsx" } }, "end": "(?<=\\))", "patterns": [{ "include": "#paren-expression-possibly-arrow-with-typeparameters" }] }, { "begin": "(?<=[(=,]|=>|^return|[^\\._$[:alnum:]]return)\\s*(async)?(?=\\s*((((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?\\()|(<)|((<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)))\\s*$)", "beginCaptures": { "1": { "name": "storage.modifier.async.tsx" } }, "end": "(?<=\\))", "patterns": [{ "include": "#paren-expression-possibly-arrow-with-typeparameters" }] }, { "include": "#possibly-arrow-return-type" }] }, "paren-expression-possibly-arrow-with-typeparameters": { "patterns": [{ "include": "#type-parameters" }, { "begin": "\\(", "beginCaptures": { "0": { "name": "meta.brace.round.tsx" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.tsx" } }, "patterns": [{ "include": "#expression-inside-possibly-arrow-parens" }] }] }, "possibly-arrow-return-type": { "begin": "(?<=\\)|^)\\s*(:)(?=\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*=>)", "beginCaptures": { "1": { "name": "meta.arrow.tsx meta.return.type.arrow.tsx keyword.operator.type.annotation.tsx" } }, "contentName": "meta.arrow.tsx meta.return.type.arrow.tsx", "end": "(?==>|\\{|(^\\s*(export|function|class|interface|let|var|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|const|import|enum|namespace|module|type|abstract|declare)\\s+))", "patterns": [{ "include": "#arrow-return-type-body" }] }, "property-accessor": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(accessor|get|set)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "storage.type.property.tsx" }, "punctuation-accessor": { "captures": { "1": { "name": "punctuation.accessor.tsx" }, "2": { "name": "punctuation.accessor.optional.tsx" } }, "match": "(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))" }, "punctuation-comma": { "match": ",", "name": "punctuation.separator.comma.tsx" }, "punctuation-semicolon": { "match": ";", "name": "punctuation.terminator.statement.tsx" }, "qstring-double": { "begin": '"', "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.tsx" } }, "end": '(")|((?:[^\\\\\\n])$)', "endCaptures": { "1": { "name": "punctuation.definition.string.end.tsx" }, "2": { "name": "invalid.illegal.newline.tsx" } }, "name": "string.quoted.double.tsx", "patterns": [{ "include": "#string-character-escape" }] }, "qstring-single": { "begin": "'", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.tsx" } }, "end": "(\\')|((?:[^\\\\\\n])$)", "endCaptures": { "1": { "name": "punctuation.definition.string.end.tsx" }, "2": { "name": "invalid.illegal.newline.tsx" } }, "name": "string.quoted.single.tsx", "patterns": [{ "include": "#string-character-escape" }] }, "regex": { "patterns": [{ "begin": "(?<!\\+\\+|--|})(?<=[=(:,\\[?+!]|^return|[^\\._$[:alnum:]]return|^case|[^\\._$[:alnum:]]case|=>|&&|\\|\\||\\*\\/)\\s*(\\/)(?![\\/*])(?=(?:[^\\/\\\\\\[\\()]|\\\\.|\\[([^\\]\\\\]|\\\\.)+\\]|\\(([^\\)\\\\]|\\\\.)+\\))+\\/([dgimsuy]+|(?![\\/\\*])|(?=\\/\\*))(?!\\s*[a-zA-Z0-9_$]))", "beginCaptures": { "1": { "name": "punctuation.definition.string.begin.tsx" } }, "end": "(/)([dgimsuy]*)", "endCaptures": { "1": { "name": "punctuation.definition.string.end.tsx" }, "2": { "name": "keyword.other.tsx" } }, "name": "string.regexp.tsx", "patterns": [{ "include": "#regexp" }] }, { "begin": "((?<![_$[:alnum:])\\]]|\\+\\+|--|}|\\*\\/)|((?<=^return|[^\\._$[:alnum:]]return|^case|[^\\._$[:alnum:]]case))\\s*)\\/(?![\\/*])(?=(?:[^\\/\\\\\\[]|\\\\.|\\[([^\\]\\\\]|\\\\.)*\\])+\\/([dgimsuy]+|(?![\\/\\*])|(?=\\/\\*))(?!\\s*[a-zA-Z0-9_$]))", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.tsx" } }, "end": "(/)([dgimsuy]*)", "endCaptures": { "1": { "name": "punctuation.definition.string.end.tsx" }, "2": { "name": "keyword.other.tsx" } }, "name": "string.regexp.tsx", "patterns": [{ "include": "#regexp" }] }] }, "regex-character-class": { "patterns": [{ "match": "\\\\[wWsSdDtrnvf]|\\.", "name": "constant.other.character-class.regexp" }, { "match": "\\\\([0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4})", "name": "constant.character.numeric.regexp" }, { "match": "\\\\c[A-Z]", "name": "constant.character.control.regexp" }, { "match": "\\\\.", "name": "constant.character.escape.backslash.regexp" }] }, "regexp": { "patterns": [{ "match": "\\\\[bB]|\\^|\\$", "name": "keyword.control.anchor.regexp" }, { "captures": { "0": { "name": "keyword.other.back-reference.regexp" }, "1": { "name": "variable.other.regexp" } }, "match": "\\\\[1-9]\\d*|\\\\k<([a-zA-Z_$][\\w$]*)>" }, { "match": "[?+*]|\\{(\\d+,\\d+|\\d+,|,\\d+|\\d+)\\}\\??", "name": "keyword.operator.quantifier.regexp" }, { "match": "\\|", "name": "keyword.operator.or.regexp" }, { "begin": "(\\()((\\?=)|(\\?!)|(\\?<=)|(\\?<!))", "beginCaptures": { "1": { "name": "punctuation.definition.group.regexp" }, "2": { "name": "punctuation.definition.group.assertion.regexp" }, "3": { "name": "meta.assertion.look-ahead.regexp" }, "4": { "name": "meta.assertion.negative-look-ahead.regexp" }, "5": { "name": "meta.assertion.look-behind.regexp" }, "6": { "name": "meta.assertion.negative-look-behind.regexp" } }, "end": "(\\))", "endCaptures": { "1": { "name": "punctuation.definition.group.regexp" } }, "name": "meta.group.assertion.regexp", "patterns": [{ "include": "#regexp" }] }, { "begin": "\\((?:(\\?:)|(?:\\?<([a-zA-Z_$][\\w$]*)>))?", "beginCaptures": { "0": { "name": "punctuation.definition.group.regexp" }, "1": { "name": "punctuation.definition.group.no-capture.regexp" }, "2": { "name": "variable.other.regexp" } }, "end": "\\)", "endCaptures": { "0": { "name": "punctuation.definition.group.regexp" } }, "name": "meta.group.regexp", "patterns": [{ "include": "#regexp" }] }, { "begin": "(\\[)(\\^)?", "beginCaptures": { "1": { "name": "punctuation.definition.character-class.regexp" }, "2": { "name": "keyword.operator.negation.regexp" } }, "end": "(\\])", "endCaptures": { "1": { "name": "punctuation.definition.character-class.regexp" } }, "name": "constant.other.character-class.set.regexp", "patterns": [{ "captures": { "1": { "name": "constant.character.numeric.regexp" }, "2": { "name": "constant.character.control.regexp" }, "3": { "name": "constant.character.escape.backslash.regexp" }, "4": { "name": "constant.character.numeric.regexp" }, "5": { "name": "constant.character.control.regexp" }, "6": { "name": "constant.character.escape.backslash.regexp" } }, "match": "(?:.|(\\\\(?:[0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}))|(\\\\c[A-Z])|(\\\\.))\\-(?:[^\\]\\\\]|(\\\\(?:[0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}))|(\\\\c[A-Z])|(\\\\.))", "name": "constant.other.character-class.range.regexp" }, { "include": "#regex-character-class" }] }, { "include": "#regex-character-class" }] }, "return-type": { "patterns": [{ "begin": "(?<=\\))\\s*(:)(?=\\s*\\S)", "beginCaptures": { "1": { "name": "keyword.operator.type.annotation.tsx" } }, "end": "(?<![:|&])(?=$|^|[{};,]|//)", "name": "meta.return.type.tsx", "patterns": [{ "include": "#return-type-core" }] }, { "begin": "(?<=\\))\\s*(:)", "beginCaptures": { "1": { "name": "keyword.operator.type.annotation.tsx" } }, "end": "(?<![:|&])((?=[{};,]|//|^\\s*$)|((?<=\\S)(?=\\s*$)))", "name": "meta.return.type.tsx", "patterns": [{ "include": "#return-type-core" }] }] }, "return-type-core": { "patterns": [{ "include": "#comment" }, { "begin": "(?<=[:|&])(?=\\s*\\{)", "end": "(?<=\\})", "patterns": [{ "include": "#type-object" }] }, { "include": "#type-predicate-operator" }, { "include": "#type" }] }, "shebang": { "captures": { "1": { "name": "punctuation.definition.comment.tsx" } }, "match": "\\A(#!).*(?=$)", "name": "comment.line.shebang.tsx" }, "single-line-comment-consuming-line-ending": { "begin": "(^[ \\t]+)?((//)(?:\\s*((@)internal)(?=\\s|$))?)", "beginCaptures": { "1": { "name": "punctuation.whitespace.comment.leading.tsx" }, "2": { "name": "comment.line.double-slash.tsx" }, "3": { "name": "punctuation.definition.comment.tsx" }, "4": { "name": "storage.type.internaldeclaration.tsx" }, "5": { "name": "punctuation.decorator.internaldeclaration.tsx" } }, "contentName": "comment.line.double-slash.tsx", "end": "(?=^)" }, "statements": { "patterns": [{ "include": "#declaration" }, { "include": "#control-statement" }, { "include": "#after-operator-block-as-object-literal" }, { "include": "#decl-block" }, { "include": "#label" }, { "include": "#expression" }, { "include": "#punctuation-semicolon" }, { "include": "#string" }, { "include": "#comment" }] }, "string": { "patterns": [{ "include": "#qstring-single" }, { "include": "#qstring-double" }, { "include": "#template" }] }, "string-character-escape": { "match": "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|u\\{[0-9A-Fa-f]+\\}|[0-2][0-7]{0,2}|3[0-6][0-7]?|37[0-7]?|[4-7][0-7]?|.|$)", "name": "constant.character.escape.tsx" }, "super-literal": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))super\\b(?!\\$)", "name": "variable.language.super.tsx" }, "support-function-call-identifiers": { "patterns": [{ "include": "#literal" }, { "include": "#support-objects" }, { "include": "#object-identifiers" }, { "include": "#punctuation-accessor" }, { "match": "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))import(?=\\s*[\\(]\\s*[\\\"\\'\\`]))", "name": "keyword.operator.expression.import.tsx" }] }, "support-objects": { "patterns": [{ "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(arguments)\\b(?!\\$)", "name": "variable.language.arguments.tsx" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(Promise)\\b(?!\\$)", "name": "support.class.promise.tsx" }, { "captures": { "1": { "name": "keyword.control.import.tsx" }, "2": { "name": "punctuation.accessor.tsx" }, "3": { "name": "punctuation.accessor.optional.tsx" }, "4": { "name": "support.variable.property.importmeta.tsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(import)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(meta)\\b(?!\\$)" }, { "captures": { "1": { "name": "keyword.operator.new.tsx" }, "2": { "name": "punctuation.accessor.tsx" }, "3": { "name": "punctuation.accessor.optional.tsx" }, "4": { "name": "support.variable.property.target.tsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(new)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(target)\\b(?!\\$)" }, { "captures": { "1": { "name": "punctuation.accessor.tsx" }, "2": { "name": "punctuation.accessor.optional.tsx" }, "3": { "name": "support.variable.property.tsx" }, "4": { "name": "support.constant.tsx" } }, "match": "(?x) (?:(\\.)|(\\?\\.(?!\\s*[[:digit:]]))) \\s* (?:\n  (?:(constructor|length|prototype|__proto__)\\b(?!\\$|\\s*(<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\\())\n  |\n  (?:(EPSILON|MAX_SAFE_INTEGER|MAX_VALUE|MIN_SAFE_INTEGER|MIN_VALUE|NEGATIVE_INFINITY|POSITIVE_INFINITY)\\b(?!\\$)))" }, { "captures": { "1": { "name": "support.type.object.module.tsx" }, "2": { "name": "support.type.object.module.tsx" }, "3": { "name": "punctuation.accessor.tsx" }, "4": { "name": "punctuation.accessor.optional.tsx" }, "5": { "name": "support.type.object.module.tsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(exports)|(module)(?:(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))(exports|id|filename|loaded|parent|children))?)\\b(?!\\$)" }] }, "switch-statement": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?=\\bswitch\\s*\\()", "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.tsx" } }, "name": "switch-statement.expr.tsx", "patterns": [{ "include": "#comment" }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(switch)\\s*(\\()", "beginCaptures": { "1": { "name": "keyword.control.switch.tsx" }, "2": { "name": "meta.brace.round.tsx" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.tsx" } }, "name": "switch-expression.expr.tsx", "patterns": [{ "include": "#expression" }] }, { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.block.tsx" } }, "end": "(?=\\})", "name": "switch-block.expr.tsx", "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(case|default(?=:))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "1": { "name": "keyword.control.switch.tsx" } }, "end": "(?=:)", "name": "case-clause.expr.tsx", "patterns": [{ "include": "#expression" }] }, { "begin": "(:)\\s*(\\{)", "beginCaptures": { "1": { "name": "case-clause.expr.tsx punctuation.definition.section.case-statement.tsx" }, "2": { "name": "meta.block.tsx punctuation.definition.block.tsx" } }, "contentName": "meta.block.tsx", "end": "\\}", "endCaptures": { "0": { "name": "meta.block.tsx punctuation.definition.block.tsx" } }, "patterns": [{ "include": "#statements" }] }, { "captures": { "0": { "name": "case-clause.expr.tsx punctuation.definition.section.case-statement.tsx" } }, "match": "(:)" }, { "include": "#statements" }] }] }, "template": { "patterns": [{ "include": "#template-call" }, { "begin": "([_$[:alpha:]][_$[:alnum:]]*)?(`)", "beginCaptures": { "1": { "name": "entity.name.function.tagged-template.tsx" }, "2": { "name": "string.template.tsx punctuation.definition.string.template.begin.tsx" } }, "contentName": "string.template.tsx", "end": "`", "endCaptures": { "0": { "name": "string.template.tsx punctuation.definition.string.template.end.tsx" } }, "patterns": [{ "include": "#template-substitution-element" }, { "include": "#string-character-escape" }] }] }, "template-call": { "patterns": [{ "begin": "(?=(([_$[:alpha:]][_$[:alnum:]]*\\s*\\??\\.\\s*)*|(\\??\\.\\s*)?)([_$[:alpha:]][_$[:alnum:]]*)(<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?`)", "end": "(?=`)", "patterns": [{ "begin": "(?=(([_$[:alpha:]][_$[:alnum:]]*\\s*\\??\\.\\s*)*|(\\??\\.\\s*)?)([_$[:alpha:]][_$[:alnum:]]*))", "end": "(?=(<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?`)", "patterns": [{ "include": "#support-function-call-identifiers" }, { "match": "([_$[:alpha:]][_$[:alnum:]]*)", "name": "entity.name.function.tagged-template.tsx" }] }, { "include": "#type-arguments" }] }, { "begin": "([_$[:alpha:]][_$[:alnum:]]*)?\\s*(?=(<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)`)", "beginCaptures": { "1": { "name": "entity.name.function.tagged-template.tsx" } }, "end": "(?=`)", "patterns": [{ "include": "#type-arguments" }] }] }, "template-substitution-element": { "begin": "\\$\\{", "beginCaptures": { "0": { "name": "punctuation.definition.template-expression.begin.tsx" } }, "contentName": "meta.embedded.line.tsx", "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.template-expression.end.tsx" } }, "name": "meta.template.expression.tsx", "patterns": [{ "include": "#expression" }] }, "template-type": { "patterns": [{ "include": "#template-call" }, { "begin": "([_$[:alpha:]][_$[:alnum:]]*)?(`)", "beginCaptures": { "1": { "name": "entity.name.function.tagged-template.tsx" }, "2": { "name": "string.template.tsx punctuation.definition.string.template.begin.tsx" } }, "contentName": "string.template.tsx", "end": "`", "endCaptures": { "0": { "name": "string.template.tsx punctuation.definition.string.template.end.tsx" } }, "patterns": [{ "include": "#template-type-substitution-element" }, { "include": "#string-character-escape" }] }] }, "template-type-substitution-element": { "begin": "\\$\\{", "beginCaptures": { "0": { "name": "punctuation.definition.template-expression.begin.tsx" } }, "contentName": "meta.embedded.line.tsx", "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.template-expression.end.tsx" } }, "name": "meta.template.expression.tsx", "patterns": [{ "include": "#type" }] }, "ternary-expression": { "begin": "(?!\\?\\.\\s*[^[:digit:]])(\\?)(?!\\?)", "beginCaptures": { "1": { "name": "keyword.operator.ternary.tsx" } }, "end": "\\s*(:)", "endCaptures": { "1": { "name": "keyword.operator.ternary.tsx" } }, "patterns": [{ "include": "#expression" }] }, "this-literal": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))this\\b(?!\\$)", "name": "variable.language.this.tsx" }, "type": { "patterns": [{ "include": "#comment" }, { "include": "#type-string" }, { "include": "#numeric-literal" }, { "include": "#type-primitive" }, { "include": "#type-builtin-literals" }, { "include": "#type-parameters" }, { "include": "#type-tuple" }, { "include": "#type-object" }, { "include": "#type-operators" }, { "include": "#type-conditional" }, { "include": "#type-fn-type-parameters" }, { "include": "#type-paren-or-function-parameters" }, { "include": "#type-function-return-type" }, { "captures": { "1": { "name": "storage.modifier.tsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(readonly)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*" }, { "include": "#type-name" }] }, "type-alias-declaration": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(type)\\b\\s+([_$[:alpha:]][_$[:alnum:]]*)\\s*", "beginCaptures": { "1": { "name": "keyword.control.export.tsx" }, "2": { "name": "storage.modifier.tsx" }, "3": { "name": "storage.type.type.tsx" }, "4": { "name": "entity.name.type.alias.tsx" } }, "end": "(?=\\}|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "name": "meta.type.declaration.tsx", "patterns": [{ "include": "#comment" }, { "include": "#type-parameters" }, { "begin": "(=)\\s*(intrinsic)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "1": { "name": "keyword.operator.assignment.tsx" }, "2": { "name": "keyword.control.intrinsic.tsx" } }, "end": "(?=\\}|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "patterns": [{ "include": "#type" }] }, { "begin": "(=)\\s*", "beginCaptures": { "1": { "name": "keyword.operator.assignment.tsx" } }, "end": "(?=\\}|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "patterns": [{ "include": "#type" }] }] }, "type-annotation": { "patterns": [{ "begin": "(:)(?=\\s*\\S)", "beginCaptures": { "1": { "name": "keyword.operator.type.annotation.tsx" } }, "end": "(?<![:|&])(?!\\s*[|&]\\s+)((?=^|[,);\\}\\]]|//)|(?==[^>])|((?<=[\\}>\\]\\)]|[_$[:alpha:]])\\s*(?=\\{)))", "name": "meta.type.annotation.tsx", "patterns": [{ "include": "#type" }] }, { "begin": "(:)", "beginCaptures": { "1": { "name": "keyword.operator.type.annotation.tsx" } }, "end": "(?<![:|&])((?=[,);\\}\\]]|\\/\\/)|(?==[^>])|(?=^\\s*$)|((?<=[\\}>\\]\\)]|[_$[:alpha:]])\\s*(?=\\{)))", "name": "meta.type.annotation.tsx", "patterns": [{ "include": "#type" }] }] }, "type-arguments": { "begin": "\\<", "beginCaptures": { "0": { "name": "punctuation.definition.typeparameters.begin.tsx" } }, "end": "\\>", "endCaptures": { "0": { "name": "punctuation.definition.typeparameters.end.tsx" } }, "name": "meta.type.parameters.tsx", "patterns": [{ "include": "#type-arguments-body" }] }, "type-arguments-body": { "patterns": [{ "captures": { "0": { "name": "keyword.operator.type.tsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(_)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))" }, { "include": "#type" }, { "include": "#punctuation-comma" }] }, "type-builtin-literals": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(this|true|false|undefined|null|object)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "support.type.builtin.tsx" }, "type-conditional": { "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(extends)\\s+", "beginCaptures": { "1": { "name": "storage.modifier.tsx" } }, "end": "(?<=:)", "patterns": [{ "begin": "\\?", "beginCaptures": { "0": { "name": "keyword.operator.ternary.tsx" } }, "end": ":", "endCaptures": { "0": { "name": "keyword.operator.ternary.tsx" } }, "patterns": [{ "include": "#type" }] }, { "include": "#type" }] }] }, "type-fn-type-parameters": { "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(abstract)\\s+)?(new)\\b(?=\\s*\\<)", "beginCaptures": { "1": { "name": "meta.type.constructor.tsx storage.modifier.tsx" }, "2": { "name": "meta.type.constructor.tsx keyword.control.new.tsx" } }, "end": "(?<=>)", "patterns": [{ "include": "#comment" }, { "include": "#type-parameters" }] }, { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(abstract)\\s+)?(new)\\b\\s*(?=\\()", "beginCaptures": { "1": { "name": "storage.modifier.tsx" }, "2": { "name": "keyword.control.new.tsx" } }, "end": "(?<=\\))", "name": "meta.type.constructor.tsx", "patterns": [{ "include": "#function-parameters" }] }, { "begin": "(?x)(\n  (?=\n    [(]\\s*(\n      ([)]) |\n      (\\.\\.\\.) |\n      ([_$[:alnum:]]+\\s*(\n        ([:,?=])|\n        ([)]\\s*=>)\n      ))\n    )\n  )\n)", "end": "(?<=\\))", "name": "meta.type.function.tsx", "patterns": [{ "include": "#function-parameters" }] }] }, "type-function-return-type": { "patterns": [{ "begin": "(=>)(?=\\s*\\S)", "beginCaptures": { "1": { "name": "storage.type.function.arrow.tsx" } }, "end": "(?<!=>)(?<![|&])(?=[,\\]\\)\\{\\}=;>:\\?]|//|$)", "name": "meta.type.function.return.tsx", "patterns": [{ "include": "#type-function-return-type-core" }] }, { "begin": "=>", "beginCaptures": { "0": { "name": "storage.type.function.arrow.tsx" } }, "end": "(?<!=>)(?<![|&])((?=[,\\]\\)\\{\\}=;:\\?>]|//|^\\s*$)|((?<=\\S)(?=\\s*$)))", "name": "meta.type.function.return.tsx", "patterns": [{ "include": "#type-function-return-type-core" }] }] }, "type-function-return-type-core": { "patterns": [{ "include": "#comment" }, { "begin": "(?<==>)(?=\\s*\\{)", "end": "(?<=\\})", "patterns": [{ "include": "#type-object" }] }, { "include": "#type-predicate-operator" }, { "include": "#type" }] }, "type-infer": { "patterns": [{ "captures": { "1": { "name": "keyword.operator.expression.infer.tsx" }, "2": { "name": "entity.name.type.tsx" }, "3": { "name": "keyword.operator.expression.extends.tsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(infer)\\s+([_$[:alpha:]][_$[:alnum:]]*)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?:\\s+(extends)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))?", "name": "meta.type.infer.tsx" }] }, "type-name": { "patterns": [{ "begin": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(<)", "captures": { "1": { "name": "entity.name.type.module.tsx" }, "2": { "name": "punctuation.accessor.tsx" }, "3": { "name": "punctuation.accessor.optional.tsx" }, "4": { "name": "meta.type.parameters.tsx punctuation.definition.typeparameters.begin.tsx" } }, "contentName": "meta.type.parameters.tsx", "end": "(>)", "endCaptures": { "1": { "name": "meta.type.parameters.tsx punctuation.definition.typeparameters.end.tsx" } }, "patterns": [{ "include": "#type-arguments-body" }] }, { "begin": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(<)", "beginCaptures": { "1": { "name": "entity.name.type.tsx" }, "2": { "name": "meta.type.parameters.tsx punctuation.definition.typeparameters.begin.tsx" } }, "contentName": "meta.type.parameters.tsx", "end": "(>)", "endCaptures": { "1": { "name": "meta.type.parameters.tsx punctuation.definition.typeparameters.end.tsx" } }, "patterns": [{ "include": "#type-arguments-body" }] }, { "captures": { "1": { "name": "entity.name.type.module.tsx" }, "2": { "name": "punctuation.accessor.tsx" }, "3": { "name": "punctuation.accessor.optional.tsx" } }, "match": "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))" }, { "match": "[_$[:alpha:]][_$[:alnum:]]*", "name": "entity.name.type.tsx" }] }, "type-object": { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.block.tsx" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.block.tsx" } }, "name": "meta.object.type.tsx", "patterns": [{ "include": "#comment" }, { "include": "#method-declaration" }, { "include": "#indexer-declaration" }, { "include": "#indexer-mapped-type-declaration" }, { "include": "#field-declaration" }, { "include": "#type-annotation" }, { "begin": "\\.\\.\\.", "beginCaptures": { "0": { "name": "keyword.operator.spread.tsx" } }, "end": "(?=\\}|;|,|$)|(?<=\\})", "patterns": [{ "include": "#type" }] }, { "include": "#punctuation-comma" }, { "include": "#punctuation-semicolon" }, { "include": "#type" }] }, "type-operators": { "patterns": [{ "include": "#typeof-operator" }, { "include": "#type-infer" }, { "begin": "([&|])(?=\\s*\\{)", "beginCaptures": { "0": { "name": "keyword.operator.type.tsx" } }, "end": "(?<=\\})", "patterns": [{ "include": "#type-object" }] }, { "begin": "[&|]", "beginCaptures": { "0": { "name": "keyword.operator.type.tsx" } }, "end": "(?=\\S)" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))keyof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.operator.expression.keyof.tsx" }, { "match": "(\\?|\\:)", "name": "keyword.operator.ternary.tsx" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))import(?=\\s*\\()", "name": "keyword.operator.expression.import.tsx" }] }, "type-parameters": { "begin": "(<)", "beginCaptures": { "1": { "name": "punctuation.definition.typeparameters.begin.tsx" } }, "end": "(>)", "endCaptures": { "1": { "name": "punctuation.definition.typeparameters.end.tsx" } }, "name": "meta.type.parameters.tsx", "patterns": [{ "include": "#comment" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(extends|in|out|const)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "storage.modifier.tsx" }, { "include": "#type" }, { "include": "#punctuation-comma" }, { "match": "(=)(?!>)", "name": "keyword.operator.assignment.tsx" }] }, "type-paren-or-function-parameters": { "begin": "\\(", "beginCaptures": { "0": { "name": "meta.brace.round.tsx" } }, "end": "\\)", "endCaptures": { "0": { "name": "meta.brace.round.tsx" } }, "name": "meta.type.paren.cover.tsx", "patterns": [{ "captures": { "1": { "name": "storage.modifier.tsx" }, "2": { "name": "keyword.operator.rest.tsx" }, "3": { "name": "entity.name.function.tsx variable.language.this.tsx" }, "4": { "name": "entity.name.function.tsx" }, "5": { "name": "keyword.operator.optional.tsx" } }, "match": "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))\\s*(\\??)(?=\\s*(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))))" }, { "captures": { "1": { "name": "storage.modifier.tsx" }, "2": { "name": "keyword.operator.rest.tsx" }, "3": { "name": "variable.parameter.tsx variable.language.this.tsx" }, "4": { "name": "variable.parameter.tsx" }, "5": { "name": "keyword.operator.optional.tsx" } }, "match": "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))\\s*(\\??)(?=:)" }, { "include": "#type-annotation" }, { "match": ",", "name": "punctuation.separator.parameter.tsx" }, { "include": "#type" }] }, "type-predicate-operator": { "patterns": [{ "captures": { "1": { "name": "keyword.operator.type.asserts.tsx" }, "2": { "name": "variable.parameter.tsx variable.language.this.tsx" }, "3": { "name": "variable.parameter.tsx" }, "4": { "name": "keyword.operator.expression.is.tsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(asserts)\\s+)?(?!asserts)(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))\\s(is)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))" }, { "captures": { "1": { "name": "keyword.operator.type.asserts.tsx" }, "2": { "name": "variable.parameter.tsx variable.language.this.tsx" }, "3": { "name": "variable.parameter.tsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(asserts)\\s+(?!is)(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))asserts(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.operator.type.asserts.tsx" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))is(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "keyword.operator.expression.is.tsx" }] }, "type-primitive": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(string|number|bigint|boolean|symbol|any|void|never|unknown)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "support.type.primitive.tsx" }, "type-string": { "patterns": [{ "include": "#qstring-single" }, { "include": "#qstring-double" }, { "include": "#template-type" }] }, "type-tuple": { "begin": "\\[", "beginCaptures": { "0": { "name": "meta.brace.square.tsx" } }, "end": "\\]", "endCaptures": { "0": { "name": "meta.brace.square.tsx" } }, "name": "meta.type.tuple.tsx", "patterns": [{ "match": "\\.\\.\\.", "name": "keyword.operator.rest.tsx" }, { "captures": { "1": { "name": "entity.name.label.tsx" }, "2": { "name": "keyword.operator.optional.tsx" }, "3": { "name": "punctuation.separator.label.tsx" } }, "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))([_$[:alpha:]][_$[:alnum:]]*)\\s*(\\?)?\\s*(:)" }, { "include": "#type" }, { "include": "#punctuation-comma" }] }, "typeof-operator": { "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))typeof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "beginCaptures": { "0": { "name": "keyword.operator.expression.typeof.tsx" } }, "end": "(?=[,);}\\]=>:&|{\\?]|(extends\\s+)|$|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))", "patterns": [{ "include": "#type-arguments" }, { "include": "#expression" }] }, "undefined-literal": { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))undefined(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "constant.language.undefined.tsx" }, "var-expr": { "patterns": [{ "begin": "(?=(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(var|let)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))", "end": "(?!(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(var|let)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))((?=^|;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))|((?<!^let|[^\\._$[:alnum:]]let|^var|[^\\._$[:alnum:]]var)(?=\\s*$)))", "name": "meta.var.expr.tsx", "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(var|let)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*", "beginCaptures": { "1": { "name": "keyword.control.export.tsx" }, "2": { "name": "storage.modifier.tsx" }, "3": { "name": "storage.type.tsx" } }, "end": "(?=\\S)" }, { "include": "#destructuring-variable" }, { "include": "#var-single-variable" }, { "include": "#variable-initializer" }, { "include": "#comment" }, { "begin": "(,)\\s*(?=$|\\/\\/)", "beginCaptures": { "1": { "name": "punctuation.separator.comma.tsx" } }, "end": "(?<!,)(((?==|;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|^\\s*$))|((?<=\\S)(?=\\s*$)))", "patterns": [{ "include": "#single-line-comment-consuming-line-ending" }, { "include": "#comment" }, { "include": "#destructuring-variable" }, { "include": "#var-single-variable" }, { "include": "#punctuation-comma" }] }, { "include": "#punctuation-comma" }] }, { "begin": "(?=(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(const(?!\\s+enum\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))", "beginCaptures": { "1": { "name": "keyword.control.export.tsx" }, "2": { "name": "storage.modifier.tsx" }, "3": { "name": "storage.type.tsx" } }, "end": "(?!(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(const(?!\\s+enum\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))((?=^|;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))|((?<!^const|[^\\._$[:alnum:]]const)(?=\\s*$)))", "name": "meta.var.expr.tsx", "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(const(?!\\s+enum\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*", "beginCaptures": { "1": { "name": "keyword.control.export.tsx" }, "2": { "name": "storage.modifier.tsx" }, "3": { "name": "storage.type.tsx" } }, "end": "(?=\\S)" }, { "include": "#destructuring-const" }, { "include": "#var-single-const" }, { "include": "#variable-initializer" }, { "include": "#comment" }, { "begin": "(,)\\s*(?=$|\\/\\/)", "beginCaptures": { "1": { "name": "punctuation.separator.comma.tsx" } }, "end": "(?<!,)(((?==|;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|^\\s*$))|((?<=\\S)(?=\\s*$)))", "patterns": [{ "include": "#single-line-comment-consuming-line-ending" }, { "include": "#comment" }, { "include": "#destructuring-const" }, { "include": "#var-single-const" }, { "include": "#punctuation-comma" }] }, { "include": "#punctuation-comma" }] }, { "begin": "(?=(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b((?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))", "beginCaptures": { "1": { "name": "keyword.control.export.tsx" }, "2": { "name": "storage.modifier.tsx" }, "3": { "name": "storage.type.tsx" } }, "end": "(?!(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b((?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))((?=;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b))|((?<!^using|[^\\._$[:alnum:]]using|^await\\s+using|[^\\._$[:alnum:]]await\\s+using)(?=\\s*$)))", "name": "meta.var.expr.tsx", "patterns": [{ "begin": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b((?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*", "beginCaptures": { "1": { "name": "keyword.control.export.tsx" }, "2": { "name": "storage.modifier.tsx" }, "3": { "name": "storage.type.tsx" } }, "end": "(?=\\S)" }, { "include": "#var-single-const" }, { "include": "#variable-initializer" }, { "include": "#comment" }, { "begin": "(,)\\s*((?!\\S)|(?=\\/\\/))", "beginCaptures": { "1": { "name": "punctuation.separator.comma.tsx" } }, "end": "(?<!,)(((?==|;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|^\\s*$))|((?<=\\S)(?=\\s*$)))", "patterns": [{ "include": "#single-line-comment-consuming-line-ending" }, { "include": "#comment" }, { "include": "#var-single-const" }, { "include": "#punctuation-comma" }] }, { "include": "#punctuation-comma" }] }] }, "var-single-const": { "patterns": [{ "begin": "(?x)([_$[:alpha:]][_$[:alnum:]]*)(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))", "beginCaptures": { "1": { "name": "meta.definition.variable.tsx variable.other.constant.tsx entity.name.function.tsx" } }, "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|(;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b)))", "name": "meta.var-single-variable.expr.tsx", "patterns": [{ "include": "#var-single-variable-type-annotation" }] }, { "begin": "([_$[:alpha:]][_$[:alnum:]]*)", "beginCaptures": { "1": { "name": "meta.definition.variable.tsx variable.other.constant.tsx" } }, "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|(;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b)))", "name": "meta.var-single-variable.expr.tsx", "patterns": [{ "include": "#var-single-variable-type-annotation" }] }] }, "var-single-variable": { "patterns": [{ "begin": "(?x)([_$[:alpha:]][_$[:alnum:]]*)(\\!)?(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))", "beginCaptures": { "1": { "name": "meta.definition.variable.tsx entity.name.function.tsx" }, "2": { "name": "keyword.operator.definiteassignment.tsx" } }, "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|(;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b)))", "name": "meta.var-single-variable.expr.tsx", "patterns": [{ "include": "#var-single-variable-type-annotation" }] }, { "begin": "([[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])(\\!)?", "beginCaptures": { "1": { "name": "meta.definition.variable.tsx variable.other.constant.tsx" }, "2": { "name": "keyword.operator.definiteassignment.tsx" } }, "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|(;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b)))", "name": "meta.var-single-variable.expr.tsx", "patterns": [{ "include": "#var-single-variable-type-annotation" }] }, { "begin": "([_$[:alpha:]][_$[:alnum:]]*)(\\!)?", "beginCaptures": { "1": { "name": "meta.definition.variable.tsx variable.other.readwrite.tsx" }, "2": { "name": "keyword.operator.definiteassignment.tsx" } }, "end": "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|(;|^\\s*$|(?:^\\s*(?:abstract|async|(?:\\bawait\\s+(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)\\b)|break|case|catch|class|const|continue|declare|do|else|enum|export|finally|function|for|goto|if|import|interface|let|module|namespace|switch|return|throw|try|type|(?:\\busing(?=\\s+(?!in\\b|of\\b(?!\\s*(?:of\\b|=)))[_$[:alpha:]])\\b)|var|while)\\b)))", "name": "meta.var-single-variable.expr.tsx", "patterns": [{ "include": "#var-single-variable-type-annotation" }] }] }, "var-single-variable-type-annotation": { "patterns": [{ "include": "#type-annotation" }, { "include": "#string" }, { "include": "#comment" }] }, "variable-initializer": { "patterns": [{ "begin": "(?<!=|!)(=)(?!=)(?=\\s*\\S)(?!\\s*.*=>\\s*$)", "beginCaptures": { "1": { "name": "keyword.operator.assignment.tsx" } }, "end": "(?=$|^|[,);}\\]]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))", "patterns": [{ "include": "#expression" }] }, { "begin": "(?<!=|!)(=)(?!=)", "beginCaptures": { "1": { "name": "keyword.operator.assignment.tsx" } }, "end": "(?=[,);}\\]]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))|(?=^\\s*$)|(?<![\\|\\&\\+\\-\\*\\/])(?<=\\S)(?<!=)(?=\\s*$)", "patterns": [{ "include": "#expression" }] }] } }, "scopeName": "source.tsx" });
var tsx = [
  lang$b
];
var lang$a = Object.freeze({ "displayName": "JSON", "name": "json", "patterns": [{ "include": "#value" }], "repository": { "array": { "begin": "\\[", "beginCaptures": { "0": { "name": "punctuation.definition.array.begin.json" } }, "end": "\\]", "endCaptures": { "0": { "name": "punctuation.definition.array.end.json" } }, "name": "meta.structure.array.json", "patterns": [{ "include": "#value" }, { "match": ",", "name": "punctuation.separator.array.json" }, { "match": "[^\\s\\]]", "name": "invalid.illegal.expected-array-separator.json" }] }, "comments": { "patterns": [{ "begin": "/\\*\\*(?!/)", "captures": { "0": { "name": "punctuation.definition.comment.json" } }, "end": "\\*/", "name": "comment.block.documentation.json" }, { "begin": "/\\*", "captures": { "0": { "name": "punctuation.definition.comment.json" } }, "end": "\\*/", "name": "comment.block.json" }, { "captures": { "1": { "name": "punctuation.definition.comment.json" } }, "match": "(//).*$\\n?", "name": "comment.line.double-slash.js" }] }, "constant": { "match": "\\b(?:true|false|null)\\b", "name": "constant.language.json" }, "number": { "match": "(?x)        # turn on extended mode\n  -?        # an optional minus\n  (?:\n    0       # a zero\n    |       # ...or...\n    [1-9]   # a 1-9 character\n    \\d*     # followed by zero or more digits\n  )\n  (?:\n    (?:\n      \\.    # a period\n      \\d+   # followed by one or more digits\n    )?\n    (?:\n      [eE]  # an e character\n      [+-]? # followed by an option +/-\n      \\d+   # followed by one or more digits\n    )?      # make exponent optional\n  )?        # make decimal portion optional", "name": "constant.numeric.json" }, "object": { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.dictionary.begin.json" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.dictionary.end.json" } }, "name": "meta.structure.dictionary.json", "patterns": [{ "comment": "the JSON object key", "include": "#objectkey" }, { "include": "#comments" }, { "begin": ":", "beginCaptures": { "0": { "name": "punctuation.separator.dictionary.key-value.json" } }, "end": "(,)|(?=\\})", "endCaptures": { "1": { "name": "punctuation.separator.dictionary.pair.json" } }, "name": "meta.structure.dictionary.value.json", "patterns": [{ "comment": "the JSON object value", "include": "#value" }, { "match": "[^\\s,]", "name": "invalid.illegal.expected-dictionary-separator.json" }] }, { "match": "[^\\s\\}]", "name": "invalid.illegal.expected-dictionary-separator.json" }] }, "objectkey": { "begin": '"', "beginCaptures": { "0": { "name": "punctuation.support.type.property-name.begin.json" } }, "end": '"', "endCaptures": { "0": { "name": "punctuation.support.type.property-name.end.json" } }, "name": "string.json support.type.property-name.json", "patterns": [{ "include": "#stringcontent" }] }, "string": { "begin": '"', "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.json" } }, "end": '"', "endCaptures": { "0": { "name": "punctuation.definition.string.end.json" } }, "name": "string.quoted.double.json", "patterns": [{ "include": "#stringcontent" }] }, "stringcontent": { "patterns": [{ "match": '(?x)                # turn on extended mode\n  \\\\                # a literal backslash\n  (?:               # ...followed by...\n    ["\\\\/bfnrt]     # one of these characters\n    |               # ...or...\n    u               # a u\n    [0-9a-fA-F]{4}) # and four hex digits', "name": "constant.character.escape.json" }, { "match": "\\\\.", "name": "invalid.illegal.unrecognized-string-escape.json" }] }, "value": { "patterns": [{ "include": "#constant" }, { "include": "#number" }, { "include": "#string" }, { "include": "#array" }, { "include": "#object" }, { "include": "#comments" }] } }, "scopeName": "source.json" });
var json = [
  lang$a
];
var lang$9 = Object.freeze({ "displayName": "JSON with Comments", "name": "jsonc", "patterns": [{ "include": "#value" }], "repository": { "array": { "begin": "\\[", "beginCaptures": { "0": { "name": "punctuation.definition.array.begin.json.comments" } }, "end": "\\]", "endCaptures": { "0": { "name": "punctuation.definition.array.end.json.comments" } }, "name": "meta.structure.array.json.comments", "patterns": [{ "include": "#value" }, { "match": ",", "name": "punctuation.separator.array.json.comments" }, { "match": "[^\\s\\]]", "name": "invalid.illegal.expected-array-separator.json.comments" }] }, "comments": { "patterns": [{ "begin": "/\\*\\*(?!/)", "captures": { "0": { "name": "punctuation.definition.comment.json.comments" } }, "end": "\\*/", "name": "comment.block.documentation.json.comments" }, { "begin": "/\\*", "captures": { "0": { "name": "punctuation.definition.comment.json.comments" } }, "end": "\\*/", "name": "comment.block.json.comments" }, { "captures": { "1": { "name": "punctuation.definition.comment.json.comments" } }, "match": "(//).*$\\n?", "name": "comment.line.double-slash.js" }] }, "constant": { "match": "\\b(?:true|false|null)\\b", "name": "constant.language.json.comments" }, "number": { "match": "(?x)        # turn on extended mode\n  -?        # an optional minus\n  (?:\n    0       # a zero\n    |       # ...or...\n    [1-9]   # a 1-9 character\n    \\d*     # followed by zero or more digits\n  )\n  (?:\n    (?:\n      \\.    # a period\n      \\d+   # followed by one or more digits\n    )?\n    (?:\n      [eE]  # an e character\n      [+-]? # followed by an option +/-\n      \\d+   # followed by one or more digits\n    )?      # make exponent optional\n  )?        # make decimal portion optional", "name": "constant.numeric.json.comments" }, "object": { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.dictionary.begin.json.comments" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.dictionary.end.json.comments" } }, "name": "meta.structure.dictionary.json.comments", "patterns": [{ "comment": "the JSON object key", "include": "#objectkey" }, { "include": "#comments" }, { "begin": ":", "beginCaptures": { "0": { "name": "punctuation.separator.dictionary.key-value.json.comments" } }, "end": "(,)|(?=\\})", "endCaptures": { "1": { "name": "punctuation.separator.dictionary.pair.json.comments" } }, "name": "meta.structure.dictionary.value.json.comments", "patterns": [{ "comment": "the JSON object value", "include": "#value" }, { "match": "[^\\s,]", "name": "invalid.illegal.expected-dictionary-separator.json.comments" }] }, { "match": "[^\\s\\}]", "name": "invalid.illegal.expected-dictionary-separator.json.comments" }] }, "objectkey": { "begin": '"', "beginCaptures": { "0": { "name": "punctuation.support.type.property-name.begin.json.comments" } }, "end": '"', "endCaptures": { "0": { "name": "punctuation.support.type.property-name.end.json.comments" } }, "name": "string.json.comments support.type.property-name.json.comments", "patterns": [{ "include": "#stringcontent" }] }, "string": { "begin": '"', "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.json.comments" } }, "end": '"', "endCaptures": { "0": { "name": "punctuation.definition.string.end.json.comments" } }, "name": "string.quoted.double.json.comments", "patterns": [{ "include": "#stringcontent" }] }, "stringcontent": { "patterns": [{ "match": '(?x)                # turn on extended mode\n  \\\\                # a literal backslash\n  (?:               # ...followed by...\n    ["\\\\/bfnrt]     # one of these characters\n    |               # ...or...\n    u               # a u\n    [0-9a-fA-F]{4}) # and four hex digits', "name": "constant.character.escape.json.comments" }, { "match": "\\\\.", "name": "invalid.illegal.unrecognized-string-escape.json.comments" }] }, "value": { "patterns": [{ "include": "#constant" }, { "include": "#number" }, { "include": "#string" }, { "include": "#array" }, { "include": "#object" }, { "include": "#comments" }] } }, "scopeName": "source.json.comments" });
var jsonc = [
  lang$9
];
var lang$8 = Object.freeze({ "displayName": "JSON5", "fileTypes": ["json5"], "name": "json5", "patterns": [{ "include": "#comments" }, { "include": "#value" }], "repository": { "array": { "begin": "\\[", "beginCaptures": { "0": { "name": "punctuation.definition.array.begin.json5" } }, "end": "\\]", "endCaptures": { "0": { "name": "punctuation.definition.array.end.json5" } }, "name": "meta.structure.array.json5", "patterns": [{ "include": "#comments" }, { "include": "#value" }, { "match": ",", "name": "punctuation.separator.array.json5" }, { "match": "[^\\s\\]]", "name": "invalid.illegal.expected-array-separator.json5" }] }, "comments": { "patterns": [{ "match": "/{2}.*", "name": "comment.single.json5" }, { "begin": "/\\*\\*(?!/)", "captures": { "0": { "name": "punctuation.definition.comment.json5" } }, "end": "\\*/", "name": "comment.block.documentation.json5" }, { "begin": "/\\*", "captures": { "0": { "name": "punctuation.definition.comment.json5" } }, "end": "\\*/", "name": "comment.block.json5" }] }, "constant": { "match": "\\b(?:true|false|null|Infinity|NaN)\\b", "name": "constant.language.json5" }, "infinity": { "match": "(-)*\\b(?:Infinity|NaN)\\b", "name": "constant.language.json5" }, "key": { "name": "string.key.json5", "patterns": [{ "include": "#stringSingle" }, { "include": "#stringDouble" }, { "match": "[a-zA-Z0-9_-]", "name": "string.key.json5" }] }, "number": { "patterns": [{ "comment": "handles hexadecimal numbers", "match": "(0x)[0-9a-fA-f]*", "name": "constant.hex.numeric.json5" }, { "comment": "handles integer and decimal numbers", "match": "[+-.]?(?=[1-9]|0(?!\\d))\\d+(\\.\\d+)?([eE][+-]?\\d+)?", "name": "constant.dec.numeric.json5" }] }, "object": { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.dictionary.begin.json5" } }, "comment": "a json5 object", "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.dictionary.end.json5" } }, "name": "meta.structure.dictionary.json5", "patterns": [{ "include": "#comments" }, { "comment": "the json5 object key", "include": "#key" }, { "begin": ":", "beginCaptures": { "0": { "name": "punctuation.separator.dictionary.key-value.json5" } }, "end": "(,)|(?=\\})", "endCaptures": { "1": { "name": "punctuation.separator.dictionary.pair.json5" } }, "name": "meta.structure.dictionary.value.json5", "patterns": [{ "comment": "the json5 object value", "include": "#value" }, { "match": "[^\\s,]", "name": "invalid.illegal.expected-dictionary-separator.json5" }] }, { "match": "[^\\s\\}]", "name": "invalid.illegal.expected-dictionary-separator.json5" }] }, "stringDouble": { "begin": '["]', "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.json5" } }, "end": '["]', "endCaptures": { "0": { "name": "punctuation.definition.string.end.json5" } }, "name": "string.quoted.json5", "patterns": [{ "match": '(?x:                # turn on extended mode\n                     \\\\                # a literal backslash\n                     (?:               # ...followed by...\n                       ["\\\\/bfnrt]     # one of these characters\n                       |               # ...or...\n                       u               # a u\n                       [0-9a-fA-F]{4}  # and four hex digits\n                     )\n                   )', "name": "constant.character.escape.json5" }, { "match": "\\\\.", "name": "invalid.illegal.unrecognized-string-escape.json5" }] }, "stringSingle": { "begin": "[']", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.json5" } }, "end": "[']", "endCaptures": { "0": { "name": "punctuation.definition.string.end.json5" } }, "name": "string.quoted.json5", "patterns": [{ "match": '(?x:                # turn on extended mode\n                     \\\\                # a literal backslash\n                     (?:               # ...followed by...\n                       ["\\\\/bfnrt]     # one of these characters\n                       |               # ...or...\n                       u               # a u\n                       [0-9a-fA-F]{4}  # and four hex digits\n                     )\n                   )', "name": "constant.character.escape.json5" }, { "match": "\\\\.", "name": "invalid.illegal.unrecognized-string-escape.json5" }] }, "value": { "comment": "the 'value' diagram at http://json.org", "patterns": [{ "include": "#constant" }, { "include": "#infinity" }, { "include": "#number" }, { "include": "#stringSingle" }, { "include": "#stringDouble" }, { "include": "#array" }, { "include": "#object" }] } }, "scopeName": "source.json5" });
var json5 = [
  lang$8
];
var lang$7 = Object.freeze({ "displayName": "YAML", "name": "yaml", "patterns": [{ "include": "#comment" }, { "include": "#property" }, { "include": "#directive" }, { "match": "^---", "name": "entity.other.document.begin.yaml" }, { "match": "^\\.{3}", "name": "entity.other.document.end.yaml" }, { "include": "#node" }], "repository": { "block-collection": { "patterns": [{ "include": "#block-sequence" }, { "include": "#block-mapping" }] }, "block-mapping": { "patterns": [{ "include": "#block-pair" }] }, "block-node": { "patterns": [{ "include": "#prototype" }, { "include": "#block-scalar" }, { "include": "#block-collection" }, { "include": "#flow-scalar-plain-out" }, { "include": "#flow-node" }] }, "block-pair": { "patterns": [{ "begin": "\\?", "beginCaptures": { "1": { "name": "punctuation.definition.key-value.begin.yaml" } }, "end": "(?=\\?)|^ *(:)|(:)", "endCaptures": { "1": { "name": "punctuation.separator.key-value.mapping.yaml" }, "2": { "name": "invalid.illegal.expected-newline.yaml" } }, "name": "meta.block-mapping.yaml", "patterns": [{ "include": "#block-node" }] }, { "begin": "(?x)\n                        (?=\n                            (?x:\n                                  [^\\s[-?:,\\[\\]{}#&*!|>'\"%@`]]\n                                | [?:-] \\S\n                            )\n                            (\n                                  [^\\s:]\n                                | : \\S\n                                | \\s+ (?![#\\s])\n                            )*\n                            \\s*\n                            :\n							(\\s|$)\n                        )\n                    ", "end": "(?x)\n                        (?=\n                              \\s* $\n                            | \\s+ \\#\n                            | \\s* : (\\s|$)\n                        )\n                    ", "patterns": [{ "include": "#flow-scalar-plain-out-implicit-type" }, { "begin": "(?x)\n                                  [^\\s[-?:,\\[\\]{}#&*!|>'\"%@`]]\n                                | [?:-] \\S\n                            ", "beginCaptures": { "0": { "name": "entity.name.tag.yaml" } }, "contentName": "entity.name.tag.yaml", "end": "(?x)\n                                (?=\n                                      \\s* $\n                                    | \\s+ \\#\n                                    | \\s* : (\\s|$)\n                                )\n                            ", "name": "string.unquoted.plain.out.yaml" }] }, { "match": ":(?=\\s|$)", "name": "punctuation.separator.key-value.mapping.yaml" }] }, "block-scalar": { "begin": "(?:(\\|)|(>))([1-9])?([-+])?(.*\\n?)", "beginCaptures": { "1": { "name": "keyword.control.flow.block-scalar.literal.yaml" }, "2": { "name": "keyword.control.flow.block-scalar.folded.yaml" }, "3": { "name": "constant.numeric.indentation-indicator.yaml" }, "4": { "name": "storage.modifier.chomping-indicator.yaml" }, "5": { "patterns": [{ "include": "#comment" }, { "match": ".+", "name": "invalid.illegal.expected-comment-or-newline.yaml" }] } }, "end": "^(?=\\S)|(?!\\G)", "patterns": [{ "begin": "^([ ]+)(?! )", "end": "^(?!\\1|\\s*$)", "name": "string.unquoted.block.yaml" }] }, "block-sequence": { "match": "(-)(?!\\S)", "name": "punctuation.definition.block.sequence.item.yaml" }, "comment": { "begin": "(?:(^[ \\t]*)|[ \\t]+)(?=#\\p{Print}*$)", "beginCaptures": { "1": { "name": "punctuation.whitespace.comment.leading.yaml" } }, "end": "(?!\\G)", "patterns": [{ "begin": "#", "beginCaptures": { "0": { "name": "punctuation.definition.comment.yaml" } }, "end": "\\n", "name": "comment.line.number-sign.yaml" }] }, "directive": { "begin": "^%", "beginCaptures": { "0": { "name": "punctuation.definition.directive.begin.yaml" } }, "end": "(?=$|[ \\t]+($|#))", "name": "meta.directive.yaml", "patterns": [{ "captures": { "1": { "name": "keyword.other.directive.yaml.yaml" }, "2": { "name": "constant.numeric.yaml-version.yaml" } }, "match": "\\G(YAML)[ \\t]+(\\d+\\.\\d+)" }, { "captures": { "1": { "name": "keyword.other.directive.tag.yaml" }, "2": { "name": "storage.type.tag-handle.yaml" }, "3": { "name": "support.type.tag-prefix.yaml" } }, "match": "(?x)\n                        \\G\n                        (TAG)\n                        (?:[ \\t]+\n                            ((?:!(?:[0-9A-Za-z\\-]*!)?))\n                            (?:[ \\t]+ (\n                                  !              (?x: %[0-9A-Fa-f]{2} | [0-9A-Za-z\\-#;/?:@&=+$,_.!~*'()\\[\\]] )*\n                                | (?![,!\\[\\]{}]) (?x: %[0-9A-Fa-f]{2} | [0-9A-Za-z\\-#;/?:@&=+$,_.!~*'()\\[\\]] )+\n                                )\n                            )?\n                        )?\n                    " }, { "captures": { "1": { "name": "support.other.directive.reserved.yaml" }, "2": { "name": "string.unquoted.directive-name.yaml" }, "3": { "name": "string.unquoted.directive-parameter.yaml" } }, "match": "(?x) \\G (\\w+) (?:[ \\t]+ (\\w+) (?:[ \\t]+ (\\w+))? )?" }, { "match": "\\S+", "name": "invalid.illegal.unrecognized.yaml" }] }, "flow-alias": { "captures": { "1": { "name": "keyword.control.flow.alias.yaml" }, "2": { "name": "punctuation.definition.alias.yaml" }, "3": { "name": "variable.other.alias.yaml" }, "4": { "name": "invalid.illegal.character.anchor.yaml" } }, "match": "((\\*))([^\\s\\[\\]/{/},]+)([^\\s\\]},]\\S*)?" }, "flow-collection": { "patterns": [{ "include": "#flow-sequence" }, { "include": "#flow-mapping" }] }, "flow-mapping": { "begin": "\\{", "beginCaptures": { "0": { "name": "punctuation.definition.mapping.begin.yaml" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.mapping.end.yaml" } }, "name": "meta.flow-mapping.yaml", "patterns": [{ "include": "#prototype" }, { "match": ",", "name": "punctuation.separator.mapping.yaml" }, { "include": "#flow-pair" }] }, "flow-node": { "patterns": [{ "include": "#prototype" }, { "include": "#flow-alias" }, { "include": "#flow-collection" }, { "include": "#flow-scalar" }] }, "flow-pair": { "patterns": [{ "begin": "\\?", "beginCaptures": { "0": { "name": "punctuation.definition.key-value.begin.yaml" } }, "end": "(?=[},\\]])", "name": "meta.flow-pair.explicit.yaml", "patterns": [{ "include": "#prototype" }, { "include": "#flow-pair" }, { "include": "#flow-node" }, { "begin": ":(?=\\s|$|[\\[\\]{},])", "beginCaptures": { "0": { "name": "punctuation.separator.key-value.mapping.yaml" } }, "end": "(?=[},\\]])", "patterns": [{ "include": "#flow-value" }] }] }, { "begin": "(?x)\n                        (?=\n                            (?:\n                                [^\\s[-?:,\\[\\]{}#&*!|>'\"%@`]]\n                              | [?:-] [^\\s[\\[\\]{},]]\n                            )\n                            (\n                                  [^\\s:[\\[\\]{},]]\n                                | : [^\\s[\\[\\]{},]]\n                                | \\s+ (?![#\\s])\n                            )*\n                            \\s*\n                            :\n							(\\s|$)\n                        )\n                    ", "end": "(?x)\n                        (?=\n                              \\s* $\n                            | \\s+ \\#\n                            | \\s* : (\\s|$)\n                            | \\s* : [\\[\\]{},]\n                            | \\s* [\\[\\]{},]\n                        )\n                    ", "name": "meta.flow-pair.key.yaml", "patterns": [{ "include": "#flow-scalar-plain-in-implicit-type" }, { "begin": "(?x)\n                                  [^\\s[-?:,\\[\\]{}#&*!|>'\"%@`]]\n                                | [?:-] [^\\s[\\[\\]{},]]\n                            ", "beginCaptures": { "0": { "name": "entity.name.tag.yaml" } }, "contentName": "entity.name.tag.yaml", "end": "(?x)\n                                (?=\n                                      \\s* $\n                                    | \\s+ \\#\n                                    | \\s* : (\\s|$)\n                                    | \\s* : [\\[\\]{},]\n                                    | \\s* [\\[\\]{},]\n                                )\n                            ", "name": "string.unquoted.plain.in.yaml" }] }, { "include": "#flow-node" }, { "begin": ":(?=\\s|$|[\\[\\]{},])", "captures": { "0": { "name": "punctuation.separator.key-value.mapping.yaml" } }, "end": "(?=[},\\]])", "name": "meta.flow-pair.yaml", "patterns": [{ "include": "#flow-value" }] }] }, "flow-scalar": { "patterns": [{ "include": "#flow-scalar-double-quoted" }, { "include": "#flow-scalar-single-quoted" }, { "include": "#flow-scalar-plain-in" }] }, "flow-scalar-double-quoted": { "begin": '"', "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.yaml" } }, "end": '"', "endCaptures": { "0": { "name": "punctuation.definition.string.end.yaml" } }, "name": "string.quoted.double.yaml", "patterns": [{ "match": '\\\\([0abtnvfre "/\\\\N_Lp]|x\\d\\d|u\\d{4}|U\\d{8})', "name": "constant.character.escape.yaml" }, { "match": "\\\\\\n", "name": "constant.character.escape.double-quoted.newline.yaml" }] }, "flow-scalar-plain-in": { "patterns": [{ "include": "#flow-scalar-plain-in-implicit-type" }, { "begin": "(?x)\n                          [^\\s[-?:,\\[\\]{}#&*!|>'\"%@`]]\n                        | [?:-] [^\\s[\\[\\]{},]]\n                    ", "end": "(?x)\n                        (?=\n                              \\s* $\n                            | \\s+ \\#\n                            | \\s* : (\\s|$)\n                            | \\s* : [\\[\\]{},]\n                            | \\s* [\\[\\]{},]\n                        )\n                    ", "name": "string.unquoted.plain.in.yaml" }] }, "flow-scalar-plain-in-implicit-type": { "patterns": [{ "captures": { "1": { "name": "constant.language.null.yaml" }, "2": { "name": "constant.language.boolean.yaml" }, "3": { "name": "constant.numeric.integer.yaml" }, "4": { "name": "constant.numeric.float.yaml" }, "5": { "name": "constant.other.timestamp.yaml" }, "6": { "name": "constant.language.value.yaml" }, "7": { "name": "constant.language.merge.yaml" } }, "match": "(?x)\n                        (?x:\n                              (null|Null|NULL|~)\n                            | (y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF)\n                            | (\n                                (?:\n                                      [-+]? 0b [0-1_]+ # (base 2)\n                                    | [-+]? 0  [0-7_]+ # (base 8)\n                                    | [-+]? (?: 0|[1-9][0-9_]*) # (base 10)\n                                    | [-+]? 0x [0-9a-fA-F_]+ # (base 16)\n                                    | [-+]? [1-9] [0-9_]* (?: :[0-5]?[0-9])+ # (base 60)\n                                )\n                              )\n                            | (\n                                (?x:\n                                      [-+]? (?: [0-9] [0-9_]*)? \\. [0-9.]* (?: [eE] [-+] [0-9]+)? # (base 10)\n                                    | [-+]? [0-9] [0-9_]* (?: :[0-5]?[0-9])+ \\. [0-9_]* # (base 60)\n                                    | [-+]? \\. (?: inf|Inf|INF) # (infinity)\n                                    |       \\. (?: nan|NaN|NAN) # (not a number)\n                                )\n                              )\n                            | (\n                                (?x:\n                                    \\d{4} - \\d{2} - \\d{2}           # (y-m-d)\n                                  | \\d{4}                           # (year)\n                                    - \\d{1,2}                       # (month)\n                                    - \\d{1,2}                       # (day)\n                                    (?: [Tt] | [ \\t]+) \\d{1,2}      # (hour)\n                                    : \\d{2}                         # (minute)\n                                    : \\d{2}                         # (second)\n                                    (?: \\.\\d*)?                     # (fraction)\n                                    (?:\n                                          (?:[ \\t]*) Z\n                                        | [-+] \\d{1,2} (?: :\\d{1,2})?\n                                    )?                              # (time zone)\n                                )\n                              )\n                            | (=)\n                            | (<<)\n                        )\n                        (?:\n                            (?=\n                                  \\s* $\n                                | \\s+ \\#\n                                | \\s* : (\\s|$)\n                                | \\s* : [\\[\\]{},]\n                                | \\s* [\\[\\]{},]\n                            )\n                        )\n                    " }] }, "flow-scalar-plain-out": { "patterns": [{ "include": "#flow-scalar-plain-out-implicit-type" }, { "begin": "(?x)\n                          [^\\s[-?:,\\[\\]{}#&*!|>'\"%@`]]\n                        | [?:-] \\S\n                    ", "end": "(?x)\n                        (?=\n                              \\s* $\n                            | \\s+ \\#\n                            | \\s* : (\\s|$)\n                        )\n                    ", "name": "string.unquoted.plain.out.yaml" }] }, "flow-scalar-plain-out-implicit-type": { "patterns": [{ "captures": { "1": { "name": "constant.language.null.yaml" }, "2": { "name": "constant.language.boolean.yaml" }, "3": { "name": "constant.numeric.integer.yaml" }, "4": { "name": "constant.numeric.float.yaml" }, "5": { "name": "constant.other.timestamp.yaml" }, "6": { "name": "constant.language.value.yaml" }, "7": { "name": "constant.language.merge.yaml" } }, "match": "(?x)\n                        (?x:\n                              (null|Null|NULL|~)\n                            | (y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF)\n                            | (\n                                (?:\n                                      [-+]? 0b [0-1_]+ # (base 2)\n                                    | [-+]? 0  [0-7_]+ # (base 8)\n                                    | [-+]? (?: 0|[1-9][0-9_]*) # (base 10)\n                                    | [-+]? 0x [0-9a-fA-F_]+ # (base 16)\n                                    | [-+]? [1-9] [0-9_]* (?: :[0-5]?[0-9])+ # (base 60)\n                                )\n                              )\n                            | (\n                                (?x:\n                                      [-+]? (?: [0-9] [0-9_]*)? \\. [0-9.]* (?: [eE] [-+] [0-9]+)? # (base 10)\n                                    | [-+]? [0-9] [0-9_]* (?: :[0-5]?[0-9])+ \\. [0-9_]* # (base 60)\n                                    | [-+]? \\. (?: inf|Inf|INF) # (infinity)\n                                    |       \\. (?: nan|NaN|NAN) # (not a number)\n                                )\n                              )\n                            | (\n                                (?x:\n                                    \\d{4} - \\d{2} - \\d{2}           # (y-m-d)\n                                  | \\d{4}                           # (year)\n                                    - \\d{1,2}                       # (month)\n                                    - \\d{1,2}                       # (day)\n                                    (?: [Tt] | [ \\t]+) \\d{1,2}      # (hour)\n                                    : \\d{2}                         # (minute)\n                                    : \\d{2}                         # (second)\n                                    (?: \\.\\d*)?                     # (fraction)\n                                    (?:\n                                          (?:[ \\t]*) Z\n                                        | [-+] \\d{1,2} (?: :\\d{1,2})?\n                                    )?                              # (time zone)\n                                )\n                              )\n                            | (=)\n                            | (<<)\n                        )\n                        (?x:\n                            (?=\n                                  \\s* $\n                                | \\s+ \\#\n                                | \\s* : (\\s|$)\n                            )\n                        )\n                    " }] }, "flow-scalar-single-quoted": { "begin": "'", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.yaml" } }, "end": "'(?!')", "endCaptures": { "0": { "name": "punctuation.definition.string.end.yaml" } }, "name": "string.quoted.single.yaml", "patterns": [{ "match": "''", "name": "constant.character.escape.single-quoted.yaml" }] }, "flow-sequence": { "begin": "\\[", "beginCaptures": { "0": { "name": "punctuation.definition.sequence.begin.yaml" } }, "end": "\\]", "endCaptures": { "0": { "name": "punctuation.definition.sequence.end.yaml" } }, "name": "meta.flow-sequence.yaml", "patterns": [{ "include": "#prototype" }, { "match": ",", "name": "punctuation.separator.sequence.yaml" }, { "include": "#flow-pair" }, { "include": "#flow-node" }] }, "flow-value": { "patterns": [{ "begin": "\\G(?![},\\]])", "end": "(?=[},\\]])", "name": "meta.flow-pair.value.yaml", "patterns": [{ "include": "#flow-node" }] }] }, "node": { "patterns": [{ "include": "#block-node" }] }, "property": { "begin": "(?=!|&)", "end": "(?!\\G)", "name": "meta.property.yaml", "patterns": [{ "captures": { "1": { "name": "keyword.control.property.anchor.yaml" }, "2": { "name": "punctuation.definition.anchor.yaml" }, "3": { "name": "entity.name.type.anchor.yaml" }, "4": { "name": "invalid.illegal.character.anchor.yaml" } }, "match": "\\G((&))([^\\s\\[\\]/{/},]+)(\\S+)?" }, { "match": "(?x)\n                        \\G\n                        (?:\n                            ! < (?: %[0-9A-Fa-f]{2} | [0-9A-Za-z\\-#;/?:@&=+$,_.!~*'()\\[\\]] )+ >\n                          | (?:!(?:[0-9A-Za-z\\-]*!)?) (?: %[0-9A-Fa-f]{2} | [0-9A-Za-z\\-#;/?:@&=+$_.~*'()] )+\n                          | !\n                        )\n                        (?=\\ |\\t|$)\n                    ", "name": "storage.type.tag-handle.yaml" }, { "match": "\\S+", "name": "invalid.illegal.tag-handle.yaml" }] }, "prototype": { "patterns": [{ "include": "#comment" }, { "include": "#property" }] } }, "scopeName": "source.yaml", "aliases": ["yml"] });
var yaml = [
  lang$7
];
var lang$6 = Object.freeze({ "displayName": "TOML", "fileTypes": ["toml"], "name": "toml", "patterns": [{ "include": "#comments" }, { "include": "#groups" }, { "include": "#key_pair" }, { "include": "#invalid" }], "repository": { "comments": { "begin": "(^[ \\t]+)?(?=#)", "beginCaptures": { "1": { "name": "punctuation.whitespace.comment.leading.toml" } }, "end": "(?!\\G)", "patterns": [{ "begin": "#", "beginCaptures": { "0": { "name": "punctuation.definition.comment.toml" } }, "end": "\\n", "name": "comment.line.number-sign.toml" }] }, "groups": { "patterns": [{ "captures": { "1": { "name": "punctuation.definition.section.begin.toml" }, "2": { "patterns": [{ "match": "[^\\s.]+", "name": "entity.name.section.toml" }] }, "3": { "name": "punctuation.definition.section.begin.toml" } }, "match": "^\\s*(\\[)([^\\[\\]]*)(\\])", "name": "meta.group.toml" }, { "captures": { "1": { "name": "punctuation.definition.section.begin.toml" }, "2": { "patterns": [{ "match": "[^\\s.]+", "name": "entity.name.section.toml" }] }, "3": { "name": "punctuation.definition.section.begin.toml" } }, "match": "^\\s*(\\[\\[)([^\\[\\]]*)(\\]\\])", "name": "meta.group.double.toml" }] }, "invalid": { "match": "\\S+(\\s*(?=\\S))?", "name": "invalid.illegal.not-allowed-here.toml" }, "key_pair": { "patterns": [{ "begin": "([A-Za-z0-9_-]+)\\s*(=)\\s*", "captures": { "1": { "name": "variable.other.key.toml" }, "2": { "name": "punctuation.separator.key-value.toml" } }, "end": "(?<=\\S)(?<!=)|$", "patterns": [{ "include": "#primatives" }] }, { "begin": '((")(.*?)("))\\s*(=)\\s*', "captures": { "1": { "name": "variable.other.key.toml" }, "2": { "name": "punctuation.definition.variable.begin.toml" }, "3": { "patterns": [{ "match": '\\\\([btnfr"\\\\]|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})', "name": "constant.character.escape.toml" }, { "match": '\\\\[^btnfr"\\\\]', "name": "invalid.illegal.escape.toml" }, { "match": '"', "name": "invalid.illegal.not-allowed-here.toml" }] }, "4": { "name": "punctuation.definition.variable.end.toml" }, "5": { "name": "punctuation.separator.key-value.toml" } }, "end": "(?<=\\S)(?<!=)|$", "patterns": [{ "include": "#primatives" }] }, { "begin": "((')([^']*)('))\\s*(=)\\s*", "captures": { "1": { "name": "variable.other.key.toml" }, "2": { "name": "punctuation.definition.variable.begin.toml" }, "4": { "name": "punctuation.definition.variable.end.toml" }, "5": { "name": "punctuation.separator.key-value.toml" } }, "end": "(?<=\\S)(?<!=)|$", "patterns": [{ "include": "#primatives" }] }, { "begin": `(?x)
						(
							(
								(?:
									[A-Za-z0-9_-]+				# Bare key
								  | "  (?:[^"\\\\]|\\\\.)* "		# Double quoted key
								  | ' [^']*          '		# Sindle quoted key
								)
								(?:
									\\s* \\. \\s*					# Dot
								  | (?= \\s* =)					#   or look-ahead for equals
								)
							){2,}								# Ensure at least one dot
						)
						\\s*(=)\\s*
					`, "captures": { "1": { "name": "variable.other.key.toml", "patterns": [{ "match": "\\.", "name": "punctuation.separator.variable.toml" }, { "captures": { "1": { "name": "punctuation.definition.variable.begin.toml" }, "2": { "patterns": [{ "match": '\\\\([btnfr"\\\\]|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})', "name": "constant.character.escape.toml" }, { "match": '\\\\[^btnfr"\\\\]', "name": "invalid.illegal.escape.toml" }] }, "3": { "name": "punctuation.definition.variable.end.toml" } }, "match": '(")((?:[^"\\\\]|\\\\.)*)(")' }, { "captures": { "1": { "name": "punctuation.definition.variable.begin.toml" }, "2": { "name": "punctuation.definition.variable.end.toml" } }, "match": "(')[^']*(')" }] }, "3": { "name": "punctuation.separator.key-value.toml" } }, "comment": "Dotted key", "end": "(?<=\\S)(?<!=)|$", "patterns": [{ "include": "#primatives" }] }] }, "primatives": { "patterns": [{ "begin": '\\G"""', "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.toml" } }, "end": '"{3,5}', "endCaptures": { "0": { "name": "punctuation.definition.string.end.toml" } }, "name": "string.quoted.triple.double.toml", "patterns": [{ "match": '\\\\([btnfr"\\\\]|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})', "name": "constant.character.escape.toml" }, { "match": '\\\\[^btnfr"\\\\\\n]', "name": "invalid.illegal.escape.toml" }] }, { "begin": '\\G"', "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.toml" } }, "end": '"', "endCaptures": { "0": { "name": "punctuation.definition.string.end.toml" } }, "name": "string.quoted.double.toml", "patterns": [{ "match": '\\\\([btnfr"\\\\]|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})', "name": "constant.character.escape.toml" }, { "match": '\\\\[^btnfr"\\\\]', "name": "invalid.illegal.escape.toml" }] }, { "begin": "\\G'''", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.toml" } }, "end": "'{3,5}", "endCaptures": { "0": { "name": "punctuation.definition.string.end.toml" } }, "name": "string.quoted.triple.single.toml" }, { "begin": "\\G'", "beginCaptures": { "0": { "name": "punctuation.definition.string.begin.toml" } }, "end": "'", "endCaptures": { "0": { "name": "punctuation.definition.string.end.toml" } }, "name": "string.quoted.single.toml" }, { "match": "\\G(?x)\n						[0-9]{4}\n						-\n						(0[1-9]|1[012])\n						-\n						(?!00|3[2-9])[0-3][0-9]\n						(\n							[Tt ]\n							(?!2[5-9])[0-2][0-9]\n							:\n							[0-5][0-9]\n							:\n							(?!6[1-9])[0-6][0-9]\n							(\\.[0-9]+)?\n							(\n								Z\n							  | [+-](?!2[5-9])[0-2][0-9]:[0-5][0-9]\n							)?\n						)?\n					", "name": "constant.other.date.toml" }, { "match": "\\G(?x)\n						(?!2[5-9])[0-2][0-9]\n						:\n						[0-5][0-9]\n						:\n						(?!6[1-9])[0-6][0-9]\n						(\\.[0-9]+)?\n					", "name": "constant.other.time.toml" }, { "match": "\\G(true|false)", "name": "constant.language.boolean.toml" }, { "match": "\\G0x\\h(\\h|_\\h)*", "name": "constant.numeric.hex.toml" }, { "match": "\\G0o[0-7]([0-7]|_[0-7])*", "name": "constant.numeric.octal.toml" }, { "match": "\\G0b[01]([01]|_[01])*", "name": "constant.numeric.binary.toml" }, { "match": "\\G[+-]?(inf|nan)", "name": "constant.numeric.toml" }, { "match": "(?x)\n						\\G\n						(\n						    [+-]?\n						    (\n								0\n							  | ([1-9](([0-9]|_[0-9])+)?)\n							)\n						)\n						(?=[.eE])\n						(\n						    \\.\n						    ([0-9](([0-9]|_[0-9])+)?)\n						)?\n						(\n						    [eE]\n						    ([+-]?[0-9](([0-9]|_[0-9])+)?)\n						)?\n					", "name": "constant.numeric.float.toml" }, { "match": "(?x)\n						\\G\n						(\n						    [+-]?\n						    (\n								0\n							  | ([1-9](([0-9]|_[0-9])+)?)\n							)\n						)\n					", "name": "constant.numeric.integer.toml" }, { "begin": "\\G\\[", "beginCaptures": { "0": { "name": "punctuation.definition.array.begin.toml" } }, "end": "\\]", "endCaptures": { "0": { "name": "punctuation.definition.array.end.toml" } }, "name": "meta.array.toml", "patterns": [{ "begin": `(?=["'']|[+-]?[0-9]|[+-]?(inf|nan)|true|false|\\[|\\{)`, "end": ",|(?=])", "endCaptures": { "0": { "name": "punctuation.separator.array.toml" } }, "patterns": [{ "include": "#primatives" }, { "include": "#comments" }, { "include": "#invalid" }] }, { "include": "#comments" }, { "include": "#invalid" }] }, { "begin": "\\G\\{", "beginCaptures": { "0": { "name": "punctuation.definition.inline-table.begin.toml" } }, "end": "\\}", "endCaptures": { "0": { "name": "punctuation.definition.inline-table.end.toml" } }, "name": "meta.inline-table.toml", "patterns": [{ "begin": "(?=\\S)", "end": ",|(?=})", "endCaptures": { "0": { "name": "punctuation.separator.inline-table.toml" } }, "patterns": [{ "include": "#key_pair" }] }, { "include": "#comments" }] }] } }, "scopeName": "source.toml" });
var toml = [
  lang$6
];
var lang$5 = Object.freeze({ "displayName": "GraphQL", "fileTypes": ["graphql", "graphqls", "gql", "graphcool"], "name": "graphql", "patterns": [{ "include": "#graphql" }], "repository": { "graphql": { "patterns": [{ "include": "#graphql-comment" }, { "include": "#graphql-description-docstring" }, { "include": "#graphql-description-singleline" }, { "include": "#graphql-fragment-definition" }, { "include": "#graphql-directive-definition" }, { "include": "#graphql-type-interface" }, { "include": "#graphql-enum" }, { "include": "#graphql-scalar" }, { "include": "#graphql-union" }, { "include": "#graphql-schema" }, { "include": "#graphql-operation-def" }, { "include": "#literal-quasi-embedded" }] }, "graphql-ampersand": { "captures": { "1": { "name": "keyword.operator.logical.graphql" } }, "match": "\\s*(&)" }, "graphql-arguments": { "begin": "\\s*(\\()", "beginCaptures": { "1": { "name": "meta.brace.round.directive.graphql" } }, "end": "\\s*(\\))", "endCaptures": { "1": { "name": "meta.brace.round.directive.graphql" } }, "name": "meta.arguments.graphql", "patterns": [{ "include": "#graphql-comment" }, { "include": "#graphql-description-docstring" }, { "include": "#graphql-description-singleline" }, { "begin": "\\s*([_A-Za-z][_0-9A-Za-z]*)(?:\\s*(:))", "beginCaptures": { "1": { "name": "variable.parameter.graphql" }, "2": { "name": "punctuation.colon.graphql" } }, "end": "(?=\\s*(?:(?:([_A-Za-z][_0-9A-Za-z]*)\\s*(:))|\\)))|\\s*(,)", "endCaptures": { "3": { "name": "punctuation.comma.graphql" } }, "patterns": [{ "include": "#graphql-comment" }, { "include": "#graphql-description-docstring" }, { "include": "#graphql-description-singleline" }, { "include": "#graphql-directive" }, { "include": "#graphql-value" }, { "include": "#graphql-skip-newlines" }] }, { "include": "#literal-quasi-embedded" }] }, "graphql-boolean-value": { "captures": { "1": { "name": "constant.language.boolean.graphql" } }, "match": "\\s*\\b(true|false)\\b" }, "graphql-colon": { "captures": { "1": { "name": "punctuation.colon.graphql" } }, "match": "\\s*(:)" }, "graphql-comma": { "captures": { "1": { "name": "punctuation.comma.graphql" } }, "match": "\\s*(,)" }, "graphql-comment": { "patterns": [{ "captures": { "1": { "name": "punctuation.whitespace.comment.leading.graphql" } }, "comment": "need to prefix comment space with a scope else Atom's reflow cmd doesn't work", "match": "(\\s*)(#).*", "name": "comment.line.graphql.js" }, { "begin": '(""")', "beginCaptures": { "1": { "name": "punctuation.whitespace.comment.leading.graphql" } }, "end": '(""")', "name": "comment.line.graphql.js" }, { "begin": '(")', "beginCaptures": { "1": { "name": "punctuation.whitespace.comment.leading.graphql" } }, "end": '(")', "name": "comment.line.graphql.js" }] }, "graphql-description-docstring": { "begin": '"""', "end": '"""', "name": "comment.block.graphql" }, "graphql-description-singleline": { "match": '#(?=([^"]*"[^"]*")*[^"]*$).*$', "name": "comment.line.number-sign.graphql" }, "graphql-directive": { "applyEndPatternLast": 1, "begin": "\\s*((@)\\s*([_A-Za-z][_0-9A-Za-z]*))", "beginCaptures": { "1": { "name": "entity.name.function.directive.graphql" } }, "end": "(?=.)", "patterns": [{ "include": "#graphql-comment" }, { "include": "#graphql-description-docstring" }, { "include": "#graphql-description-singleline" }, { "include": "#graphql-arguments" }, { "include": "#literal-quasi-embedded" }, { "include": "#graphql-skip-newlines" }] }, "graphql-directive-definition": { "applyEndPatternLast": 1, "begin": "\\s*(\\bdirective\\b)\\s*(@[_A-Za-z][_0-9A-Za-z]*)", "beginCaptures": { "1": { "name": "keyword.directive.graphql" }, "2": { "name": "entity.name.function.directive.graphql" }, "3": { "name": "keyword.on.graphql" }, "4": { "name": "support.type.graphql" } }, "end": "(?=.)", "patterns": [{ "include": "#graphql-variable-definitions" }, { "applyEndPatternLast": 1, "begin": "\\s*(\\bon\\b)\\s*([_A-Za-z]*)", "beginCaptures": { "1": { "name": "keyword.on.graphql" }, "2": { "name": "support.type.location.graphql" } }, "end": "(?=.)", "patterns": [{ "include": "#graphql-skip-newlines" }, { "include": "#graphql-comment" }, { "include": "#literal-quasi-embedded" }, { "captures": { "2": { "name": "support.type.location.graphql" } }, "match": "\\s*(\\|)\\s*([_A-Za-z]*)" }] }, { "include": "#graphql-skip-newlines" }, { "include": "#graphql-comment" }, { "include": "#literal-quasi-embedded" }] }, "graphql-enum": { "begin": "\\s*+\\b(enum)\\b\\s*([_A-Za-z][_0-9A-Za-z]*)", "beginCaptures": { "1": { "name": "keyword.enum.graphql" }, "2": { "name": "support.type.enum.graphql" } }, "end": "(?<=})", "name": "meta.enum.graphql", "patterns": [{ "begin": "\\s*({)", "beginCaptures": { "1": { "name": "punctuation.operation.graphql" } }, "end": "\\s*(})", "endCaptures": { "1": { "name": "punctuation.operation.graphql" } }, "name": "meta.type.object.graphql", "patterns": [{ "include": "#graphql-object-type" }, { "include": "#graphql-comment" }, { "include": "#graphql-description-docstring" }, { "include": "#graphql-description-singleline" }, { "include": "#graphql-directive" }, { "include": "#graphql-enum-value" }, { "include": "#literal-quasi-embedded" }] }, { "include": "#graphql-comment" }, { "include": "#graphql-description-docstring" }, { "include": "#graphql-description-singleline" }, { "include": "#graphql-directive" }] }, "graphql-enum-value": { "match": "\\s*(?!=\\b(true|false|null)\\b)([_A-Za-z][_0-9A-Za-z]*)", "name": "constant.character.enum.graphql" }, "graphql-field": { "patterns": [{ "captures": { "1": { "name": "string.unquoted.alias.graphql" }, "2": { "name": "punctuation.colon.graphql" } }, "match": "\\s*([_A-Za-z][_0-9A-Za-z]*)\\s*(:)" }, { "captures": { "1": { "name": "variable.graphql" } }, "match": "\\s*([_A-Za-z][_0-9A-Za-z]*)" }, { "include": "#graphql-arguments" }, { "include": "#graphql-directive" }, { "include": "#graphql-selection-set" }, { "include": "#literal-quasi-embedded" }, { "include": "#graphql-skip-newlines" }] }, "graphql-float-value": { "captures": { "1": { "name": "constant.numeric.float.graphql" } }, "match": "\\s*(-?(0|[1-9][0-9]*)(\\.[0-9]+)?((e|E)(\\+|-)?[0-9]+)?)" }, "graphql-fragment-definition": { "begin": "\\s*(?:(\\bfragment\\b)\\s*([_A-Za-z][_0-9A-Za-z]*)?\\s*(?:(\\bon\\b)\\s*([_A-Za-z][_0-9A-Za-z]*)))", "captures": { "1": { "name": "keyword.fragment.graphql" }, "2": { "name": "entity.name.fragment.graphql" }, "3": { "name": "keyword.on.graphql" }, "4": { "name": "support.type.graphql" } }, "end": "(?<=})", "name": "meta.fragment.graphql", "patterns": [{ "include": "#graphql-comment" }, { "include": "#graphql-description-docstring" }, { "include": "#graphql-description-singleline" }, { "include": "#graphql-selection-set" }, { "include": "#graphql-directive" }, { "include": "#graphql-skip-newlines" }, { "include": "#literal-quasi-embedded" }] }, "graphql-fragment-spread": { "applyEndPatternLast": 1, "begin": "\\s*(\\.\\.\\.)\\s*(?!\\bon\\b)([_A-Za-z][_0-9A-Za-z]*)", "captures": { "1": { "name": "keyword.operator.spread.graphql" }, "2": { "name": "variable.fragment.graphql" } }, "end": "(?=.)", "patterns": [{ "include": "#graphql-comment" }, { "include": "#graphql-description-docstring" }, { "include": "#graphql-description-singleline" }, { "include": "#graphql-selection-set" }, { "include": "#graphql-directive" }, { "include": "#literal-quasi-embedded" }, { "include": "#graphql-skip-newlines" }] }, "graphql-ignore-spaces": { "match": "\\s*" }, "graphql-inline-fragment": { "applyEndPatternLast": 1, "begin": "\\s*(\\.\\.\\.)\\s*(?:(\\bon\\b)\\s*([_A-Za-z][_0-9A-Za-z]*))?", "captures": { "1": { "name": "keyword.operator.spread.graphql" }, "2": { "name": "keyword.on.graphql" }, "3": { "name": "support.type.graphql" } }, "end": "(?=.)", "patterns": [{ "include": "#graphql-comment" }, { "include": "#graphql-description-docstring" }, { "include": "#graphql-description-singleline" }, { "include": "#graphql-selection-set" }, { "include": "#graphql-directive" }, { "include": "#graphql-skip-newlines" }, { "include": "#literal-quasi-embedded" }] }, "graphql-input-types": { "patterns": [{ "include": "#graphql-scalar-type" }, { "captures": { "1": { "name": "support.type.graphql" }, "2": { "name": "keyword.operator.nulltype.graphql" } }, "match": "\\s*([_A-Za-z][_0-9A-Za-z]*)(?:\\s*(!))?" }, { "begin": "\\s*(\\[)", "captures": { "1": { "name": "meta.brace.square.graphql" }, "2": { "name": "keyword.operator.nulltype.graphql" } }, "end": "\\s*(\\])(?:\\s*(!))?", "name": "meta.type.list.graphql", "patterns": [{ "include": "#graphql-comment" }, { "include": "#graphql-description-docstring" }, { "include": "#graphql-description-singleline" }, { "include": "#graphql-input-types" }, { "include": "#graphql-comma" }, { "include": "#literal-quasi-embedded" }] }] }, "graphql-list-value": { "patterns": [{ "begin": "\\s*+(\\[)", "beginCaptures": { "1": { "name": "meta.brace.square.graphql" } }, "end": "\\s*(\\])", "endCaptures": { "1": { "name": "meta.brace.square.graphql" } }, "name": "meta.listvalues.graphql", "patterns": [{ "include": "#graphql-value" }] }] }, "graphql-name": { "captures": { "1": { "name": "entity.name.function.graphql" } }, "match": "\\s*([_A-Za-z][_0-9A-Za-z]*)" }, "graphql-null-value": { "captures": { "1": { "name": "constant.language.null.graphql" } }, "match": "\\s*\\b(null)\\b" }, "graphql-object-field": { "captures": { "1": { "name": "constant.object.key.graphql" }, "2": { "name": "string.unquoted.graphql" }, "3": { "name": "punctuation.graphql" } }, "match": "\\s*(([_A-Za-z][_0-9A-Za-z]*))\\s*(:)" }, "graphql-object-value": { "patterns": [{ "begin": "\\s*+({)", "beginCaptures": { "1": { "name": "meta.brace.curly.graphql" } }, "end": "\\s*(})", "endCaptures": { "1": { "name": "meta.brace.curly.graphql" } }, "name": "meta.objectvalues.graphql", "patterns": [{ "include": "#graphql-object-field" }, { "include": "#graphql-value" }] }] }, "graphql-operation-def": { "patterns": [{ "include": "#graphql-query-mutation" }, { "include": "#graphql-name" }, { "include": "#graphql-variable-definitions" }, { "include": "#graphql-directive" }, { "include": "#graphql-selection-set" }] }, "graphql-query-mutation": { "captures": { "1": { "name": "keyword.operation.graphql" } }, "match": "\\s*\\b(query|mutation)\\b" }, "graphql-scalar": { "captures": { "1": { "name": "keyword.scalar.graphql" }, "2": { "name": "entity.scalar.graphql" } }, "match": "\\s*\\b(scalar)\\b\\s*([_A-Za-z][_0-9A-Za-z]*)" }, "graphql-scalar-type": { "captures": { "1": { "name": "support.type.builtin.graphql" }, "2": { "name": "keyword.operator.nulltype.graphql" } }, "match": "\\s*\\b(Int|Float|String|Boolean|ID)\\b(?:\\s*(!))?" }, "graphql-schema": { "begin": "\\s*\\b(schema)\\b", "beginCaptures": { "1": { "name": "keyword.schema.graphql" } }, "end": "(?<=})", "patterns": [{ "begin": "\\s*({)", "beginCaptures": { "1": { "name": "punctuation.operation.graphql" } }, "end": "\\s*(})", "endCaptures": { "1": { "name": "punctuation.operation.graphql" } }, "patterns": [{ "begin": "\\s*([_A-Za-z][_0-9A-Za-z]*)(?=\\s*\\(|:)", "beginCaptures": { "1": { "name": "variable.arguments.graphql" } }, "end": "(?=\\s*(([_A-Za-z][_0-9A-Za-z]*)\\s*(\\(|:)|(})))|\\s*(,)", "endCaptures": { "5": { "name": "punctuation.comma.graphql" } }, "patterns": [{ "captures": { "1": { "name": "support.type.graphql" } }, "match": "\\s*([_A-Za-z][_0-9A-Za-z]*)" }, { "include": "#graphql-comment" }, { "include": "#graphql-description-docstring" }, { "include": "#graphql-description-singleline" }, { "include": "#graphql-colon" }, { "include": "#graphql-skip-newlines" }] }, { "include": "#graphql-comment" }, { "include": "#graphql-description-docstring" }, { "include": "#graphql-description-singleline" }, { "include": "#graphql-skip-newlines" }] }, { "include": "#graphql-comment" }, { "include": "#graphql-description-docstring" }, { "include": "#graphql-description-singleline" }, { "include": "#graphql-directive" }, { "include": "#graphql-skip-newlines" }] }, "graphql-selection-set": { "begin": "\\s*({)", "beginCaptures": { "1": { "name": "punctuation.operation.graphql" } }, "end": "\\s*(})", "endCaptures": { "1": { "name": "punctuation.operation.graphql" } }, "name": "meta.selectionset.graphql", "patterns": [{ "include": "#graphql-comment" }, { "include": "#graphql-description-docstring" }, { "include": "#graphql-description-singleline" }, { "include": "#graphql-field" }, { "include": "#graphql-fragment-spread" }, { "include": "#graphql-inline-fragment" }, { "include": "#graphql-comma" }, { "include": "#native-interpolation" }, { "include": "#literal-quasi-embedded" }] }, "graphql-skip-newlines": { "match": "\\s*\n" }, "graphql-string-content": { "patterns": [{ "match": `\\\\[/'"\\\\nrtbf]`, "name": "constant.character.escape.graphql" }, { "match": "\\\\u([0-9a-fA-F]{4})", "name": "constant.character.escape.graphql" }] }, "graphql-string-value": { "begin": '\\s*+(("))', "beginCaptures": { "1": { "name": "string.quoted.double.graphql" }, "2": { "name": "punctuation.definition.string.begin.graphql" } }, "contentName": "string.quoted.double.graphql", "end": '\\s*+(?:(("))|(\n))', "endCaptures": { "1": { "name": "string.quoted.double.graphql" }, "2": { "name": "punctuation.definition.string.end.graphql" }, "3": { "name": "invalid.illegal.newline.graphql" } }, "patterns": [{ "include": "#graphql-string-content" }, { "include": "#literal-quasi-embedded" }] }, "graphql-type-definition": { "begin": "\\s*([_A-Za-z][_0-9A-Za-z]*)(?=\\s*\\(|:)", "beginCaptures": { "1": { "name": "variable.graphql" } }, "comment": "key (optionalArgs): Type", "end": "(?=\\s*(([_A-Za-z][_0-9A-Za-z]*)\\s*(\\(|:)|(})))|\\s*(,)", "endCaptures": { "5": { "name": "punctuation.comma.graphql" } }, "patterns": [{ "include": "#graphql-comment" }, { "include": "#graphql-description-docstring" }, { "include": "#graphql-description-singleline" }, { "include": "#graphql-directive" }, { "include": "#graphql-variable-definitions" }, { "include": "#graphql-type-object" }, { "include": "#graphql-colon" }, { "include": "#graphql-input-types" }, { "include": "#literal-quasi-embedded" }] }, "graphql-type-interface": { "applyEndPatternLast": 1, "begin": "\\s*\\b(?:(extends?)?\\b\\s*\\b(type)|(interface)|(input))\\b\\s*([_A-Za-z][_0-9A-Za-z]*)?", "captures": { "1": { "name": "keyword.type.graphql" }, "2": { "name": "keyword.type.graphql" }, "3": { "name": "keyword.interface.graphql" }, "4": { "name": "keyword.input.graphql" }, "5": { "name": "support.type.graphql" } }, "end": "(?=.)", "name": "meta.type.interface.graphql", "patterns": [{ "begin": "\\s*\\b(implements)\\b\\s*", "beginCaptures": { "1": { "name": "keyword.implements.graphql" } }, "end": "\\s*(?={)", "patterns": [{ "captures": { "1": { "name": "support.type.graphql" } }, "match": "\\s*([_A-Za-z][_0-9A-Za-z]*)" }, { "include": "#graphql-comment" }, { "include": "#graphql-description-docstring" }, { "include": "#graphql-description-singleline" }, { "include": "#graphql-directive" }, { "include": "#graphql-ampersand" }, { "include": "#graphql-comma" }] }, { "include": "#graphql-comment" }, { "include": "#graphql-description-docstring" }, { "include": "#graphql-description-singleline" }, { "include": "#graphql-directive" }, { "include": "#graphql-type-object" }, { "include": "#literal-quasi-embedded" }, { "include": "#graphql-ignore-spaces" }] }, "graphql-type-object": { "begin": "\\s*({)", "beginCaptures": { "1": { "name": "punctuation.operation.graphql" } }, "end": "\\s*(})", "endCaptures": { "1": { "name": "punctuation.operation.graphql" } }, "name": "meta.type.object.graphql", "patterns": [{ "include": "#graphql-comment" }, { "include": "#graphql-description-docstring" }, { "include": "#graphql-description-singleline" }, { "include": "#graphql-object-type" }, { "include": "#graphql-type-definition" }, { "include": "#literal-quasi-embedded" }] }, "graphql-union": { "applyEndPatternLast": 1, "begin": "\\s*\\b(union)\\b\\s*([_A-Za-z][_0-9A-Za-z]*)", "captures": { "1": { "name": "keyword.union.graphql" }, "2": { "name": "support.type.graphql" } }, "end": "(?=.)", "patterns": [{ "applyEndPatternLast": 1, "begin": "\\s*(=)\\s*([_A-Za-z][_0-9A-Za-z]*)", "captures": { "1": { "name": "punctuation.assignment.graphql" }, "2": { "name": "support.type.graphql" } }, "end": "(?=.)", "patterns": [{ "include": "#graphql-comment" }, { "include": "#graphql-description-docstring" }, { "include": "#graphql-description-singleline" }, { "include": "#graphql-skip-newlines" }, { "include": "#literal-quasi-embedded" }, { "captures": { "1": { "name": "punctuation.or.graphql" }, "2": { "name": "support.type.graphql" } }, "match": "\\s*(\\|)\\s*([_A-Za-z][_0-9A-Za-z]*)" }] }, { "include": "#graphql-comment" }, { "include": "#graphql-description-docstring" }, { "include": "#graphql-description-singleline" }, { "include": "#graphql-skip-newlines" }, { "include": "#literal-quasi-embedded" }] }, "graphql-union-mark": { "captures": { "1": { "name": "punctuation.union.graphql" } }, "match": "\\s*(\\|)" }, "graphql-value": { "patterns": [{ "include": "#graphql-comment" }, { "include": "#graphql-description-docstring" }, { "include": "#graphql-variable-name" }, { "include": "#graphql-float-value" }, { "include": "#graphql-string-value" }, { "include": "#graphql-boolean-value" }, { "include": "#graphql-null-value" }, { "include": "#graphql-enum-value" }, { "include": "#graphql-list-value" }, { "include": "#graphql-object-value" }, { "include": "#literal-quasi-embedded" }] }, "graphql-variable-assignment": { "applyEndPatternLast": 1, "begin": "\\s(=)", "beginCaptures": { "1": { "name": "punctuation.assignment.graphql" } }, "end": "(?=[\n,)])", "patterns": [{ "include": "#graphql-value" }] }, "graphql-variable-definition": { "begin": "\\s*(\\$?[_A-Za-z][_0-9A-Za-z]*)(?=\\s*\\(|:)", "beginCaptures": { "1": { "name": "variable.parameter.graphql" } }, "comment": "variable: type = value,.... which may be a list", "end": "(?=\\s*((\\$?[_A-Za-z][_0-9A-Za-z]*)\\s*(\\(|:)|(}|\\))))|\\s*(,)", "endCaptures": { "5": { "name": "punctuation.comma.graphql" } }, "name": "meta.variables.graphql", "patterns": [{ "include": "#graphql-comment" }, { "include": "#graphql-description-docstring" }, { "include": "#graphql-description-singleline" }, { "include": "#graphql-directive" }, { "include": "#graphql-colon" }, { "include": "#graphql-input-types" }, { "include": "#graphql-variable-assignment" }, { "include": "#literal-quasi-embedded" }, { "include": "#graphql-skip-newlines" }] }, "graphql-variable-definitions": { "begin": "\\s*(\\()", "captures": { "1": { "name": "meta.brace.round.graphql" } }, "end": "\\s*(\\))", "patterns": [{ "include": "#graphql-comment" }, { "include": "#graphql-description-docstring" }, { "include": "#graphql-description-singleline" }, { "include": "#graphql-variable-definition" }, { "include": "#literal-quasi-embedded" }] }, "graphql-variable-name": { "captures": { "1": { "name": "variable.graphql" } }, "match": "\\s*(\\$[_A-Za-z][_0-9A-Za-z]*)" }, "native-interpolation": { "begin": "\\s*(\\${)", "beginCaptures": { "1": { "name": "keyword.other.substitution.begin" } }, "end": "(})", "endCaptures": { "1": { "name": "keyword.other.substitution.end" } }, "name": "native.interpolation", "patterns": [{ "include": "source.js" }, { "include": "source.ts" }, { "include": "source.js.jsx" }, { "include": "source.tsx" }] } }, "scopeName": "source.graphql", "embeddedLangs": ["javascript", "typescript", "jsx", "tsx"], "aliases": ["gql"] });
var graphql = [
  ...javascript,
  ...typescript,
  ...jsx,
  ...tsx,
  lang$5
];
var lang$4 = Object.freeze({ "fileTypes": [], "injectTo": ["text.html.markdown"], "injectionSelector": "L:text.html.markdown", "name": "markdown-vue", "patterns": [{ "include": "#vue-code-block" }], "repository": { "vue-code-block": { "begin": "(^|\\G)(\\s*)(`{3,}|~{3,})\\s*(?i:(vue)((\\s+|:|,|\\{|\\?)[^`~]*)?$)", "beginCaptures": { "3": { "name": "punctuation.definition.markdown" }, "4": { "name": "fenced_code.block.language.markdown" }, "5": { "name": "fenced_code.block.language.attributes.markdown" } }, "end": "(^|\\G)(\\2|\\s{0,3})(\\3)\\s*$", "endCaptures": { "3": { "name": "punctuation.definition.markdown" } }, "name": "markup.fenced_code.block.markdown", "patterns": [{ "include": "source.vue" }] } }, "scopeName": "markdown.vue.codeblock" });
var markdown_vue = [
  lang$4
];
var lang$3 = Object.freeze({ "fileTypes": [], "injectTo": ["source.vue", "text.html.markdown", "text.html.derivative", "text.pug"], "injectionSelector": "L:meta.tag -meta.attribute -entity.name.tag.pug -attribute_value -source.tsx -source.js.jsx, L:meta.element -meta.attribute", "name": "vue-directives", "patterns": [{ "include": "source.vue#vue-directives" }], "scopeName": "vue.directives" });
var vue_directives = [
  lang$3
];
var lang$2 = Object.freeze({ "fileTypes": [], "injectTo": ["source.vue", "text.html.markdown", "text.html.derivative", "text.pug"], "injectionSelector": "L:text.pug -comment -string.comment, L:text.html.derivative -comment.block, L:text.html.markdown -comment.block", "name": "vue-interpolations", "patterns": [{ "include": "source.vue#vue-interpolations" }], "scopeName": "vue.interpolations" });
var vue_interpolations = [
  lang$2
];
var lang$1 = Object.freeze({ "fileTypes": [], "injectTo": ["source.vue"], "injectionSelector": "L:source.css -comment, L:source.postcss -comment, L:source.sass -comment, L:source.stylus -comment", "name": "vue-sfc-style-variable-injection", "patterns": [{ "include": "#vue-sfc-style-variable-injection" }], "repository": { "vue-sfc-style-variable-injection": { "begin": "\\b(v-bind)\\s*\\(", "beginCaptures": { "1": { "name": "entity.name.function" } }, "end": "\\)", "name": "vue.sfc.style.variable.injection.v-bind", "patterns": [{ "begin": `('|")`, "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html" } }, "end": "(\\1)", "endCaptures": { "1": { "name": "punctuation.definition.tag.end.html" } }, "name": "source.ts.embedded.html.vue", "patterns": [{ "include": "source.js" }] }, { "include": "source.js" }] } }, "scopeName": "vue.sfc.style.variable.injection", "embeddedLangs": ["javascript"] });
var vue_sfc_style_variable_injection = [
  ...javascript,
  lang$1
];
var lang = Object.freeze({ "displayName": "Vue", "name": "vue", "patterns": [{ "include": "text.html.basic#comment" }, { "include": "#self-closing-tag" }, { "begin": "(<)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html.vue" } }, "end": "(>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.end.html.vue" } }, "patterns": [{ "begin": `([a-zA-Z0-9:-]+)\\b(?=[^>]*\\blang\\s*=\\s*(['"]?)md\\b\\2)`, "beginCaptures": { "1": { "name": "entity.name.tag.$1.html.vue" } }, "end": "(</)(\\1)\\s*(?=>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.begin.html.vue" }, "2": { "name": "entity.name.tag.$2.html.vue" } }, "patterns": [{ "include": "#tag-stuff" }, { "begin": "(?<=>)", "end": "(?=<\\/)", "name": "text.html.markdown", "patterns": [{ "include": "text.html.markdown" }] }] }, { "begin": `([a-zA-Z0-9:-]+)\\b(?=[^>]*\\blang\\s*=\\s*(['"]?)html\\b\\2)`, "beginCaptures": { "1": { "name": "entity.name.tag.$1.html.vue" } }, "end": "(</)(\\1)\\s*(?=>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.begin.html.vue" }, "2": { "name": "entity.name.tag.$2.html.vue" } }, "patterns": [{ "include": "#tag-stuff" }, { "begin": "(?<=>)", "end": "(?=<\\/)", "name": "text.html.derivative", "patterns": [{ "include": "#html-stuff" }] }] }, { "begin": `([a-zA-Z0-9:-]+)\\b(?=[^>]*\\blang\\s*=\\s*(['"]?)pug\\b\\2)`, "beginCaptures": { "1": { "name": "entity.name.tag.$1.html.vue" } }, "end": "(</)(\\1)\\s*(?=>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.begin.html.vue" }, "2": { "name": "entity.name.tag.$2.html.vue" } }, "patterns": [{ "include": "#tag-stuff" }, { "begin": "(?<=>)", "end": "(?=<\\/)", "name": "text.pug", "patterns": [{ "include": "text.pug" }] }] }, { "begin": `([a-zA-Z0-9:-]+)\\b(?=[^>]*\\blang\\s*=\\s*(['"]?)stylus\\b\\2)`, "beginCaptures": { "1": { "name": "entity.name.tag.$1.html.vue" } }, "end": "(</)(\\1)\\s*(?=>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.begin.html.vue" }, "2": { "name": "entity.name.tag.$2.html.vue" } }, "patterns": [{ "include": "#tag-stuff" }, { "begin": "(?<=>)", "end": "(?=<\\/)", "name": "source.stylus", "patterns": [{ "include": "source.stylus" }] }] }, { "begin": `([a-zA-Z0-9:-]+)\\b(?=[^>]*\\blang\\s*=\\s*(['"]?)postcss\\b\\2)`, "beginCaptures": { "1": { "name": "entity.name.tag.$1.html.vue" } }, "end": "(</)(\\1)\\s*(?=>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.begin.html.vue" }, "2": { "name": "entity.name.tag.$2.html.vue" } }, "patterns": [{ "include": "#tag-stuff" }, { "begin": "(?<=>)", "end": "(?=<\\/)", "name": "source.postcss", "patterns": [{ "include": "source.postcss" }] }] }, { "begin": `([a-zA-Z0-9:-]+)\\b(?=[^>]*\\blang\\s*=\\s*(['"]?)sass\\b\\2)`, "beginCaptures": { "1": { "name": "entity.name.tag.$1.html.vue" } }, "end": "(</)(\\1)\\s*(?=>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.begin.html.vue" }, "2": { "name": "entity.name.tag.$2.html.vue" } }, "patterns": [{ "include": "#tag-stuff" }, { "begin": "(?<=>)", "end": "(?=<\\/)", "name": "source.sass", "patterns": [{ "include": "source.sass" }] }] }, { "begin": `([a-zA-Z0-9:-]+)\\b(?=[^>]*\\blang\\s*=\\s*(['"]?)css\\b\\2)`, "beginCaptures": { "1": { "name": "entity.name.tag.$1.html.vue" } }, "end": "(</)(\\1)\\s*(?=>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.begin.html.vue" }, "2": { "name": "entity.name.tag.$2.html.vue" } }, "patterns": [{ "include": "#tag-stuff" }, { "begin": "(?<=>)", "end": "(?=<\\/)", "name": "source.css", "patterns": [{ "include": "source.css" }] }] }, { "begin": `([a-zA-Z0-9:-]+)\\b(?=[^>]*\\blang\\s*=\\s*(['"]?)scss\\b\\2)`, "beginCaptures": { "1": { "name": "entity.name.tag.$1.html.vue" } }, "end": "(</)(\\1)\\s*(?=>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.begin.html.vue" }, "2": { "name": "entity.name.tag.$2.html.vue" } }, "patterns": [{ "include": "#tag-stuff" }, { "begin": "(?<=>)", "end": "(?=<\\/)", "name": "source.css.scss", "patterns": [{ "include": "source.css.scss" }] }] }, { "begin": `([a-zA-Z0-9:-]+)\\b(?=[^>]*\\blang\\s*=\\s*(['"]?)less\\b\\2)`, "beginCaptures": { "1": { "name": "entity.name.tag.$1.html.vue" } }, "end": "(</)(\\1)\\s*(?=>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.begin.html.vue" }, "2": { "name": "entity.name.tag.$2.html.vue" } }, "patterns": [{ "include": "#tag-stuff" }, { "begin": "(?<=>)", "end": "(?=<\\/)", "name": "source.css.less", "patterns": [{ "include": "source.css.less" }] }] }, { "begin": `([a-zA-Z0-9:-]+)\\b(?=[^>]*\\blang\\s*=\\s*(['"]?)js\\b\\2)`, "beginCaptures": { "1": { "name": "entity.name.tag.$1.html.vue" } }, "end": "(</)(\\1)\\s*(?=>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.begin.html.vue" }, "2": { "name": "entity.name.tag.$2.html.vue" } }, "patterns": [{ "include": "#tag-stuff" }, { "begin": "(?<=>)", "end": "(?=<\\/)", "name": "source.js", "patterns": [{ "include": "source.js" }] }] }, { "begin": `([a-zA-Z0-9:-]+)\\b(?=[^>]*\\blang\\s*=\\s*(['"]?)ts\\b\\2)`, "beginCaptures": { "1": { "name": "entity.name.tag.$1.html.vue" } }, "end": "(</)(\\1)\\s*(?=>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.begin.html.vue" }, "2": { "name": "entity.name.tag.$2.html.vue" } }, "patterns": [{ "include": "#tag-stuff" }, { "begin": "(?<=>)", "end": "(?=<\\/)", "name": "source.ts", "patterns": [{ "include": "source.ts" }] }] }, { "begin": `([a-zA-Z0-9:-]+)\\b(?=[^>]*\\blang\\s*=\\s*(['"]?)jsx\\b\\2)`, "beginCaptures": { "1": { "name": "entity.name.tag.$1.html.vue" } }, "end": "(</)(\\1)\\s*(?=>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.begin.html.vue" }, "2": { "name": "entity.name.tag.$2.html.vue" } }, "patterns": [{ "include": "#tag-stuff" }, { "begin": "(?<=>)", "end": "(?=<\\/)", "name": "source.js.jsx", "patterns": [{ "include": "source.js.jsx" }] }] }, { "begin": `([a-zA-Z0-9:-]+)\\b(?=[^>]*\\blang\\s*=\\s*(['"]?)tsx\\b\\2)`, "beginCaptures": { "1": { "name": "entity.name.tag.$1.html.vue" } }, "end": "(</)(\\1)\\s*(?=>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.begin.html.vue" }, "2": { "name": "entity.name.tag.$2.html.vue" } }, "patterns": [{ "include": "#tag-stuff" }, { "begin": "(?<=>)", "end": "(?=<\\/)", "name": "source.tsx", "patterns": [{ "include": "source.tsx" }] }] }, { "begin": `([a-zA-Z0-9:-]+)\\b(?=[^>]*\\blang\\s*=\\s*(['"]?)json\\b\\2)`, "beginCaptures": { "1": { "name": "entity.name.tag.$1.html.vue" } }, "end": "(</)(\\1)\\s*(?=>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.begin.html.vue" }, "2": { "name": "entity.name.tag.$2.html.vue" } }, "patterns": [{ "include": "#tag-stuff" }, { "begin": "(?<=>)", "end": "(?=<\\/)", "name": "source.json", "patterns": [{ "include": "source.json" }] }] }, { "begin": `([a-zA-Z0-9:-]+)\\b(?=[^>]*\\blang\\s*=\\s*(['"]?)jsonc\\b\\2)`, "beginCaptures": { "1": { "name": "entity.name.tag.$1.html.vue" } }, "end": "(</)(\\1)\\s*(?=>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.begin.html.vue" }, "2": { "name": "entity.name.tag.$2.html.vue" } }, "patterns": [{ "include": "#tag-stuff" }, { "begin": "(?<=>)", "end": "(?=<\\/)", "name": "source.json.comments", "patterns": [{ "include": "source.json.comments" }] }] }, { "begin": `([a-zA-Z0-9:-]+)\\b(?=[^>]*\\blang\\s*=\\s*(['"]?)json5\\b\\2)`, "beginCaptures": { "1": { "name": "entity.name.tag.$1.html.vue" } }, "end": "(</)(\\1)\\s*(?=>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.begin.html.vue" }, "2": { "name": "entity.name.tag.$2.html.vue" } }, "patterns": [{ "include": "#tag-stuff" }, { "begin": "(?<=>)", "end": "(?=<\\/)", "name": "source.json5", "patterns": [{ "include": "source.json5" }] }] }, { "begin": `([a-zA-Z0-9:-]+)\\b(?=[^>]*\\blang\\s*=\\s*(['"]?)yaml\\b\\2)`, "beginCaptures": { "1": { "name": "entity.name.tag.$1.html.vue" } }, "end": "(</)(\\1)\\s*(?=>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.begin.html.vue" }, "2": { "name": "entity.name.tag.$2.html.vue" } }, "patterns": [{ "include": "#tag-stuff" }, { "begin": "(?<=>)", "end": "(?=<\\/)", "name": "source.yaml", "patterns": [{ "include": "source.yaml" }] }] }, { "begin": `([a-zA-Z0-9:-]+)\\b(?=[^>]*\\blang\\s*=\\s*(['"]?)toml\\b\\2)`, "beginCaptures": { "1": { "name": "entity.name.tag.$1.html.vue" } }, "end": "(</)(\\1)\\s*(?=>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.begin.html.vue" }, "2": { "name": "entity.name.tag.$2.html.vue" } }, "patterns": [{ "include": "#tag-stuff" }, { "begin": "(?<=>)", "end": "(?=<\\/)", "name": "source.toml", "patterns": [{ "include": "source.toml" }] }] }, { "begin": `([a-zA-Z0-9:-]+)\\b(?=[^>]*\\blang\\s*=\\s*(['"]?)(gql|graphql)\\b\\2)`, "beginCaptures": { "1": { "name": "entity.name.tag.$1.html.vue" } }, "end": "(</)(\\1)\\s*(?=>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.begin.html.vue" }, "2": { "name": "entity.name.tag.$2.html.vue" } }, "patterns": [{ "include": "#tag-stuff" }, { "begin": "(?<=>)", "end": "(?=<\\/)", "name": "source.graphql", "patterns": [{ "include": "source.graphql" }] }] }, { "begin": `([a-zA-Z0-9:-]+)\\b(?=[^>]*\\blang\\s*=\\s*(['"]?)vue\\b\\2)`, "beginCaptures": { "1": { "name": "entity.name.tag.$1.html.vue" } }, "end": "(</)(\\1)\\s*(?=>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.begin.html.vue" }, "2": { "name": "entity.name.tag.$2.html.vue" } }, "patterns": [{ "include": "#tag-stuff" }, { "begin": "(?<=>)", "end": "(?=<\\/)", "name": "source.vue", "patterns": [{ "include": "source.vue" }] }] }, { "begin": "(template)\\b", "beginCaptures": { "1": { "name": "entity.name.tag.$1.html.vue" } }, "end": "(</)(\\1)\\s*(?=>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.begin.html.vue" }, "2": { "name": "entity.name.tag.$2.html.vue" } }, "patterns": [{ "include": "#tag-stuff" }, { "begin": "(?<=>)", "end": "(?=<\\/template\\b)", "name": "text.html.derivative", "patterns": [{ "include": "#html-stuff" }] }] }, { "begin": "(script)\\b", "beginCaptures": { "1": { "name": "entity.name.tag.$1.html.vue" } }, "end": "(</)(\\1)\\s*(?=>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.begin.html.vue" }, "2": { "name": "entity.name.tag.$2.html.vue" } }, "patterns": [{ "include": "#tag-stuff" }, { "begin": "(?<=>)", "end": "(?=<\\/script\\b)", "name": "source.js", "patterns": [{ "include": "source.js" }] }] }, { "begin": "(style)\\b", "beginCaptures": { "1": { "name": "entity.name.tag.$1.html.vue" } }, "end": "(</)(\\1)\\s*(?=>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.begin.html.vue" }, "2": { "name": "entity.name.tag.$2.html.vue" } }, "patterns": [{ "include": "#tag-stuff" }, { "begin": "(?<=>)", "end": "(?=<\\/style\\b)", "name": "source.css", "patterns": [{ "include": "source.css" }] }] }, { "begin": "([a-zA-Z0-9:-]+)", "beginCaptures": { "1": { "name": "entity.name.tag.$1.html.vue" } }, "end": "(</)(\\1)\\s*(?=>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.begin.html.vue" }, "2": { "name": "entity.name.tag.$2.html.vue" } }, "patterns": [{ "include": "#tag-stuff" }, { "begin": "(?<=>)", "end": "(?=<\\/)", "name": "text" }] }] }], "repository": { "html-stuff": { "patterns": [{ "include": "#template-tag" }, { "include": "text.html.derivative" }, { "include": "text.html.basic" }] }, "self-closing-tag": { "begin": "(<)([a-zA-Z0-9:-]+)(?=([^>]+/>))", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html.vue" }, "2": { "name": "entity.name.tag.$2.html.vue" } }, "end": "(/>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.end.html.vue" } }, "name": "self-closing-tag", "patterns": [{ "include": "#tag-stuff" }] }, "tag-stuff": { "begin": "\\G", "end": "(?=/>)|(>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.end.html.vue" } }, "name": "meta.tag-stuff", "patterns": [{ "include": "#vue-directives" }, { "include": "text.html.basic#attribute" }] }, "template-tag": { "patterns": [{ "include": "#template-tag-1" }, { "include": "#template-tag-2" }] }, "template-tag-1": { "begin": "(<)(template)\\b(>)", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html.vue" }, "2": { "name": "entity.name.tag.$2.html.vue" }, "3": { "name": "punctuation.definition.tag.end.html.vue" } }, "end": "(/?>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.end.html.vue" } }, "name": "meta.template-tag.start", "patterns": [{ "begin": "\\G", "end": "(?=/>)|((</)(template)\\b)", "endCaptures": { "2": { "name": "punctuation.definition.tag.begin.html.vue" }, "3": { "name": "entity.name.tag.$3.html.vue" } }, "name": "meta.template-tag.end", "patterns": [{ "include": "#html-stuff" }] }] }, "template-tag-2": { "begin": "(<)(template)\\b", "beginCaptures": { "1": { "name": "punctuation.definition.tag.begin.html.vue" }, "2": { "name": "entity.name.tag.$2.html.vue" } }, "end": "(/?>)", "endCaptures": { "1": { "name": "punctuation.definition.tag.end.html.vue" } }, "name": "meta.template-tag.start", "patterns": [{ "begin": "\\G", "end": "(?=/>)|((</)(template)\\b)", "endCaptures": { "2": { "name": "punctuation.definition.tag.begin.html.vue" }, "3": { "name": "entity.name.tag.$3.html.vue" } }, "name": "meta.template-tag.end", "patterns": [{ "include": "#tag-stuff" }, { "include": "#html-stuff" }] }] }, "vue-directives": { "patterns": [{ "include": "#vue-directives-control" }, { "include": "#vue-directives-style-attr" }, { "include": "#vue-directives-original" }, { "include": "#vue-directives-generic-attr" }] }, "vue-directives-control": { "begin": "(v-for)|(v-if|v-else-if|v-else)", "captures": { "1": { "name": "keyword.control.loop.vue" }, "2": { "name": "keyword.control.conditional.vue" } }, "end": "(?=\\s*+[^=\\s])", "name": "meta.attribute.directive.control.vue", "patterns": [{ "include": "#vue-directives-expression" }] }, "vue-directives-expression": { "patterns": [{ "begin": "(=)\\s*('|\"|`)", "beginCaptures": { "1": { "name": "punctuation.separator.key-value.html.vue" }, "2": { "name": "punctuation.definition.string.begin.html.vue" } }, "end": "(\\2)", "endCaptures": { "1": { "name": "punctuation.definition.string.end.html.vue" } }, "patterns": [{ "begin": "(?<=('|\"|`))", "end": "(?=\\1)", "name": "source.ts.embedded.html.vue", "patterns": [{ "include": "source.ts" }] }] }, { "begin": "(=)\\s*(?=[^'\"`])", "beginCaptures": { "1": { "name": "punctuation.separator.key-value.html.vue" } }, "end": "(?=(\\s|>|\\/>))", "patterns": [{ "begin": "(?=[^'\"`])", "end": "(?=(\\s|>|\\/>))", "name": "source.ts.embedded.html.vue", "patterns": [{ "include": "source.ts" }] }] }] }, "vue-directives-generic-attr": { "begin": "\\b(generic)\\s*(=)", "captures": { "1": { "name": "entity.other.attribute-name.html.vue" }, "2": { "name": "punctuation.separator.key-value.html.vue" } }, "end": `(?<='|")`, "name": "meta.attribute.generic.vue", "patterns": [{ "begin": `('|")`, "beginCaptures": { "1": { "name": "punctuation.definition.string.begin.html.vue" } }, "comment": "https://github.com/microsoft/vscode/blob/fd4346210f59135fad81a8b8c4cea7bf5a9ca6b4/extensions/typescript-basics/syntaxes/TypeScript.tmLanguage.json#L4002-L4020", "end": "(\\1)", "endCaptures": { "1": { "name": "punctuation.definition.string.end.html.vue" } }, "name": "meta.type.parameters.vue", "patterns": [{ "include": "source.ts#comment" }, { "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(extends|in|out)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))", "name": "storage.modifier.ts" }, { "include": "source.ts#type" }, { "include": "source.ts#punctuation-comma" }, { "match": "(=)(?!>)", "name": "keyword.operator.assignment.ts" }] }] }, "vue-directives-original": { "begin": "(?:\\b(v-)|([:\\.])|(@)|(#))(\\[?)([\\w\\-]*)(\\]?)(?:\\.([\\w\\-]*))*", "beginCaptures": { "1": { "name": "entity.other.attribute-name.html.vue" }, "2": { "name": "punctuation.attribute-shorthand.bind.html.vue" }, "3": { "name": "punctuation.attribute-shorthand.event.html.vue" }, "4": { "name": "punctuation.attribute-shorthand.slot.html.vue" }, "5": { "name": "punctuation.separator.key-value.html.vue" }, "6": { "name": "entity.other.attribute-name.html.vue" }, "7": { "name": "punctuation.separator.key-value.html.vue" }, "8": { "name": "entity.other.attribute-name.html.vue" }, "9": { "name": "punctuation.separator.key-value.html.vue" } }, "end": "(?=\\s*+[^=\\s])", "endCaptures": { "1": { "name": "punctuation.definition.string.end.html.vue" } }, "name": "meta.attribute.directive.vue", "patterns": [{ "include": "#vue-directives-expression" }] }, "vue-directives-style-attr": { "begin": "\\b(style)\\s*(=)", "captures": { "1": { "name": "entity.other.attribute-name.html.vue" }, "2": { "name": "punctuation.separator.key-value.html.vue" } }, "end": `(?<='|")`, "name": "meta.attribute.style.vue", "patterns": [{ "begin": `('|")`, "beginCaptures": { "1": { "name": "punctuation.definition.string.begin.html.vue" } }, "comment": "Copy from source.css#rule-list-innards", "end": "(\\1)", "endCaptures": { "1": { "name": "punctuation.definition.string.end.html.vue" } }, "name": "source.css.embedded.html.vue", "patterns": [{ "include": "source.css#comment-block" }, { "include": "source.css#escapes" }, { "include": "source.css#font-features" }, { "match": "(?x) (?<![\\w-])\n--\n(?:[-a-zA-Z_]    | [^\\x00-\\x7F])     # First letter\n(?:[-a-zA-Z0-9_] | [^\\x00-\\x7F]      # Remainder of identifier\n  |\\\\(?:[0-9a-fA-F]{1,6}|.)\n)*", "name": "variable.css" }, { "begin": "(?<![-a-zA-Z])(?=[-a-zA-Z])", "end": "$|(?![-a-zA-Z])", "name": "meta.property-name.css", "patterns": [{ "include": "source.css#property-names" }] }, { "begin": "(:)\\s*", "beginCaptures": { "1": { "name": "punctuation.separator.key-value.css" } }, "comment": "Modify end to fix #199. TODO: handle ' character.", "contentName": "meta.property-value.css", "end": `\\s*(;)|\\s*(?='|")`, "endCaptures": { "1": { "name": "punctuation.terminator.rule.css" } }, "patterns": [{ "include": "source.css#comment-block" }, { "include": "source.css#property-values" }] }, { "match": ";", "name": "punctuation.terminator.rule.css" }] }] }, "vue-interpolations": { "patterns": [{ "begin": "(\\{\\{)", "beginCaptures": { "1": { "name": "punctuation.definition.interpolation.begin.html.vue" } }, "end": "(\\}\\})", "endCaptures": { "1": { "name": "punctuation.definition.interpolation.end.html.vue" } }, "name": "expression.embedded.vue", "patterns": [{ "begin": "\\G", "end": "(?=\\}\\})", "name": "source.ts.embedded.html.vue", "patterns": [{ "include": "source.ts" }] }] }] } }, "scopeName": "source.vue", "embeddedLangs": ["html", "markdown", "pug", "stylus", "sass", "css", "scss", "less", "javascript", "typescript", "jsx", "tsx", "json", "jsonc", "json5", "yaml", "toml", "graphql", "markdown-vue", "vue-directives", "vue-interpolations", "vue-sfc-style-variable-injection"] });
var vue = [
  ...html,
  ...markdown,
  ...pug,
  ...stylus,
  ...sass,
  ...css,
  ...scss,
  ...less,
  ...javascript,
  ...typescript,
  ...jsx,
  ...tsx,
  ...json,
  ...jsonc,
  ...json5,
  ...yaml,
  ...toml,
  ...graphql,
  ...markdown_vue,
  ...vue_directives,
  ...vue_interpolations,
  ...vue_sfc_style_variable_injection,
  lang
];
var darkPlus = Object.freeze({
  "colors": {
    "actionBar.toggledBackground": "#383a49",
    "activityBarBadge.background": "#007ACC",
    "checkbox.border": "#6B6B6B",
    "editor.background": "#1E1E1E",
    "editor.foreground": "#D4D4D4",
    "editor.inactiveSelectionBackground": "#3A3D41",
    "editor.selectionHighlightBackground": "#ADD6FF26",
    "editorIndentGuide.activeBackground": "#707070",
    "editorIndentGuide.background": "#404040",
    "input.placeholderForeground": "#A6A6A6",
    "list.activeSelectionIconForeground": "#FFF",
    "list.dropBackground": "#383B3D",
    "menu.background": "#252526",
    "menu.border": "#454545",
    "menu.foreground": "#CCCCCC",
    "menu.separatorBackground": "#454545",
    "ports.iconRunningProcessForeground": "#369432",
    "sideBarSectionHeader.background": "#0000",
    "sideBarSectionHeader.border": "#ccc3",
    "sideBarTitle.foreground": "#BBBBBB",
    "statusBarItem.remoteBackground": "#16825D",
    "statusBarItem.remoteForeground": "#FFF",
    "tab.lastPinnedBorder": "#ccc3",
    "terminal.inactiveSelectionBackground": "#3A3D41",
    "widget.border": "#303031"
  },
  "displayName": "Dark Plus",
  "name": "dark-plus",
  "semanticHighlighting": true,
  "semanticTokenColors": {
    "customLiteral": "#DCDCAA",
    "newOperator": "#C586C0",
    "numberLiteral": "#b5cea8",
    "stringLiteral": "#ce9178"
  },
  "tokenColors": [
    {
      "scope": [
        "meta.embedded",
        "source.groovy.embedded",
        "string meta.image.inline.markdown",
        "variable.legacy.builtin.python"
      ],
      "settings": {
        "foreground": "#D4D4D4"
      }
    },
    {
      "scope": "emphasis",
      "settings": {
        "fontStyle": "italic"
      }
    },
    {
      "scope": "strong",
      "settings": {
        "fontStyle": "bold"
      }
    },
    {
      "scope": "header",
      "settings": {
        "foreground": "#000080"
      }
    },
    {
      "scope": "comment",
      "settings": {
        "foreground": "#6A9955"
      }
    },
    {
      "scope": "constant.language",
      "settings": {
        "foreground": "#569cd6"
      }
    },
    {
      "scope": [
        "constant.numeric",
        "variable.other.enummember",
        "keyword.operator.plus.exponent",
        "keyword.operator.minus.exponent"
      ],
      "settings": {
        "foreground": "#b5cea8"
      }
    },
    {
      "scope": "constant.regexp",
      "settings": {
        "foreground": "#646695"
      }
    },
    {
      "scope": "entity.name.tag",
      "settings": {
        "foreground": "#569cd6"
      }
    },
    {
      "scope": "entity.name.tag.css",
      "settings": {
        "foreground": "#d7ba7d"
      }
    },
    {
      "scope": "entity.other.attribute-name",
      "settings": {
        "foreground": "#9cdcfe"
      }
    },
    {
      "scope": [
        "entity.other.attribute-name.class.css",
        "entity.other.attribute-name.class.mixin.css",
        "entity.other.attribute-name.id.css",
        "entity.other.attribute-name.parent-selector.css",
        "entity.other.attribute-name.pseudo-class.css",
        "entity.other.attribute-name.pseudo-element.css",
        "source.css.less entity.other.attribute-name.id",
        "entity.other.attribute-name.scss"
      ],
      "settings": {
        "foreground": "#d7ba7d"
      }
    },
    {
      "scope": "invalid",
      "settings": {
        "foreground": "#f44747"
      }
    },
    {
      "scope": "markup.underline",
      "settings": {
        "fontStyle": "underline"
      }
    },
    {
      "scope": "markup.bold",
      "settings": {
        "fontStyle": "bold",
        "foreground": "#569cd6"
      }
    },
    {
      "scope": "markup.heading",
      "settings": {
        "fontStyle": "bold",
        "foreground": "#569cd6"
      }
    },
    {
      "scope": "markup.italic",
      "settings": {
        "fontStyle": "italic"
      }
    },
    {
      "scope": "markup.strikethrough",
      "settings": {
        "fontStyle": "strikethrough"
      }
    },
    {
      "scope": "markup.inserted",
      "settings": {
        "foreground": "#b5cea8"
      }
    },
    {
      "scope": "markup.deleted",
      "settings": {
        "foreground": "#ce9178"
      }
    },
    {
      "scope": "markup.changed",
      "settings": {
        "foreground": "#569cd6"
      }
    },
    {
      "scope": "punctuation.definition.quote.begin.markdown",
      "settings": {
        "foreground": "#6A9955"
      }
    },
    {
      "scope": "punctuation.definition.list.begin.markdown",
      "settings": {
        "foreground": "#6796e6"
      }
    },
    {
      "scope": "markup.inline.raw",
      "settings": {
        "foreground": "#ce9178"
      }
    },
    {
      "scope": "punctuation.definition.tag",
      "settings": {
        "foreground": "#808080"
      }
    },
    {
      "scope": [
        "meta.preprocessor",
        "entity.name.function.preprocessor"
      ],
      "settings": {
        "foreground": "#569cd6"
      }
    },
    {
      "scope": "meta.preprocessor.string",
      "settings": {
        "foreground": "#ce9178"
      }
    },
    {
      "scope": "meta.preprocessor.numeric",
      "settings": {
        "foreground": "#b5cea8"
      }
    },
    {
      "scope": "meta.structure.dictionary.key.python",
      "settings": {
        "foreground": "#9cdcfe"
      }
    },
    {
      "scope": "meta.diff.header",
      "settings": {
        "foreground": "#569cd6"
      }
    },
    {
      "scope": "storage",
      "settings": {
        "foreground": "#569cd6"
      }
    },
    {
      "scope": "storage.type",
      "settings": {
        "foreground": "#569cd6"
      }
    },
    {
      "scope": [
        "storage.modifier",
        "keyword.operator.noexcept"
      ],
      "settings": {
        "foreground": "#569cd6"
      }
    },
    {
      "scope": [
        "string",
        "meta.embedded.assembly"
      ],
      "settings": {
        "foreground": "#ce9178"
      }
    },
    {
      "scope": "string.tag",
      "settings": {
        "foreground": "#ce9178"
      }
    },
    {
      "scope": "string.value",
      "settings": {
        "foreground": "#ce9178"
      }
    },
    {
      "scope": "string.regexp",
      "settings": {
        "foreground": "#d16969"
      }
    },
    {
      "scope": [
        "punctuation.definition.template-expression.begin",
        "punctuation.definition.template-expression.end",
        "punctuation.section.embedded"
      ],
      "settings": {
        "foreground": "#569cd6"
      }
    },
    {
      "scope": [
        "meta.template.expression"
      ],
      "settings": {
        "foreground": "#d4d4d4"
      }
    },
    {
      "scope": [
        "support.type.vendored.property-name",
        "support.type.property-name",
        "variable.css",
        "variable.scss",
        "variable.other.less",
        "source.coffee.embedded"
      ],
      "settings": {
        "foreground": "#9cdcfe"
      }
    },
    {
      "scope": "keyword",
      "settings": {
        "foreground": "#569cd6"
      }
    },
    {
      "scope": "keyword.control",
      "settings": {
        "foreground": "#569cd6"
      }
    },
    {
      "scope": "keyword.operator",
      "settings": {
        "foreground": "#d4d4d4"
      }
    },
    {
      "scope": [
        "keyword.operator.new",
        "keyword.operator.expression",
        "keyword.operator.cast",
        "keyword.operator.sizeof",
        "keyword.operator.alignof",
        "keyword.operator.typeid",
        "keyword.operator.alignas",
        "keyword.operator.instanceof",
        "keyword.operator.logical.python",
        "keyword.operator.wordlike"
      ],
      "settings": {
        "foreground": "#569cd6"
      }
    },
    {
      "scope": "keyword.other.unit",
      "settings": {
        "foreground": "#b5cea8"
      }
    },
    {
      "scope": [
        "punctuation.section.embedded.begin.php",
        "punctuation.section.embedded.end.php"
      ],
      "settings": {
        "foreground": "#569cd6"
      }
    },
    {
      "scope": "support.function.git-rebase",
      "settings": {
        "foreground": "#9cdcfe"
      }
    },
    {
      "scope": "constant.sha.git-rebase",
      "settings": {
        "foreground": "#b5cea8"
      }
    },
    {
      "scope": [
        "storage.modifier.import.java",
        "variable.language.wildcard.java",
        "storage.modifier.package.java"
      ],
      "settings": {
        "foreground": "#d4d4d4"
      }
    },
    {
      "scope": "variable.language",
      "settings": {
        "foreground": "#569cd6"
      }
    },
    {
      "scope": [
        "entity.name.function",
        "support.function",
        "support.constant.handlebars",
        "source.powershell variable.other.member",
        "entity.name.operator.custom-literal"
      ],
      "settings": {
        "foreground": "#DCDCAA"
      }
    },
    {
      "scope": [
        "support.class",
        "support.type",
        "entity.name.type",
        "entity.name.namespace",
        "entity.other.attribute",
        "entity.name.scope-resolution",
        "entity.name.class",
        "storage.type.numeric.go",
        "storage.type.byte.go",
        "storage.type.boolean.go",
        "storage.type.string.go",
        "storage.type.uintptr.go",
        "storage.type.error.go",
        "storage.type.rune.go",
        "storage.type.cs",
        "storage.type.generic.cs",
        "storage.type.modifier.cs",
        "storage.type.variable.cs",
        "storage.type.annotation.java",
        "storage.type.generic.java",
        "storage.type.java",
        "storage.type.object.array.java",
        "storage.type.primitive.array.java",
        "storage.type.primitive.java",
        "storage.type.token.java",
        "storage.type.groovy",
        "storage.type.annotation.groovy",
        "storage.type.parameters.groovy",
        "storage.type.generic.groovy",
        "storage.type.object.array.groovy",
        "storage.type.primitive.array.groovy",
        "storage.type.primitive.groovy"
      ],
      "settings": {
        "foreground": "#4EC9B0"
      }
    },
    {
      "scope": [
        "meta.type.cast.expr",
        "meta.type.new.expr",
        "support.constant.math",
        "support.constant.dom",
        "support.constant.json",
        "entity.other.inherited-class"
      ],
      "settings": {
        "foreground": "#4EC9B0"
      }
    },
    {
      "scope": [
        "keyword.control",
        "source.cpp keyword.operator.new",
        "keyword.operator.delete",
        "keyword.other.using",
        "keyword.other.directive.using",
        "keyword.other.operator",
        "entity.name.operator"
      ],
      "settings": {
        "foreground": "#C586C0"
      }
    },
    {
      "scope": [
        "variable",
        "meta.definition.variable.name",
        "support.variable",
        "entity.name.variable",
        "constant.other.placeholder"
      ],
      "settings": {
        "foreground": "#9CDCFE"
      }
    },
    {
      "scope": [
        "variable.other.constant",
        "variable.other.enummember"
      ],
      "settings": {
        "foreground": "#4FC1FF"
      }
    },
    {
      "scope": [
        "meta.object-literal.key"
      ],
      "settings": {
        "foreground": "#9CDCFE"
      }
    },
    {
      "scope": [
        "support.constant.property-value",
        "support.constant.font-name",
        "support.constant.media-type",
        "support.constant.media",
        "constant.other.color.rgb-value",
        "constant.other.rgb-value",
        "support.constant.color"
      ],
      "settings": {
        "foreground": "#CE9178"
      }
    },
    {
      "scope": [
        "punctuation.definition.group.regexp",
        "punctuation.definition.group.assertion.regexp",
        "punctuation.definition.character-class.regexp",
        "punctuation.character.set.begin.regexp",
        "punctuation.character.set.end.regexp",
        "keyword.operator.negation.regexp",
        "support.other.parenthesis.regexp"
      ],
      "settings": {
        "foreground": "#CE9178"
      }
    },
    {
      "scope": [
        "constant.character.character-class.regexp",
        "constant.other.character-class.set.regexp",
        "constant.other.character-class.regexp",
        "constant.character.set.regexp"
      ],
      "settings": {
        "foreground": "#d16969"
      }
    },
    {
      "scope": [
        "keyword.operator.or.regexp",
        "keyword.control.anchor.regexp"
      ],
      "settings": {
        "foreground": "#DCDCAA"
      }
    },
    {
      "scope": "keyword.operator.quantifier.regexp",
      "settings": {
        "foreground": "#d7ba7d"
      }
    },
    {
      "scope": [
        "constant.character",
        "constant.other.option"
      ],
      "settings": {
        "foreground": "#569cd6"
      }
    },
    {
      "scope": "constant.character.escape",
      "settings": {
        "foreground": "#d7ba7d"
      }
    },
    {
      "scope": "entity.name.label",
      "settings": {
        "foreground": "#C8C8C8"
      }
    }
  ],
  "type": "dark"
});
var lightPlus = Object.freeze({
  "colors": {
    "actionBar.toggledBackground": "#dddddd",
    "activityBarBadge.background": "#007ACC",
    "checkbox.border": "#919191",
    "editor.background": "#FFFFFF",
    "editor.foreground": "#000000",
    "editor.inactiveSelectionBackground": "#E5EBF1",
    "editor.selectionHighlightBackground": "#ADD6FF80",
    "editorIndentGuide.activeBackground": "#939393",
    "editorIndentGuide.background": "#D3D3D3",
    "editorSuggestWidget.background": "#F3F3F3",
    "input.placeholderForeground": "#767676",
    "list.activeSelectionIconForeground": "#FFF",
    "list.focusAndSelectionOutline": "#90C2F9",
    "list.hoverBackground": "#E8E8E8",
    "menu.border": "#D4D4D4",
    "notebook.cellBorderColor": "#E8E8E8",
    "notebook.selectedCellBackground": "#c8ddf150",
    "ports.iconRunningProcessForeground": "#369432",
    "searchEditor.textInputBorder": "#CECECE",
    "settings.numberInputBorder": "#CECECE",
    "settings.textInputBorder": "#CECECE",
    "sideBarSectionHeader.background": "#0000",
    "sideBarSectionHeader.border": "#61616130",
    "sideBarTitle.foreground": "#6F6F6F",
    "statusBarItem.errorBackground": "#c72e0f",
    "statusBarItem.remoteBackground": "#16825D",
    "statusBarItem.remoteForeground": "#FFF",
    "tab.lastPinnedBorder": "#61616130",
    "terminal.inactiveSelectionBackground": "#E5EBF1",
    "widget.border": "#d4d4d4"
  },
  "displayName": "Light Plus",
  "name": "light-plus",
  "semanticHighlighting": true,
  "semanticTokenColors": {
    "customLiteral": "#795E26",
    "newOperator": "#AF00DB",
    "numberLiteral": "#098658",
    "stringLiteral": "#a31515"
  },
  "tokenColors": [
    {
      "scope": [
        "meta.embedded",
        "source.groovy.embedded",
        "string meta.image.inline.markdown",
        "variable.legacy.builtin.python"
      ],
      "settings": {
        "foreground": "#000000ff"
      }
    },
    {
      "scope": "emphasis",
      "settings": {
        "fontStyle": "italic"
      }
    },
    {
      "scope": "strong",
      "settings": {
        "fontStyle": "bold"
      }
    },
    {
      "scope": "meta.diff.header",
      "settings": {
        "foreground": "#000080"
      }
    },
    {
      "scope": "comment",
      "settings": {
        "foreground": "#008000"
      }
    },
    {
      "scope": "constant.language",
      "settings": {
        "foreground": "#0000ff"
      }
    },
    {
      "scope": [
        "constant.numeric",
        "variable.other.enummember",
        "keyword.operator.plus.exponent",
        "keyword.operator.minus.exponent"
      ],
      "settings": {
        "foreground": "#098658"
      }
    },
    {
      "scope": "constant.regexp",
      "settings": {
        "foreground": "#811f3f"
      }
    },
    {
      "scope": "entity.name.tag",
      "settings": {
        "foreground": "#800000"
      }
    },
    {
      "scope": "entity.name.selector",
      "settings": {
        "foreground": "#800000"
      }
    },
    {
      "scope": "entity.other.attribute-name",
      "settings": {
        "foreground": "#e50000"
      }
    },
    {
      "scope": [
        "entity.other.attribute-name.class.css",
        "entity.other.attribute-name.class.mixin.css",
        "entity.other.attribute-name.id.css",
        "entity.other.attribute-name.parent-selector.css",
        "entity.other.attribute-name.pseudo-class.css",
        "entity.other.attribute-name.pseudo-element.css",
        "source.css.less entity.other.attribute-name.id",
        "entity.other.attribute-name.scss"
      ],
      "settings": {
        "foreground": "#800000"
      }
    },
    {
      "scope": "invalid",
      "settings": {
        "foreground": "#cd3131"
      }
    },
    {
      "scope": "markup.underline",
      "settings": {
        "fontStyle": "underline"
      }
    },
    {
      "scope": "markup.bold",
      "settings": {
        "fontStyle": "bold",
        "foreground": "#000080"
      }
    },
    {
      "scope": "markup.heading",
      "settings": {
        "fontStyle": "bold",
        "foreground": "#800000"
      }
    },
    {
      "scope": "markup.italic",
      "settings": {
        "fontStyle": "italic"
      }
    },
    {
      "scope": "markup.strikethrough",
      "settings": {
        "fontStyle": "strikethrough"
      }
    },
    {
      "scope": "markup.inserted",
      "settings": {
        "foreground": "#098658"
      }
    },
    {
      "scope": "markup.deleted",
      "settings": {
        "foreground": "#a31515"
      }
    },
    {
      "scope": "markup.changed",
      "settings": {
        "foreground": "#0451a5"
      }
    },
    {
      "scope": [
        "punctuation.definition.quote.begin.markdown",
        "punctuation.definition.list.begin.markdown"
      ],
      "settings": {
        "foreground": "#0451a5"
      }
    },
    {
      "scope": "markup.inline.raw",
      "settings": {
        "foreground": "#800000"
      }
    },
    {
      "scope": "punctuation.definition.tag",
      "settings": {
        "foreground": "#800000"
      }
    },
    {
      "scope": [
        "meta.preprocessor",
        "entity.name.function.preprocessor"
      ],
      "settings": {
        "foreground": "#0000ff"
      }
    },
    {
      "scope": "meta.preprocessor.string",
      "settings": {
        "foreground": "#a31515"
      }
    },
    {
      "scope": "meta.preprocessor.numeric",
      "settings": {
        "foreground": "#098658"
      }
    },
    {
      "scope": "meta.structure.dictionary.key.python",
      "settings": {
        "foreground": "#0451a5"
      }
    },
    {
      "scope": "storage",
      "settings": {
        "foreground": "#0000ff"
      }
    },
    {
      "scope": "storage.type",
      "settings": {
        "foreground": "#0000ff"
      }
    },
    {
      "scope": [
        "storage.modifier",
        "keyword.operator.noexcept"
      ],
      "settings": {
        "foreground": "#0000ff"
      }
    },
    {
      "scope": [
        "string",
        "meta.embedded.assembly"
      ],
      "settings": {
        "foreground": "#a31515"
      }
    },
    {
      "scope": [
        "string.comment.buffered.block.pug",
        "string.quoted.pug",
        "string.interpolated.pug",
        "string.unquoted.plain.in.yaml",
        "string.unquoted.plain.out.yaml",
        "string.unquoted.block.yaml",
        "string.quoted.single.yaml",
        "string.quoted.double.xml",
        "string.quoted.single.xml",
        "string.unquoted.cdata.xml",
        "string.quoted.double.html",
        "string.quoted.single.html",
        "string.unquoted.html",
        "string.quoted.single.handlebars",
        "string.quoted.double.handlebars"
      ],
      "settings": {
        "foreground": "#0000ff"
      }
    },
    {
      "scope": "string.regexp",
      "settings": {
        "foreground": "#811f3f"
      }
    },
    {
      "scope": [
        "punctuation.definition.template-expression.begin",
        "punctuation.definition.template-expression.end",
        "punctuation.section.embedded"
      ],
      "settings": {
        "foreground": "#0000ff"
      }
    },
    {
      "scope": [
        "meta.template.expression"
      ],
      "settings": {
        "foreground": "#000000"
      }
    },
    {
      "scope": [
        "support.constant.property-value",
        "support.constant.font-name",
        "support.constant.media-type",
        "support.constant.media",
        "constant.other.color.rgb-value",
        "constant.other.rgb-value",
        "support.constant.color"
      ],
      "settings": {
        "foreground": "#0451a5"
      }
    },
    {
      "scope": [
        "support.type.vendored.property-name",
        "support.type.property-name",
        "variable.css",
        "variable.scss",
        "variable.other.less",
        "source.coffee.embedded"
      ],
      "settings": {
        "foreground": "#e50000"
      }
    },
    {
      "scope": [
        "support.type.property-name.json"
      ],
      "settings": {
        "foreground": "#0451a5"
      }
    },
    {
      "scope": "keyword",
      "settings": {
        "foreground": "#0000ff"
      }
    },
    {
      "scope": "keyword.control",
      "settings": {
        "foreground": "#0000ff"
      }
    },
    {
      "scope": "keyword.operator",
      "settings": {
        "foreground": "#000000"
      }
    },
    {
      "scope": [
        "keyword.operator.new",
        "keyword.operator.expression",
        "keyword.operator.cast",
        "keyword.operator.sizeof",
        "keyword.operator.alignof",
        "keyword.operator.typeid",
        "keyword.operator.alignas",
        "keyword.operator.instanceof",
        "keyword.operator.logical.python",
        "keyword.operator.wordlike"
      ],
      "settings": {
        "foreground": "#0000ff"
      }
    },
    {
      "scope": "keyword.other.unit",
      "settings": {
        "foreground": "#098658"
      }
    },
    {
      "scope": [
        "punctuation.section.embedded.begin.php",
        "punctuation.section.embedded.end.php"
      ],
      "settings": {
        "foreground": "#800000"
      }
    },
    {
      "scope": "support.function.git-rebase",
      "settings": {
        "foreground": "#0451a5"
      }
    },
    {
      "scope": "constant.sha.git-rebase",
      "settings": {
        "foreground": "#098658"
      }
    },
    {
      "scope": [
        "storage.modifier.import.java",
        "variable.language.wildcard.java",
        "storage.modifier.package.java"
      ],
      "settings": {
        "foreground": "#000000"
      }
    },
    {
      "scope": "variable.language",
      "settings": {
        "foreground": "#0000ff"
      }
    },
    {
      "scope": [
        "entity.name.function",
        "support.function",
        "support.constant.handlebars",
        "source.powershell variable.other.member",
        "entity.name.operator.custom-literal"
      ],
      "settings": {
        "foreground": "#795E26"
      }
    },
    {
      "scope": [
        "support.class",
        "support.type",
        "entity.name.type",
        "entity.name.namespace",
        "entity.other.attribute",
        "entity.name.scope-resolution",
        "entity.name.class",
        "storage.type.numeric.go",
        "storage.type.byte.go",
        "storage.type.boolean.go",
        "storage.type.string.go",
        "storage.type.uintptr.go",
        "storage.type.error.go",
        "storage.type.rune.go",
        "storage.type.cs",
        "storage.type.generic.cs",
        "storage.type.modifier.cs",
        "storage.type.variable.cs",
        "storage.type.annotation.java",
        "storage.type.generic.java",
        "storage.type.java",
        "storage.type.object.array.java",
        "storage.type.primitive.array.java",
        "storage.type.primitive.java",
        "storage.type.token.java",
        "storage.type.groovy",
        "storage.type.annotation.groovy",
        "storage.type.parameters.groovy",
        "storage.type.generic.groovy",
        "storage.type.object.array.groovy",
        "storage.type.primitive.array.groovy",
        "storage.type.primitive.groovy"
      ],
      "settings": {
        "foreground": "#267f99"
      }
    },
    {
      "scope": [
        "meta.type.cast.expr",
        "meta.type.new.expr",
        "support.constant.math",
        "support.constant.dom",
        "support.constant.json",
        "entity.other.inherited-class"
      ],
      "settings": {
        "foreground": "#267f99"
      }
    },
    {
      "scope": [
        "keyword.control",
        "source.cpp keyword.operator.new",
        "source.cpp keyword.operator.delete",
        "keyword.other.using",
        "keyword.other.directive.using",
        "keyword.other.operator",
        "entity.name.operator"
      ],
      "settings": {
        "foreground": "#AF00DB"
      }
    },
    {
      "scope": [
        "variable",
        "meta.definition.variable.name",
        "support.variable",
        "entity.name.variable",
        "constant.other.placeholder"
      ],
      "settings": {
        "foreground": "#001080"
      }
    },
    {
      "scope": [
        "variable.other.constant",
        "variable.other.enummember"
      ],
      "settings": {
        "foreground": "#0070C1"
      }
    },
    {
      "scope": [
        "meta.object-literal.key"
      ],
      "settings": {
        "foreground": "#001080"
      }
    },
    {
      "scope": [
        "support.constant.property-value",
        "support.constant.font-name",
        "support.constant.media-type",
        "support.constant.media",
        "constant.other.color.rgb-value",
        "constant.other.rgb-value",
        "support.constant.color"
      ],
      "settings": {
        "foreground": "#0451a5"
      }
    },
    {
      "scope": [
        "punctuation.definition.group.regexp",
        "punctuation.definition.group.assertion.regexp",
        "punctuation.definition.character-class.regexp",
        "punctuation.character.set.begin.regexp",
        "punctuation.character.set.end.regexp",
        "keyword.operator.negation.regexp",
        "support.other.parenthesis.regexp"
      ],
      "settings": {
        "foreground": "#d16969"
      }
    },
    {
      "scope": [
        "constant.character.character-class.regexp",
        "constant.other.character-class.set.regexp",
        "constant.other.character-class.regexp",
        "constant.character.set.regexp"
      ],
      "settings": {
        "foreground": "#811f3f"
      }
    },
    {
      "scope": "keyword.operator.quantifier.regexp",
      "settings": {
        "foreground": "#000000"
      }
    },
    {
      "scope": [
        "keyword.operator.or.regexp",
        "keyword.control.anchor.regexp"
      ],
      "settings": {
        "foreground": "#EE0000"
      }
    },
    {
      "scope": [
        "constant.character",
        "constant.other.option"
      ],
      "settings": {
        "foreground": "#0000ff"
      }
    },
    {
      "scope": "constant.character.escape",
      "settings": {
        "foreground": "#EE0000"
      }
    },
    {
      "scope": "entity.name.label",
      "settings": {
        "foreground": "#000000"
      }
    }
  ],
  "type": "light"
});
async function registerHighlighter() {
  const highlighter = await getHighlighterCore({
    themes: [darkPlus, lightPlus],
    langs: [vue],
    loadWasm: getWasmInlined
  });
  languages$2.register({ id: "vue" });
  shikijiToMonaco(highlighter, monaco);
  return {
    light: lightPlus.name,
    dark: darkPlus.name
  };
}
export {
  registerHighlighter
};
//# sourceMappingURL=highlight-CJzieDKQ-QHLTYRVM.js.map
